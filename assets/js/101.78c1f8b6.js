(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{306:function(e,t,o){"use strict";o.r(t);var s=o(14),n=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("react Hook 发展\nVue2 的代码模式下存在的几个问题\n1、随着功能的增长，复杂组件的代码变得越来越难以维护。 尤其发生你去新接手别人的代码时。 根本原因是 Vue 的现有 API 通过「选项」组织代码，但是在大部分情况下，通过逻辑考虑来组织代码更有意义。\n2、缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制。\n3、类型推断不够友好。\nReact Hook 发展\nReact 中是经历了很长的一段发展历程的， mixin -> HOC & render-props -> Hook，mixin 是 React 中最早启用的一种逻辑复用方式，因为它的缺点实在是多到数不清，而后面的两种也有着自己的问题，比如增加组件嵌套啊、props 来源不明确啊等等。可以说到目前为止，Hook 是相对完美的一种方案。\nHook 和 Mixin & HOC 对比\nHOC 对比 Hook HOC套东西props不容易看 ，Hook逻辑清晰")]),e._v(" "),t("p",[e._v("说到这里，还是不得不把官方对于「Mixin & HOC 模式」所带来的缺点整理一下。")]),e._v(" "),t("ol",[t("li",[e._v("渲染上下文中公开的属性的来源不清楚。 例如，当使用多个 mixin 读取组件的模板时，可能很难确定从哪个 mixin 注入了特定的属性。")]),e._v(" "),t("li",[e._v("命名空间冲突。 Mixins 可能会在属性和方法名称上发生冲突，而 HOC 可能会在预期的 prop 名称上发生冲突。")]),e._v(" "),t("li",[e._v("性能问题，HOC 和无渲染组件需要额外的有状态组件实例，这会降低性能。\n而 「Hook」模式带来的好处则是：")]),e._v(" "),t("li",[e._v("暴露给模板的属性具有明确的来源，因为它们是从 Hook 函数返回的值。")]),e._v(" "),t("li",[e._v("Hook 函数返回的值可以任意命名，因此不会发生名称空间冲突。")]),e._v(" "),t("li",[e._v("没有创建仅用于逻辑重用的不必要的组件实例。\n当然，这种模式也存在一些缺点，比如 ref 带来的心智负担，详见drawbacks。\nReact Hook 和 Vue Hook 对比\n其实 React Hook 的限制非常多，比如官方文档中就专门有一个章节介绍它的限制：")]),e._v(" "),t("li",[e._v("不要在循环，条件或嵌套函数中调用 Hook")]),e._v(" "),t("li",[e._v("确保总是在你的 React 函数的最顶层调用他们。")]),e._v(" "),t("li",[e._v("遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。\n而 Vue 带来的不同在于：")]),e._v(" "),t("li",[e._v("与 React Hooks 相同级别的逻辑组合功能，但有一些重要的区别。 与 React Hook 不同，setup 函数仅被调用一次，这在性能上比较占优。")]),e._v(" "),t("li",[e._v("对调用顺序没什么要求，每次渲染中不会反复调用 Hook 函数，产生的的 GC 压力较小。")]),e._v(" "),t("li",[e._v("不必考虑几乎总是需要 useCallback 的问题，以防止传递函数prop给子组件的引用变化，导致无必要的重新渲染。")]),e._v(" "),t("li",[e._v("React Hook 有臭名昭著的闭包陷阱问题（甚至成了一道热门面试题，omg），如果用户忘记传递正确的依赖项数组，useEffect 和 useMemo 可能会捕获过时的变量，这不受此问题的影响。 Vue 的自动依赖关系跟踪确保观察者和计算值始终正确无误。")]),e._v(" "),t("li",[e._v("不得不提一句，React Hook 里的「依赖」是需要你去手动声明的，而且官方提供了一个 eslint 插件，这个插件虽然大部分时候挺有用的，但是有时候也特别烦人，需要你手动加一行丑陋的注释去关闭它。\n我们认可 React Hooks 的创造力，这也是 Vue-Composition-Api 的主要灵感来源。上面提到的问题确实存在于 React Hook 的设计中，我们注意到 Vue 的响应式模型恰好完美的解决了这些问题。\n顺嘴一题，React Hook 的心智负担是真的很严重，如果对此感兴趣的话，请参考：\nhttps://www.zhihu.com/question/350523308/answer/858145147\n并且我自己在实际开发中，也遇到了很多问题，尤其是在我想对组件用 memo 进行一些性能优化的时候，闭包的问题爆炸式的暴露了出来。最后我用 useReducer 大法解决了其中很多问题，让我不得不怀疑这从头到尾会不会就是 Dan 的阴谋……（别想逃过 reducer）")])]),e._v(" "),t("p",[e._v("对于意大利面代码：")]),e._v(" "),t("ol",[t("li",[e._v("提取共用的自定义 Hook（在写 React 购物车组件的时候，我提取了 3 个以上可以全局复用的 Hook）。")]),e._v(" "),t("li",[e._v("基于「逻辑功能」去组织代码，而不是 state 放在一块，method 放在一块，这样和用 Vue2 没什么本质上的区别（很多很多新人在用 React Hook 的时候犯这样的错误，包括我自己）。\n对于心智负担：")]),e._v(" "),t("li",[e._v("更强大的能力意味着更多的学习成本，但是 Vue3 总体而言我觉得已经把心智负担控制的很到位了。对于 ref 这个玩意，确实是需要仔细思考一下才能理解。")]),e._v(" "),t("li",[e._v("React Hook 的心智负担已经重的出名了，在我实际的开发过程中，有时候真的会被整到头秃…… 尤其是抽了一些自定义 Hook，deps 依赖会层层传递的情况下（随便哪一层的依赖错了，你的应用就爆炸了）。")])]),e._v(" "),t("p",[e._v("vue的优化做的要比react好一些。\n在React应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用")]),e._v(" "),t("p",[e._v("PureComponent，或是手动实现shouldComponentUpdate方法。同时你可能会需要使用不可变的数据结构来使得你的组件更容易被优化。然而，使用PureComponent和shouldComponentUpdate时，需要保证该组件的整个子树的渲染输出都是由该组件的props所决定的。如果不符合这个情况，那么此类优化就会导致难以察觉的渲染结果不一致。这使得React中的组件优化伴随着相当的心智负担。")]),e._v(" "),t("p",[e._v("而在做vue相关的项目时，我们只需要关注于业务逻辑，而不需要去操心是否会产生不必要的组件渲染，因为vue已经把这些麻烦的东西很好的解决了。\nvue3与React中的Hooks到底是什么 https://blog.csdn.net/web2022050903/article/details/127586707\nreact hook的各种功能")]),e._v(" "),t("p",[e._v("通过useState 函数我们可以定义多个state数据，但我们应该保证每一个state数据都具有意义，同种意义范围的state数据应该放在同一个state，而不应该拆分成2个state")]),e._v(" "),t("p",[e._v("useRef Hook 获取了DOM元素，写法和API createRef()相似。useRef只能用来保存对象，而没办法通过改变useRef.current中的对象来响应式改变页面， 如果父组件想通过ref来控制子组件中的DOM（如何传递ref对象），请使用useImperativeHandle Hook")]),e._v(" "),t("p",[e._v("Hooks与普通函数的区别\n● (也是定义，封装逻辑、逻辑的复用)官方提供的Hooks只应该在React函数组件/自定义Hooks内调用，而不应该在普通函数调用。\n● 自定义Hooks能够调用诸如useState、useRef等，普通函数则不能。由此可以通过内置的Hooks获得Fiber的访问方式，可以实现在组件级别存储数据的方案等。\n● (也是规则)自定义Hooks需要以use开头，普通函数则没有这个限制。使用use开头并不是一个语法或者一个强制性的方案，更像是一个约定，就像是GET请求约定语义不携带Body一样，使用use开头的目的就是让React识别出来这是个Hooks，从而检查这些规则约束，通常也会使用ESlint配合eslint-plugin-react-hooks检查这些规则，从而提前避免错误的使用。")]),e._v(" "),t("p",[e._v("useCallback的作用 https://blog.csdn.net/Kobe_G/article/details/121752526\nhttps://juejin.cn/post/7079663951214018596")]),e._v(" "),t("p",[e._v("useCallback的依赖是只比较值的, 如果是对象, 就是只比较引用。而textRef是一直存在不会销毁的跨生命周期对象, 引用一直不变, 相当于, useCallback的依赖为[]。使用 useRef 可以生成一个变量让其在组件每个生命周期内都能访问到，且 handleSubmit 并不会因为 text 的更新而更新，也就不会让 OtherForm 多次渲染。")]),e._v(" "),t("p",[e._v("useContext使用的问题和优化\n问题：当context中的值改变时，只要使用useContext订阅了context的组件，不管该组件用到的state改不改变，该组件都会reRender，此时用React.memo是没有办法优化的。\n优化：\n1.拆分context，把经常改变的数据和不经常改变的数据拆分开，在只使用稳定数据的组件中，我们只使用stableContext\n2.使用useMemo")]),e._v(" "),t("p",[e._v("useEffect不能滥用 https://juejin.cn/post/7182110095554117692#heading-4\nuseSyncExternalStore  用于解决外部数据撕裂问题\nuseSWR https://blog.csdn.net/qq_29722281/article/details/113034336\nuseId  在服务器和客户端生成相同的唯一一个id，避免hydrating的不兼容\nuseInsertionEffect  这个hooks只建议在css in js库中使用，这个hooks执行时机在DOM生成之后，useLayoutEffect执行之前，它的工作原理大致与useLayoutEffect相同，此时无法访问DOM节点的引用，一般用于提前注入脚本")]),e._v(" "),t("p",[e._v("「React 进阶」 React 全部 Hooks 使用大全 （包含 React v18 版本 ）https://juejin.cn/post/7118937685653192735#heading-23\n你真的理解setState吗\nhttps://juejin.cn/post/6844903636749778958")]),e._v(" "),t("p",[e._v("hooks 带来了两方面的问题，一是hooks本身的各种限制带来的心智负担，二是hook只能在function里使用导致的在function里组织业务逻辑的问题，前者大家提及的非常多了，后者带来的问题如果不妥善解决，对于代码维护同样是个灾难，class里通过method我们很容易将接口和实现分离，我读代码时并不需要去读每个method的实现，只要需要去读每个mrthod的调用就能很好的知道业务流程，但是hooks里把所有业务的实现混杂到一起，导致我读代码的时候经常被各种子业务的实现细节扰乱，难以把握业务的主要流程，更别提function里作用域不隔离，导致这里定义的变量到底给谁使用的问题，导致各种实现混杂一起，这可能需要社区慢慢积累一下最佳实践了")]),e._v(" "),t("p",[e._v("useEffect和useLayoutEffect的区别https://blog.csdn.net/AHcola233/article/details/116716316\nhttps://blog.csdn.net/qq_38164763/article/details/113532855\nhttps://zhuanlan.zhihu.com/p/346977585\nhttps://www.cnblogs.com/fulu/p/13470126.html\nuseMemo与useCallback区别 https://blog.csdn.net/s1879046/article/details/120193330?spm=1001.2014.3001.5502\nuseRef和createRef区别  https://blog.csdn.net/qq_40494944/article/details/124785746\nuseState， 变量，useRef 的时机https://blog.csdn.net/u010565037/article/details/124491244")])])}),[],!1,null,null,null);t.default=n.exports}}]);