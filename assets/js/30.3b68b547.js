(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{337:function(n,t,a){"use strict";a.r(t);var r=a(14),e=Object(r.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("什么是arguments?\n")]),n._v(" "),t("h5",{attrs:{id:"什么是arguments"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是arguments"}},[n._v("#")]),n._v(" 什么是arguments?")]),n._v(" "),t("p",[n._v("它是JS的一个内置对象，常被人们所忽略，但实际上确很重要，JS不像JAVA是显示传递参数，JS传的是形参，可以传也可以不传，若方法里没有写参数却传入了参数，该如何拿到参数呢，答案就是arguments了，在一些插件里通常这样使用。")]),n._v(" "),t("p",[n._v("每一个函数都有一个arguments对象，它包括了函数所要调的参数，通常我们把它当作数组使用，用它的length得到参数数量，但它却不是数组，使用instanceof查看下，若使用push添加数据将报错，代码如下：")]),n._v(" "),t("p",[n._v("(function(){\nconsole.log([] instanceof Array)\nconsole.log(arguments instanceof Array)\nif(arguments.push) arguments.push('test')\n})()")]),n._v(" "),t("h5",{attrs:{id:"创建一个灵活的格式化函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建一个灵活的格式化函数"}},[n._v("#")]),n._v(" 创建一个灵活的格式化函数")]),n._v(" "),t("p",[n._v("上面说了arguments可以使用函数使用数量不定的参数，下面看看它的一个实际应用：")]),n._v(" "),t("p",[n._v('function format(string) {\nvar args = arguments;\nvar pattern = new RegExp("%([1-" + arguments.length + "])", "g");\nreturn String(string).replace(pattern, function(match, index) {\nreturn args[index];\n});'),t("br"),n._v('\n};\nformat("And the %1 want to know whose %2 you %3", "papers", "shirt", "wear");')]),n._v(" "),t("p",[n._v("这里我借用了别人的一个例子，一个模板字符串，可以使用%1到%9等9个占位符，然后提供9个参数给这些占位符，最后替换生成真正的字符串。\n上面的代码返回：“And the papers want to know whose shirt you wear”")]),n._v(" "),t("h5",{attrs:{id:"把arguments转换成一个真正的数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#把arguments转换成一个真正的数组"}},[n._v("#")]),n._v(" 把arguments转换成一个真正的数组")]),n._v(" "),t("p",[n._v("有时我们希望将它转换成真正的数组使用，可以使用下面的代码：")]),n._v(" "),t("p",[n._v("var args = Array.prototype.slice.call(arguments);")]),n._v(" "),t("p",[n._v("现在args就是一个标准的js数组了，可以使用数组的标准方法了。")]),n._v(" "),t("p",[n._v("arguments允许我们去执行所有类型的js方法，下面通过一个makeFunc函数，展示了函数允许我们去提供一个函数引用和这个函数的所有参数，它将返回一个匿名函数去调用你规定的函数(就是闭包)，也提供了匿名函数调用时所附带的参数。")]),n._v(" "),t("p",[n._v("function makeFunc() {\nvar args = Array.prototype.slice.call(arguments);\nvar func = args.shift();\nreturn function() {\nreturn func.apply(null, args.concat(Array.prototype.slice.call(arguments)));\n};\n}")]),n._v(" "),t("p",[n._v("第一个arguments给makeFunc提供了你调用的函数的引用，它将第一个参数从arguments数组里移除，然后makeFunc返回了一个匿名函数去运行规定的方法。\napply的第一个参数是函数调用的范围，主要是函数内部关联部分所指向的，这里设为null，它的arguments是一个数组，即匿名函数调用时传入的参数，匿名函数将传入的参数串联到原参数对象args里组成完整的匿名函数所需要参数。")]),n._v(" "),t("p",[n._v("你需要输出一个模板，总是相同位置的字符发生改变，这样就可以使用makeFunc去生成一个模板函数，传入不同的参数多次调用生成不同的内容了")]),n._v(" "),t("p",[n._v('"I like js not java."\n"I like java not python."')]),n._v(" "),t("p",[n._v("这样封装format是不是很酷，不过arguments还有更多惊喜。")]),n._v(" "),t("h5",{attrs:{id:"创建引用自身的函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建引用自身的函数"}},[n._v("#")]),n._v(" 创建引用自身的函数")]),n._v(" "),t("p",[n._v("arguments.callee包括了一个函数的引用去创建一个arguments对象，它能让一个匿名函数很方便的指向本身。\n下面的Repeat是一个承载了一个函数引用和两个数字的函数，第一个数字是调用次数，第二个是间隔时间，单位毫秒。")]),n._v(" "),t("p",[n._v("function repeat(fn, times, delay) {\nreturn function() {\nif(times-- > 0) {\nfn.apply(null, arguments);\nvar args = Array.prototype.slice.call(arguments);\nvar self = arguments.callee;\nsetTimeout(function(){self.apply(null,args)}, delay);\n}\n};\n}")]),n._v(" "),t("p",[n._v("Repeat函数使用了arguments.callee方法从变量self获取一个引用，指向运行原始指令的函数。这样，匿名函数就可以再次调用自身，看看下面的调用：")]),n._v(" "),t("p",[n._v('var somethingWrong = repeat(function(s){console.log(s)}, 3, 2000);\nsomethingWrong("Can you hear me, major tom?");')]),n._v(" "),t("p",[n._v("可以看到somethingWrong函数的结果被打印了3次，每隔2秒。")])])}),[],!1,null,null,null);t.default=e.exports}}]);