(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{336:function(t,e,n){"use strict";n.r(e);var s=n(14),r=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("ES6 系列之箭头函数\n")]),t._v(" "),e("h5",{attrs:{id:"我们重点比较一下箭头函数与普通函数。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#我们重点比较一下箭头函数与普通函数。"}},[t._v("#")]),t._v(" 我们重点比较一下箭头函数与普通函数。")]),t._v(" "),e("h4",{attrs:{id:"_1-没有-this"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-没有-this"}},[t._v("#")]),t._v(" 1.没有 this")]),t._v(" "),e("h5",{attrs:{id:"箭头函数没有-this-所以需要通过查找作用域链来确定-this-的值。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数没有-this-所以需要通过查找作用域链来确定-this-的值。"}},[t._v("#")]),t._v(" 箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。")]),t._v(" "),e("p",[t._v("这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。")]),t._v(" "),e("p",[t._v("模拟一个实际开发中的例子：")]),t._v(" "),e("p",[t._v("我们的需求是点击一个按钮，改变该按钮的背景色。")]),t._v(" "),e("p",[t._v("为了方便开发，我们抽离一个 Button 组件，当需要使用的时候，直接：")]),t._v(" "),e("p",[t._v('// 传入元素 id 值即可绑定该元素点击时改变背景色的事件\nnew Button("button")\nHTML 代码如下：')]),t._v(" "),e("p",[e("button",{attrs:{id:"button"}},[t._v("点击变色")]),t._v("\nJavaScript 代码如下：")]),t._v(" "),e("p",[t._v('function Button(id) {\nthis.element = document.querySelector("#" + id);\nthis.bindEvent();\n}')]),t._v(" "),e("p",[t._v('Button.prototype.bindEvent = function() {\nthis.element.addEventListener("click", this.setBgColor, false);\n};')]),t._v(" "),e("p",[t._v("Button.prototype.setBgColor = function() {\nthis.element.style.backgroundColor = '#1abc9c'\n};")]),t._v(" "),e("p",[t._v("var button = new Button(\"button\");\n看着好像没有问题，结果却是报错 Uncaught TypeError: Cannot read property 'style' of undefined")]),t._v(" "),e("p",[t._v("这是因为当使用 addEventListener() 为一个元素注册事件的时候，事件函数里的 this 值是该元素的引用。")]),t._v(" "),e("p",[t._v("所以如果我们在 setBgColor 中 console.log(this)，this 指向的是按钮元素，那 this.element 就是 undefined，报错自然就理所当然了。")]),t._v(" "),e("p",[t._v("也许你会问，既然 this 都指向了按钮元素，那我们直接修改 setBgColor 函数为：")]),t._v(" "),e("p",[t._v("Button.prototype.setBgColor = function() {\nthis.style.backgroundColor = '#1abc9c'\n};")]),t._v(" "),e("p",[t._v("不就可以解决这个问题了？")]),t._v(" "),e("p",[t._v("确实可以这样做，但是在实际的开发中，我们可能会在 setBgColor 中还调用其他的函数，比如写成这种：")]),t._v(" "),e("p",[t._v("Button.prototype.setBgColor = function() {\nthis.setElementColor();\nthis.setOtherElementColor();\n};")]),t._v(" "),e("p",[t._v("所以我们还是希望 setBgColor 中的 this 是指向实例对象的，这样就可以调用其他的函数。")]),t._v(" "),e("p",[t._v("利用 ES5，我们一般会这样做：")]),t._v(" "),e("p",[t._v('Button.prototype.bindEvent = function() {\nthis.element.addEventListener("click", this.setBgColor.bind(this), false);\n};')]),t._v(" "),e("p",[t._v("为避免 addEventListener 的影响，使用 bind 强制绑定 setBgColor() 的 this 为实例对象")]),t._v(" "),e("p",[t._v("使用 ES6，我们可以更好的解决这个问题：")]),t._v(" "),e("p",[t._v('Button.prototype.bindEvent = function() {\nthis.element.addEventListener("click", event => this.setBgColor(event), false);\n};')]),t._v(" "),e("p",[t._v("由于箭头函数没有 this，所以会向外层查找 this 的值，即 bindEvent 中的 this，此时 this 指向实例对象，所以可以正确的调用 this.setBgColor 方法， 而 this.setBgColor 中的 this 也会正确指向实例对象。")]),t._v(" "),e("p",[t._v("在这里再额外提一点，就是注意 bindEvent 和 setBgColor 在这里使用的是普通函数的形式，而非箭头函数，如果我们改成箭头函数，会导致函数里的 this 指向 window 对象 (非严格模式下)。")]),t._v(" "),e("p",[t._v("最后，因为箭头函数没有 this，所以也不能用 call()、apply()、bind() 这些方法改变 this 的指向，可以看一个例子：")]),t._v(" "),e("p",[t._v("var value = 1;\nvar result = (() => this.value).bind({value: 2})();\nconsole.log(result); // 1")]),t._v(" "),e("h4",{attrs:{id:"_2-没有-arguments"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-没有-arguments"}},[t._v("#")]),t._v(" 2. 没有 arguments")]),t._v(" "),e("h5",{attrs:{id:"箭头函数没有自己的-arguments-对象-这不一定是件坏事-因为箭头函数可以访问外围函数的-arguments-对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数没有自己的-arguments-对象-这不一定是件坏事-因为箭头函数可以访问外围函数的-arguments-对象"}},[t._v("#")]),t._v(" 箭头函数没有自己的 arguments 对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象：")]),t._v(" "),e("p",[t._v("function constant() {\nreturn () => arguments[0]\n}")]),t._v(" "),e("p",[t._v("var result = constant(1);\nconsole.log(result()); // 1")]),t._v(" "),e("p",[t._v("那如果我们就是要访问箭头函数的参数呢？")]),t._v(" "),e("p",[t._v("你可以通过命名参数或者 rest 参数的形式访问参数:")]),t._v(" "),e("p",[t._v("let nums = (...nums) => nums;")]),t._v(" "),e("h4",{attrs:{id:"_3-不能通过-new-关键字调用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-不能通过-new-关键字调用"}},[t._v("#")]),t._v(" 3. 不能通过 new 关键字调用")]),t._v(" "),e("p",[t._v("JavaScript 函数有两个内部方法：[[Call]] 和 [[Construct]]。")]),t._v(" "),e("p",[t._v("当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。")]),t._v(" "),e("p",[t._v("当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。")]),t._v(" "),e("p",[t._v("箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。")]),t._v(" "),e("p",[t._v("var Foo = () => {};\nvar foo = new Foo(); // TypeError: Foo is not a constructor")]),t._v(" "),e("h4",{attrs:{id:"_4-没有-new-target"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-没有-new-target"}},[t._v("#")]),t._v(" 4. 没有 new.target")]),t._v(" "),e("p",[t._v("因为不能使用 new 调用，所以也没有 new.target 值。")]),t._v(" "),e("p",[t._v("关于 new.target，可以参考 http://es6.ruanyifeng.com/#docs/class#new-target-%E5%B1%9E%E6%80%A7")]),t._v(" "),e("h4",{attrs:{id:"_5-没有原型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-没有原型"}},[t._v("#")]),t._v(" 5. 没有原型")]),t._v(" "),e("p",[t._v("由于不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性。")]),t._v(" "),e("p",[t._v("var Foo = () => {};\nconsole.log(Foo.prototype); // undefined")]),t._v(" "),e("h4",{attrs:{id:"_6-没有-super"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-没有-super"}},[t._v("#")]),t._v(" 6. 没有 super")]),t._v(" "),e("p",[t._v("连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。")])])}),[],!1,null,null,null);e.default=r.exports}}]);