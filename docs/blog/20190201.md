---
title: JavaScript深入之继承的多种方式和优缺点 
date: 2019-02-1 17:25:23
categories:
- js
tags:
- js
---

本文讲解JavaScript各种继承方式和优缺点。
<!-- more -->

##### 1.原型链继承

        function Parent () {
            this.name = 'kevin';
        }

        Parent.prototype.getName = function () {
            console.log(this.name);
        }

        function Child () {

        }

        Child.prototype = new Parent();

        var child1 = new Child();

        console.log(child1.getName()) // kevin

问题：

1.引用类型的属性被所有实例共享，举个例子：

        function Parent () {
            this.names = ['kevin', 'daisy'];
        }

        function Child () {

        }

        Child.prototype = new Parent();

        var child1 = new Child();

        child1.names.push('yayu');

        console.log(child1.names); // ["kevin", "daisy", "yayu"]

        var child2 = new Child();

        console.log(child2.names); // ["kevin", "daisy", "yayu"]

2.在创建 Child 的实例时，不能向Parent传参

#### 2.借用构造函数(经典继承)

        function Parent () {
            this.names = ['kevin', 'daisy'];
        }

        function Child () {
            Parent.call(this);
        }

        var child1 = new Child();

        child1.names.push('yayu');

        console.log(child1.names); // ["kevin", "daisy", "yayu"]

        var child2 = new Child();

        console.log(child2.names); // ["kevin", "daisy"]

优点：

1.避免了引用类型的属性被所有实例共享

2.可以在 Child 中向 Parent 传参

举个例子：

function Parent (name) {
    this.name = name;
}

function Child (name) {
    Parent.call(this, name);
}

var child1 = new Child('kevin');

console.log(child1.name); // kevin

var child2 = new Child('daisy');

console.log(child2.name); // daisy

缺点：

方法都在构造函数中定义，每次创建实例都会创建一遍方法。

#### 3.组合继承

原型链继承和经典继承双剑合璧。

        function Parent (name) {
            this.name = name;
            this.colors = ['red', 'blue', 'green'];
        }

        Parent.prototype.getName = function () {
            console.log(this.name)
        }

        function Child (name, age) {

            Parent.call(this, name);
            
            this.age = age;

        }

        Child.prototype = new Parent();
        Child.prototype.constructor = Child;

        var child1 = new Child('kevin', '18');

        child1.colors.push('black');

        console.log(child1.name); // kevin
        console.log(child1.age); // 18
        console.log(child1.colors); // ["red", "blue", "green", "black"]

        var child2 = new Child('daisy', '20');

        console.log(child2.name); // daisy
        console.log(child2.age); // 20
        console.log(child2.colors); // ["red", "blue", "green"]

优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。

#### 4.原型式继承

        function createObj(o) {
            function F(){}
            F.prototype = o;
            return new F();
        }

就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。

缺点：

包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。

        var person = {
            name: 'kevin',
            friends: ['daisy', 'kelly']
        }

        var person1 = createObj(person);
        var person2 = createObj(person);

        person1.name = 'person1';
        console.log(person2.name); // kevin

        person1.firends.push('taylor');
        console.log(person2.friends); // ["daisy", "kelly", "taylor"]

注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = 'person1'，给person1添加了 name 值，并非修改了原型上的 name 值。


5. 寄生式继承

创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。

        function createObj (o) {
            var clone = Object.create(o);
            clone.sayName = function () {
                console.log('hi');
            }
            return clone;
        }

缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法

#### 6. 寄生组合式继承

为了方便大家阅读，在这里重复一下组合继承的代码：

        function Box(name) {
            this.name = name;
            this.arr = ['哥哥','妹妹','父母'];
        }
        Box.prototype.run = function () {
            return this.name;
        };
        function Desk(name, age) {
            Box.call(this, name);//第二次调用 Box
            this.age = age;
        }
        Desk.prototype = new Box();//第一次调用 Box

以上代码是之前的组合继承，那么寄生组合继承寄生组合继承，解决了两次调用的问题

        function obj(o) {
            function F() {}
            F.prototype = o;
            return new F();
        }
        function create(box, desk) {
            var f = obj(box.prototype);
            f.constructor = desk;
            desk.prototype = f;
        }
        function Box(name) {
            this.name = name;
            this.arr = ['哥哥','妹妹','父母'];
        }
        Box.prototype.run = function () {
            return this.name;
        };

        function Desk(name, age) {
            Box.call(this, name);
            this.age = age;
        }

        create(Box, Desk);//通过这里实现继承
        var desk = new Desk('Lee',100);
        desk.arr.push('姐姐');
        alert(desk.arr);
        alert(desk.run());//只共享了方法
        var desk2 = new Desk('Jack', 200);
        alert(desk2.arr);//引用问题解决

