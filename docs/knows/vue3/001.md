---
title: 变量，ref，reactive，toRefs
date: 2019-04-09
---


### 变量的区别点

> 只操作变量时，页面是不会响应改变的

如本例所示，“infoName” 并不是一个响应式的变量，“loading”是一个响应式的变量，但是如果“loading”的值变化，“infoName”的值也会变化，这是为什么

``` js
import { defineComponent, ref } from 'vue';

export default defineComponent({
  name: 'FittingPage',
  setup() {
    const loading = ref(true);
    let infoName = 'MYYU';
    const getList = async () => {
      new Promise(function (resolve, reject) {
        setTimeout(() => {
          resolve('step1');
          infoName = 'POOL';
          loading.value = false;
        }, 1000);
      });
    };
    getList();
    return () => (
      <div>
        {loading.value} {/*false*/}
        <span>{infoName}{/*POOL*/}</span> 
      </div>
    );
  },
});
``` 

ref 的作用是检查变化，这样在下一个时钟周期，vue 会检查哪些 ref 发生了变化，如果存在变化，着会对整个组件的参数进行 diff 运算，找到整个组件的所有参数的变化情况并更新到 dom 组件；

因此只是修改 infoName 使不会更新组件的，但是你更新了 loading ，所以当这次函数整体运行完成进入下一个周期的时候，整个组件变中心 diff 并渲染了， infoName 也就自然的被改变了。

### ref

+ 用于创建基础数据类型的响应式变量（采用复制的方式，修改响应式数据不会影响原始数据，数据发生改变，界面就会自动更新
+ reactive用来定义：对象（或数组）类型数据。
+ 备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。
+ ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。
+ reactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。
+ ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。
+ reactive定义的数据：操作数据与读取数据：均不需要.value。



``` js
setup(){
	const refA = ref(0) 
    console.log(refA.value) //需要用.value 
}
``` 

### reactive
**reactive用于创建引用类型的响应式对象**
``` js
setup(){
	const refA = reactive({
		name: "LISA",
		age: "36"
	})
    console.log(refA) //不需要用.value 
}
``` 

### toRef
**toRef接收两个参数target和attr，target是一般是reactive的响应式对象，attr是对象的属性，返回响应式变量（采用引用的方式，修改响应式数据，会影响原始数据，并且数据发生改变）**
``` js
setup(){
	const object = reactive({ name: "LISA", age: "36" })
	const refA = toRef(object, name) 
}
``` 

### toRefs
**将响应式reactive对象转换为普通对象，多用于响应式对象转为普通对象后解构（对象中的数据依旧是响应式）**
``` js
setup(){
	const refA = reactive({
		name: "LISA",
		age: "36"
	})
	return{
		...toRefs(refA) 
	}
	// 相当于return了 name: ref("LISA"),age: ref("36")
}
``` 