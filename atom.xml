<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>倘若有一天</title>
  
  <subtitle>深夜狂奔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-10T01:56:03.143Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>笑余笙</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue源码分析 - observer,dep,watch实现数据双向绑定</title>
    <link href="http://yoursite.com/post/2019-04-01-20190401/"/>
    <id>http://yoursite.com/post/2019-04-01-20190401/</id>
    <published>2019-04-01T09:25:23.000Z</published>
    <updated>2020-03-10T01:56:03.143Z</updated>
    
    <content type="html"><![CDATA[<p>vue源码分析 - observer,dep,watch,实现数据双向绑定</p><a id="more"></a><p>我们把双向数据绑定分为两个流程：</p><h4 id="1、收集依赖流程："><a href="#1、收集依赖流程：" class="headerlink" title="1、收集依赖流程："></a>1、收集依赖流程：</h4><pre><code>observe -&gt; walk -&gt; defineReactive -&gt; get -&gt; dep.depend() -&gt; watcher.addDep(new Dep()) -&gt; watcher.newDeps.push(dep) -&gt; dep.addSub(new Watcher()) -&gt; dep.subs.push(watcher)</code></pre><p>依赖收集会经过以上流程，最终watcher.newDeps数组中存放dep列表，dep.subs数组中存放watcher列表。</p><h6 id="为什么要进行依赖收集？"><a href="#为什么要进行依赖收集？" class="headerlink" title="为什么要进行依赖收集？"></a>为什么要进行依赖收集？</h6><pre><code>new Vue({    data(){        return {            name:&apos;zane&apos;,            sex:&apos;男&apos;        }    }})</code></pre><p>有上面这个data，实际上页面只使用到了name，并没有使用age，根据Object.defineProperty的转换，如果我们设置了this.sex=’女’，那么Vue也会去执行一遍虚拟DOM的比较，这样就无形的浪费了一些性能，因此才需要做依赖收集，界面用到了就收集，没有用到就不收集。</p><p>我们跟着流程走来理一遍源码：</p><p>直接进入Object.defineProperty的get方法：</p><p><img src="/images/blog/20190401/1.png" alt></p><p>考验你闭包能力的时候到了，这个dep对象就是一个闭包。记下来我们看看dep.depend()方法的实现。</p><p><img src="/images/blog/20190401/2.png" alt></p><p>先暂停一下，上面两处都用到了 Dep.target ，我也说了它就是一个Watcher实例化对象，你是不是很想搞懂它到底在哪里赋值的呢，不急请跟着我下面的代码看看。</p><p><img src="/images/blog/20190401/3.png" alt><br><img src="/images/blog/20190401/4.png" alt><br><img src="/images/blog/20190401/5.png" alt></p><p>搞懂了Dep.target等于一个Watche对象，现在继续回到之前的思路看watcher.addDep做了什么。</p><p><img src="/images/blog/20190401/6.png" alt><br><img src="/images/blog/20190401/7.png" alt></p><p>就这样依赖收集的流程就走完了，是否感觉很绕。</p><h6 id="总结：依赖收集最终在-watcher-newDeps-中push了闭包中传过来的dep对象，在dep-subs中push了初始化Vue是简历的Watcher对象，这个对象的，this-getter-expOrFn-传过来的expOrFn是后期数据更新页面渲染的核心步骤，需要沉下心来好好去理理。"><a href="#总结：依赖收集最终在-watcher-newDeps-中push了闭包中传过来的dep对象，在dep-subs中push了初始化Vue是简历的Watcher对象，这个对象的，this-getter-expOrFn-传过来的expOrFn是后期数据更新页面渲染的核心步骤，需要沉下心来好好去理理。" class="headerlink" title="总结：依赖收集最终在 watcher.newDeps 中push了闭包中传过来的dep对象，在dep.subs中push了初始化Vue是简历的Watcher对象，这个对象的，this.getter = expOrFn,传过来的expOrFn是后期数据更新页面渲染的核心步骤，需要沉下心来好好去理理。"></a>总结：依赖收集最终在 watcher.newDeps 中push了闭包中传过来的dep对象，在dep.subs中push了初始化Vue是简历的Watcher对象，这个对象的，this.getter = expOrFn,传过来的expOrFn是后期数据更新页面渲染的核心步骤，需要沉下心来好好去理理。</h6><h4 id="2、视图更新流程："><a href="#2、视图更新流程：" class="headerlink" title="2、视图更新流程："></a>2、视图更新流程：</h4><pre><code>set -&gt; dep.notify() -&gt; subs[i].update() -&gt; watcher.run() || queueWatcher(this) -&gt; watcher.get() || watcher.cb -&gt; watcher.getter() -&gt; vm._update() -&gt; vm.__patch__()</code></pre><p>视图更新会经过以上流程，最终调用Vue的虚拟Dom diff过程实时更新界面视图</p><p><img src="/images/blog/20190401/8.png" alt><br><img src="/images/blog/20190401/9.png" alt><br><img src="/images/blog/20190401/10.png" alt><br><img src="/images/blog/20190401/11.png" alt><br><img src="/images/blog/20190401/12.png" alt><br><img src="/images/blog/20190401/13.png" alt></p><p>走到此处后面我就不去跟踪了，后面会调用vm.<strong>patch</strong> 方法，进而执行虚拟DOM的diff过程实时的更新界面。</p><h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>要很好的理解vue的数据双向绑定就要比较耐心，沉下心来慢慢理解，同时也需要对vue的源码有个大致的理解，不然你只会看的越来越烦躁越来越没有信心。vue很好的利用了Object.defineProperty方法的 get和set方法，订阅者发布者的设计思路，巧妙的组织代码，值得我们很深入的去学习和理解，从而促使我们更好的去使用它。谢谢尤大的无私奉献，让我们提高了生产力，把更多的精力花到业务逻辑中去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue源码分析 - observer,dep,watch,实现数据双向绑定&lt;/p&gt;
    
    </summary>
    
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="日志" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>当勤精进</title>
    <link href="http://yoursite.com/post/2019-01-17-20190117/"/>
    <id>http://yoursite.com/post/2019-01-17-20190117/</id>
    <published>2019-01-17T09:25:23.000Z</published>
    <updated>2020-03-10T01:32:07.036Z</updated>
    
    <content type="html"><![CDATA[<p>当勤精进</p><a id="more"></a><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><p>尝试着指定日计划/周计划/月计划，有针对性的复习；<br>数学，专业课为主，英语居中，政治中后期主背诵，辅刷题；<br>算法还要持续学习；</p><h4 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h4><p>每天要坚持锻炼，健身卡要充分利用</p><h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p>小时候沉迷于网络小说，看了n多的网络小说，但影响最深的还是蓝大的&lt;高手寂寞&gt;，大概主角的三观和我这种内向的人比较相符的原因，实际上喜欢此书的读者少之又少．最近发现许多的名著读起来还是挺有感觉的，最近接触&lt;白夜行&gt; ，感觉打开了新世界的大门．遂有了下面这个书单：</p><p>&lt;恶意&gt;　东野圭吾<br>&lt;倾城之恋&gt;　张爱玲<br>&lt;百年孤独&gt; 加西亚·马尔克斯<br>&lt;挪威的森林&gt; 村上春树<br>&lt;自控力&gt; 凯利·麦格尼格尔<br>&lt;时间简史&gt; 霍金<br>&lt;阿Ｑ正传&gt; 鲁迅<br>&lt;乌合之众&gt; 勒庞<br>&lt;当我谈跑步时我谈些什么&gt;　村上春树<br>&lt;人间失格&gt; 太宰治<br>电影没什么想看的，也没什么闲着的时间了，唔，还要学着写写书评，嗯，算读后感？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当勤精进&lt;/p&gt;
    
    </summary>
    
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="日志" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>ES6 系列之 defineProperty 与 proxy</title>
    <link href="http://yoursite.com/post/2019-01-12-20190112/"/>
    <id>http://yoursite.com/post/2019-01-12-20190112/</id>
    <published>2019-01-12T02:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.253Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 系列之 defineProperty 与 proxy </p><a id="more"></a><h5 id="definePropety"><a href="#definePropety" class="headerlink" title="definePropety"></a>definePropety</h5><p>ES5 提供了 Object.defineProperty 方法，该方法可以在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。</p><p>语法<br>    Object.defineProperty(obj, prop, descriptor)</p><pre><code>obj: 要在其上定义属性的对象。prop:  要定义或修改的属性的名称。descriptor: 将被定义或修改的属性的描述符。</code></pre><p>举个例子：</p><pre><code>var obj = {};Object.defineProperty(obj, &quot;num&quot;, {    value : 1,    writable : true,    enumerable : true,    configurable : true});//  对象 obj 拥有属性 num，值为 1</code></pre><p>虽然我们可以直接添加属性和值，但是使用这种方式，我们能进行更多的配置。</p><p>函数的第三个参数 descriptor 所表示的属性描述符有两种形式：数据描述符和存取描述符。</p><h6 id="两者均具有以下两种键值："><a href="#两者均具有以下两种键值：" class="headerlink" title="两者均具有以下两种键值："></a>两者均具有以下两种键值：</h6><p>configurable</p><p>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，也能够被删除。默认为 false。<br>enumerable</p><p>当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。</p><h6 id="数据描述符同时具有以下可选键值："><a href="#数据描述符同时具有以下可选键值：" class="headerlink" title="数据描述符同时具有以下可选键值："></a>数据描述符同时具有以下可选键值：</h6><p>value</p><p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。<br>writable</p><p>当且仅当该属性的 writable 为 true 时，该属性才能被赋值运算符改变。默认为 false。</p><h6 id="存取描述符同时具有以下可选键值："><a href="#存取描述符同时具有以下可选键值：" class="headerlink" title="存取描述符同时具有以下可选键值："></a>存取描述符同时具有以下可选键值：</h6><p>get</p><p>一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。<br>set</p><p>一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。<br>值得注意的是：</p><p>属性描述符必须是数据描述符或者存取描述符两种形式之一，不能同时是两者 。这就意味着你可以：</p><pre><code>Object.defineProperty({}, &quot;num&quot;, {    value: 1,    writable: true,    enumerable: true,    configurable: true});</code></pre><p>也可以：</p><pre><code>var value = 1;Object.defineProperty({}, &quot;num&quot;, {    get : function(){      return value;    },    set : function(newValue){      value = newValue;    },    enumerable : true,    configurable : true});</code></pre><p>但是不可以：</p><pre><code>// 报错Object.defineProperty({}, &quot;num&quot;, {    value: 1,    get: function() {        return 1;    }});</code></pre><p>此外，所有的属性描述符都是非必须的，但是 descriptor 这个字段是必须的，如果不进行任何配置，你可以这样：</p><pre><code>var obj = Object.defineProperty({}, &quot;num&quot;, {});console.log(obj.num); // undefined</code></pre><h5 id="Setters-和-Getters"><a href="#Setters-和-Getters" class="headerlink" title="Setters 和 Getters"></a>Setters 和 Getters</h5><p>之所以讲到 defineProperty，是因为我们要使用存取描述符中的 get 和 set，这两个方法又被称为 getter 和 setter。由 getter 和 setter 定义的属性称做”存取器属性“。</p><p>当程序查询存取器属性的值时，JavaScript 调用 getter方法。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，JavaScript 调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责“设置”属性值。可以忽略 setter 方法的返回值。</p><p>举个例子：</p><pre><code>var obj = {}, value = null;Object.defineProperty(obj, &quot;num&quot;, {    get: function(){        console.log(&apos;执行了 get 操作&apos;)        return value;    },    set: function(newValue) {        console.log(&apos;执行了 set 操作&apos;)        value = newValue;    }})obj.num = 1 // 执行了 set 操作console.log(obj.num); // 执行了 get 操作 // 1</code></pre><p>这不就是我们要的监控数据改变的方法吗？我们再来封装一下：</p><pre><code>function Archiver() {    var value = null;    // archive n. 档案    var archive = [];    Object.defineProperty(this, &apos;num&apos;, {        get: function() {            console.log(&apos;执行了 get 操作&apos;)            return value;        },        set: function(value) {            console.log(&apos;执行了 set 操作&apos;)            value = value;            archive.push({ val: value });        }    });    this.getArchive = function() { return archive; };}var arc = new Archiver();arc.num; // 执行了 get 操作arc.num = 11; // 执行了 set 操作arc.num = 13; // 执行了 set 操作console.log(arc.getArchive()); // [{ val: 11 }, { val: 13 }]</code></pre><p>watch API</p><p>既然可以监控数据的改变，那我可以这样设想，即当数据改变的时候，自动进行渲染工作。举个例子：</p><p>HTML 中有个 span 标签和 button 标签</p><pre><code>&lt;span id=&quot;container&quot;&gt;1&lt;/span&gt;&lt;button id=&quot;button&quot;&gt;点击加 1&lt;/button&gt;</code></pre><p>当点击按钮的时候，span 标签里的值加 1。</p><p>传统的做法是：</p><pre><code>document.getElementById(&apos;button&apos;).addEventListener(&quot;click&quot;, function(){    var container = document.getElementById(&quot;container&quot;);    container.innerHTML = Number(container.innerHTML) + 1;});</code></pre><p>如果使用了 defineProperty：</p><pre><code>var obj = {    value: 1}// 储存 obj.value 的值var value = 1;Object.defineProperty(obj, &quot;value&quot;, {    get: function() {        return value;    },    set: function(newValue) {        value = newValue;        document.getElementById(&apos;container&apos;).innerHTML = newValue;    }});document.getElementById(&apos;button&apos;).addEventListener(&quot;click&quot;, function() {    obj.value += 1;});</code></pre><p>代码看似增多了，但是当我们需要改变 span 标签里的值的时候，直接修改 obj.value 的值就可以了。</p><p>然而，现在的写法，我们还需要单独声明一个变量存储 obj.value 的值，因为如果你在 set 中直接 obj.value = newValue 就会陷入无限的循环中。此外，我们可能需要监控很多属性值的改变，要是一个一个写，也很累呐，所以我们简单写个 watch 函数。使用效果如下：</p><pre><code>var obj = {    value: 1}watch(obj, &quot;value&quot;, function(newvalue){    document.getElementById(&apos;container&apos;).innerHTML = newvalue;})document.getElementById(&apos;button&apos;).addEventListener(&quot;click&quot;, function(){    obj.value += 1});</code></pre><p>我们来写下这个 watch 函数：</p><pre><code>(function(){    var root = this;    function watch(obj, name, func){        var value = obj[name];        Object.defineProperty(obj, name, {            get: function() {                return value;            },            set: function(newValue) {                value = newValue;                func(value)            }        });        if (value) obj[name] = value    }    this.watch = watch;})()</code></pre><p>现在我们已经可以监控对象属性值的改变，并且可以根据属性值的改变，添加回调函数，棒棒哒~</p><h5 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h5><p>使用 defineProperty 只能重定义属性的读取（get）和设置（set）行为，到了 ES6，提供了 Proxy，可以重定义更多的行为，比如 in、delete、函数调用等更多行为。</p><p>Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。我们来看看它的语法：</p><p>  var proxy = new Proxy(target, handler);</p><p>proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p><pre><code>var proxy = new Proxy({}, {    get: function(obj, prop) {        console.log(&apos;设置 get 操作&apos;)        return obj[prop];    },    set: function(obj, prop, value) {        console.log(&apos;设置 set 操作&apos;)        obj[prop] = value;    }});proxy.time = 35; // 设置 set 操作console.log(proxy.time); // 设置 get 操作 // 35</code></pre><p>除了 get 和 set 之外，proxy 可以拦截多达 13 种操作，比如 has(target, propKey)，可以拦截 propKey in proxy 的操作，返回一个布尔值。</p><pre><code>// 使用 has 方法隐藏某些属性，不被 in 运算符发现var handler = {  has (target, key) {    if (key[0] === &apos;_&apos;) {      return false;    }    return key in target;  }};var target = { _prop: &apos;foo&apos;, prop: &apos;foo&apos; };var proxy = new Proxy(target, handler);console.log(&apos;_prop&apos; in proxy); // false</code></pre><p>又比如说 apply 方法拦截函数的调用、call 和 apply 操作。</p><p>apply 方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组，不过这里我们简单演示一下：</p><pre><code>var target = function () { return &apos;I am the target&apos;; };var handler = {  apply: function () {    return &apos;I am the proxy&apos;;  }};var p = new Proxy(target, handler);p();// &quot;I am the proxy&quot;</code></pre><p>又比如说 ownKeys 方法可以拦截对象自身属性的读取操作。具体来说，拦截以下操作：</p><pre><code>Object.getOwnPropertyNames()Object.getOwnPropertySymbols()Object.keys()</code></pre><p>下面的例子是拦截第一个字符为下划线的属性名，不让它被 for of 遍历到。</p><pre><code>let target = {  _bar: &apos;foo&apos;,  _prop: &apos;bar&apos;,  prop: &apos;baz&apos;};let handler = {  ownKeys (target) {    return Reflect.ownKeys(target).filter(key =&gt; key[0] !== &apos;_&apos;);  }};let proxy = new Proxy(target, handler);for (let key of Object.keys(proxy)) {  console.log(target[key]);}// &quot;baz&quot;</code></pre><p>更多的拦截行为可以查看阮一峰老师的 《ECMAScript 6 入门》</p><p>值得注意的是，proxy 的最大问题在于浏览器支持度不够，而且很多效果无法使用 poilyfill 来弥补。</p><h5 id="watch-API-优化"><a href="#watch-API-优化" class="headerlink" title="watch API 优化"></a>watch API 优化</h5><p>我们使用 proxy 再来写一下 watch 函数。使用效果如下：</p><pre><code>(function() {    var root = this;    function watch(target, func) {        var proxy = new Proxy(target, {            get: function(target, prop) {                return target[prop];            },            set: function(target, prop, value) {                target[prop] = value;                func(prop, value);            }        });        return proxy;    }    this.watch = watch;})()var obj = {    value: 1}var newObj = watch(obj, function(key, newvalue) {    if (key == &apos;value&apos;) document.getElementById(&apos;container&apos;).innerHTML = newvalue;})document.getElementById(&apos;button&apos;).addEventListener(&quot;click&quot;, function() {    newObj.value += 1});</code></pre><p>我们也可以发现，使用 defineProperty 和 proxy 的区别，当使用 defineProperty，我们修改原来的 obj 对象就可以触发拦截，而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 系列之 defineProperty 与 proxy &lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>完全理解JS--arguments</title>
    <link href="http://yoursite.com/post/2019-01-02-20190106/"/>
    <id>http://yoursite.com/post/2019-01-02-20190106/</id>
    <published>2019-01-02T02:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.247Z</updated>
    
    <content type="html"><![CDATA[<p>什么是arguments?</p><a id="more"></a><h5 id="什么是arguments"><a href="#什么是arguments" class="headerlink" title="什么是arguments?"></a>什么是arguments?</h5><p>它是JS的一个内置对象，常被人们所忽略，但实际上确很重要，JS不像JAVA是显示传递参数，JS传的是形参，可以传也可以不传，若方法里没有写参数却传入了参数，该如何拿到参数呢，答案就是arguments了，在一些插件里通常这样使用。</p><p>每一个函数都有一个arguments对象，它包括了函数所要调的参数，通常我们把它当作数组使用，用它的length得到参数数量，但它却不是数组，使用instanceof查看下，若使用push添加数据将报错，代码如下：</p><p>  (function(){<br>      console.log([] instanceof Array)<br>      console.log(arguments instanceof Array)<br>      if(arguments.push) arguments.push(‘test’)<br>  })()</p><h5 id="创建一个灵活的格式化函数"><a href="#创建一个灵活的格式化函数" class="headerlink" title="创建一个灵活的格式化函数"></a>创建一个灵活的格式化函数</h5><p>上面说了arguments可以使用函数使用数量不定的参数，下面看看它的一个实际应用：</p><p>  function format(string) {<br>    var args = arguments;<br>    var pattern = new RegExp(“%([1-“ + arguments.length + “])”, “g”);<br>    return String(string).replace(pattern, function(match, index) {<br>      return args[index];<br>    });<br>  };<br>  format(“And the %1 want to know whose %2 you %3”, “papers”, “shirt”, “wear”);</p><p>这里我借用了别人的一个例子，一个模板字符串，可以使用%1到%9等9个占位符，然后提供9个参数给这些占位符，最后替换生成真正的字符串。<br>上面的代码返回：“And the papers want to know whose shirt you wear”</p><h5 id="把arguments转换成一个真正的数组"><a href="#把arguments转换成一个真正的数组" class="headerlink" title="把arguments转换成一个真正的数组"></a>把arguments转换成一个真正的数组</h5><p>有时我们希望将它转换成真正的数组使用，可以使用下面的代码：</p><p>  var args = Array.prototype.slice.call(arguments);</p><p>现在args就是一个标准的js数组了，可以使用数组的标准方法了。</p><p>  arguments允许我们去执行所有类型的js方法，下面通过一个makeFunc函数，展示了函数允许我们去提供一个函数引用和这个函数的所有参数，它将返回一个匿名函数去调用你规定的函数(就是闭包)，也提供了匿名函数调用时所附带的参数。</p><p>  function makeFunc() {<br>    var args = Array.prototype.slice.call(arguments);<br>    var func = args.shift();<br>    return function() {<br>      return func.apply(null, args.concat(Array.prototype.slice.call(arguments)));<br>    };<br>  }</p><p>第一个arguments给makeFunc提供了你调用的函数的引用，它将第一个参数从arguments数组里移除，然后makeFunc返回了一个匿名函数去运行规定的方法。<br>apply的第一个参数是函数调用的范围，主要是函数内部关联部分所指向的，这里设为null，它的arguments是一个数组，即匿名函数调用时传入的参数，匿名函数将传入的参数串联到原参数对象args里组成完整的匿名函数所需要参数。</p><p>你需要输出一个模板，总是相同位置的字符发生改变，这样就可以使用makeFunc去生成一个模板函数，传入不同的参数多次调用生成不同的内容了</p><p>  “I like js not java.”<br>  “I like java not python.”</p><p>  这样封装format是不是很酷，不过arguments还有更多惊喜。</p><h5 id="创建引用自身的函数"><a href="#创建引用自身的函数" class="headerlink" title="创建引用自身的函数"></a>创建引用自身的函数</h5><p>  arguments.callee包括了一个函数的引用去创建一个arguments对象，它能让一个匿名函数很方便的指向本身。<br>下面的Repeat是一个承载了一个函数引用和两个数字的函数，第一个数字是调用次数，第二个是间隔时间，单位毫秒。</p><p>  function repeat(fn, times, delay) {<br>    return function() {<br>      if(times– &gt; 0) {<br>        fn.apply(null, arguments);<br>        var args = Array.prototype.slice.call(arguments);<br>        var self = arguments.callee;<br>        setTimeout(function(){self.apply(null,args)}, delay);<br>      }<br>    };<br>  }</p><p>Repeat函数使用了arguments.callee方法从变量self获取一个引用，指向运行原始指令的函数。这样，匿名函数就可以再次调用自身，看看下面的调用：</p><p>  var somethingWrong = repeat(function(s){console.log(s)}, 3, 2000);<br>  somethingWrong(“Can you hear me, major tom?”);</p><p>  可以看到somethingWrong函数的结果被打印了3次，每隔2秒。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是arguments?&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS异步解决方案的发展历程以及优缺点</title>
    <link href="http://yoursite.com/post/2019-01-02-20190102/"/>
    <id>http://yoursite.com/post/2019-01-02-20190102/</id>
    <published>2019-01-02T02:23:18.000Z</published>
    <updated>2020-03-09T01:44:46.505Z</updated>
    
    <content type="html"><![CDATA[<p>js 异步已经告一段落了，这里来一波小总结</p><a id="more"></a><h5 id="1-回调函数（callback）"><a href="#1-回调函数（callback）" class="headerlink" title="1. 回调函数（callback）"></a>1. 回调函数（callback）</h5><p>  setTimeout(() =&gt; {<br>      // callback 函数体<br>  }, 1000)</p><h6 id="缺点：回调地狱，不能用-try-catch-捕获错误，不能-return"><a href="#缺点：回调地狱，不能用-try-catch-捕获错误，不能-return" class="headerlink" title="缺点：回调地狱，不能用 try catch 捕获错误，不能 return"></a>缺点：回调地狱，不能用 try catch 捕获错误，不能 return</h6><p>回调地狱的根本问题在于：</p><p>缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符<br>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转）<br>嵌套函数过多的多话，很难处理错误</p><p>  ajax(‘XXX1’, () =&gt; {<br>      // callback 函数体<br>      ajax(‘XXX2’, () =&gt; {<br>          // callback 函数体<br>          ajax(‘XXX3’, () =&gt; {<br>              // callback 函数体<br>          })<br>      })<br>  })</p><h6 id="优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）"><a href="#优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）" class="headerlink" title="优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）"></a>优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）</h6><h5 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2.Promise"></a>2.Promise</h5><p>Promise就是为了解决callback的问题而产生的。</p><p>Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装</p><h6 id="优点：解决了回调地狱的问题"><a href="#优点：解决了回调地狱的问题" class="headerlink" title="优点：解决了回调地狱的问题"></a>优点：解决了回调地狱的问题</h6><p>  ajax(‘XXX1’)<br>    .then(res =&gt; {<br>        // 操作逻辑<br>        return ajax(‘XXX2’)<br>    }).then(res =&gt; {<br>        // 操作逻辑<br>        return ajax(‘XXX3’)<br>    }).then(res =&gt; {<br>        // 操作逻辑<br>    })</p><h6 id="缺点：无法取消-Promise-，错误需要通过回调函数来捕获"><a href="#缺点：无法取消-Promise-，错误需要通过回调函数来捕获" class="headerlink" title="缺点：无法取消 Promise ，错误需要通过回调函数来捕获"></a>缺点：无法取消 Promise ，错误需要通过回调函数来捕获</h6><h5 id="3-Generator"><a href="#3-Generator" class="headerlink" title="3. Generator"></a>3. Generator</h5><h6 id="特点：可以控制函数的执行，可以配合-co-函数库使用"><a href="#特点：可以控制函数的执行，可以配合-co-函数库使用" class="headerlink" title="特点：可以控制函数的执行，可以配合 co 函数库使用"></a>特点：可以控制函数的执行，可以配合 co 函数库使用</h6><p>  function *fetch() {<br>      yield ajax(‘XXX1’, () =&gt; {})<br>      yield ajax(‘XXX2’, () =&gt; {})<br>      yield ajax(‘XXX3’, () =&gt; {})<br>  }<br>  let it = fetch()<br>  let result1 = it.next()<br>  let result2 = it.next()<br>  let result3 = it.next()</p><h5 id="4-Async-await"><a href="#4-Async-await" class="headerlink" title="4. Async/await"></a>4. Async/await</h5><p>  async、await 是异步的终极解决方案  </p><h5 id="优点是：代码清晰，不用像-Promise-写一大堆-then-链，处理了回调地狱的问题"><a href="#优点是：代码清晰，不用像-Promise-写一大堆-then-链，处理了回调地狱的问题" class="headerlink" title="优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题"></a>优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题</h5><h5 id="缺点：await-将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用-await-会导致性能上的降低。"><a href="#缺点：await-将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用-await-会导致性能上的降低。" class="headerlink" title="缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。"></a>缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。</h5><p>  async function test() {<br>    // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式<br>    // 如果有依赖性的话，其实就是解决回调地狱的例子了<br>    await fetch(‘XXX1’)<br>    await fetch(‘XXX2’)<br>    await fetch(‘XXX3’)<br>  }</p><p>下面来看一个使用 await 的例子：</p><p>  let a = 0<br>  let b = async () =&gt; {<br>    a = a + await 10<br>    console.log(‘2’, a) // -&gt; ‘2’ 10<br>  }<br>  b()<br>  a++<br>  console.log(‘1’, a) // -&gt; ‘1’ 1</p><p>对于以上代码你可能会有疑惑，让我来解释下原因</p><p>首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来<br>因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码<br>同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10</p><p>上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js 异步已经告一段落了，这里来一波小总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ES6 使用手册</title>
    <link href="http://yoursite.com/post/2018-11-12-20181212/"/>
    <id>http://yoursite.com/post/2018-11-12-20181212/</id>
    <published>2018-11-12T00:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.240Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 使用手册</p><a id="more"></a><h5 id="1-let-和-const"><a href="#1-let-和-const" class="headerlink" title="1. let 和 const"></a>1. let 和 const</h5><p>  在我们开发的时候，可能认为应该默认使用 let 而不是 var，这种情况下，对于需要写保护的变量要使用 const。</p><p>  然而另一种做法日益普及：默认使用 const，只有当确实需要改变变量的值的时候才使用 let。这是因为大部分的变量的值在初始化后不应再改变，而预料之外的变量的修改是很多 bug 的源头。</p><pre><code>// 例子 1-1// badvar foo = &apos;bar&apos;;// goodlet foo = &apos;bar&apos;;// betterconst foo = &apos;bar&apos;;</code></pre><h5 id="2-模板字符串"><a href="#2-模板字符串" class="headerlink" title="2. 模板字符串"></a>2. 模板字符串</h5><h6 id="需要拼接字符串的时候尽量改成使用模板字符串"><a href="#需要拼接字符串的时候尽量改成使用模板字符串" class="headerlink" title="需要拼接字符串的时候尽量改成使用模板字符串:"></a>需要拼接字符串的时候尽量改成使用模板字符串:</h6><pre><code>// 例子 2-1// badconst foo = &apos;this is a&apos; + example;// goodconst foo = `this is a ${example}`;</code></pre><h6 id="2-标签模板"><a href="#2-标签模板" class="headerlink" title="2. 标签模板"></a>2. 标签模板</h6><p>  可以借助标签模板优化书写方式:</p><pre><code>let url = oneLine `    www.taobao.com/example/index.html    ?foo=${foo}    &amp;bar=${bar}`;console.log(url); // www.taobao.com/example/index.html?foo=foo&amp;bar=bar</code></pre><p>  oneLine 的源码可以参考 《ES6 系列之模板字符串》</p><h5 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3. 箭头函数"></a>3. 箭头函数</h5><p>  优先使用箭头函数，不过以下几种情况避免使用：</p><h6 id="1-使用箭头函数定义对象的方法"><a href="#1-使用箭头函数定义对象的方法" class="headerlink" title="1. 使用箭头函数定义对象的方法"></a>1. 使用箭头函数定义对象的方法</h6><pre><code>// 例子 3-1// badlet foo = {  value: 1,  getValue: () =&gt; console.log(this.value)}foo.getValue();  // undefined</code></pre><h6 id="2-定义原型方法"><a href="#2-定义原型方法" class="headerlink" title="2. 定义原型方法"></a>2. 定义原型方法</h6><pre><code>// 例子 3-2// badfunction Foo() {  this.value = 1}Foo.prototype.getValue = () =&gt; console.log(this.value)let foo = new Foo()foo.getValue();  // undefined</code></pre><h6 id="3-作为事件的回调函数"><a href="#3-作为事件的回调函数" class="headerlink" title="3. 作为事件的回调函数"></a>3. 作为事件的回调函数</h6><pre><code>// 例子 3-3// badconst button = document.getElementById(&apos;myButton&apos;);button.addEventListener(&apos;click&apos;, () =&gt; {    console.log(this === window); // =&gt; true    this.innerHTML = &apos;Clicked button&apos;;});</code></pre><h5 id="4-Symbol"><a href="#4-Symbol" class="headerlink" title="4. Symbol"></a>4. Symbol</h5><h6 id="1-唯一值"><a href="#1-唯一值" class="headerlink" title="1. 唯一值"></a>1. 唯一值</h6><pre><code>// 例子 4-1// bad// 1. 创建的属性会被 for-in 或 Object.keys() 枚举出来// 2. 一些库可能在将来会使用同样的方式，这会与你的代码发生冲突if (element.isMoving) {  smoothAnimations(element);}element.isMoving = true;// goodif (element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__) {  smoothAnimations(element);}element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = true;// bettervar isMoving = Symbol(&quot;isMoving&quot;);...if (element[isMoving]) {  smoothAnimations(element);}element[isMoving] = true;</code></pre><h6 id="2-魔术字符串"><a href="#2-魔术字符串" class="headerlink" title="2. 魔术字符串"></a>2. 魔术字符串</h6><p>  魔术字符串指的是在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。</p><p>  魔术字符串不利于修改和维护，风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p><pre><code>// 例子 4-1// badconst TYPE_AUDIO = &apos;AUDIO&apos;const TYPE_VIDEO = &apos;VIDEO&apos;const TYPE_IMAGE = &apos;IMAGE&apos;// goodconst TYPE_AUDIO = Symbol()const TYPE_VIDEO = Symbol()const TYPE_IMAGE = Symbol()function handleFileResource(resource) {  switch(resource.type) {    case TYPE_AUDIO:      playAudio(resource)      break    case TYPE_VIDEO:      playVideo(resource)      break    case TYPE_IMAGE:      previewImage(resource)      break    default:      throw new Error(&apos;Unknown type of resource&apos;)  }}</code></pre><h6 id="3-私有变量"><a href="#3-私有变量" class="headerlink" title="3. 私有变量"></a>3. 私有变量</h6><p>  Symbol 也可以用于私有变量的实现。<br>    // 例子 4-3</p><pre><code>const Example = (function() {    var _private = Symbol(&apos;private&apos;);    class Example {        constructor() {          this[_private] = &apos;private&apos;;        }        getName() {          return this[_private];        }    }    return Example;})();var ex = new Example();console.log(ex.getName()); // privateconsole.log(ex.name); // undefined</code></pre><h5 id="5-Set-和-Map"><a href="#5-Set-和-Map" class="headerlink" title="5. Set 和 Map"></a>5. Set 和 Map</h5><h6 id="1-数组去重"><a href="#1-数组去重" class="headerlink" title="1. 数组去重"></a>1. 数组去重</h6><pre><code>/ 例子 5-1[...new Set(array)]</code></pre><h6 id="2-条件语句的优化"><a href="#2-条件语句的优化" class="headerlink" title="2. 条件语句的优化"></a>2. 条件语句的优化</h6><pre><code>// 例子 5-2// 根据颜色找出对应的水果// badfunction test(color) {  switch (color) {    case &apos;red&apos;:      return [&apos;apple&apos;, &apos;strawberry&apos;];    case &apos;yellow&apos;:      return [&apos;banana&apos;, &apos;pineapple&apos;];    case &apos;purple&apos;:      return [&apos;grape&apos;, &apos;plum&apos;];    default:      return [];  }}test(&apos;yellow&apos;); // [&apos;banana&apos;, &apos;pineapple&apos;]// goodconst fruitColor = {  red: [&apos;apple&apos;, &apos;strawberry&apos;],  yellow: [&apos;banana&apos;, &apos;pineapple&apos;],  purple: [&apos;grape&apos;, &apos;plum&apos;]};function test(color) {  return fruitColor[color] || [];}// betterconst fruitColor = new Map()  .set(&apos;red&apos;, [&apos;apple&apos;, &apos;strawberry&apos;])  .set(&apos;yellow&apos;, [&apos;banana&apos;, &apos;pineapple&apos;])  .set(&apos;purple&apos;, [&apos;grape&apos;, &apos;plum&apos;]);function test(color) {  return fruitColor.get(color) || [];}</code></pre><h5 id="6-for-of"><a href="#6-for-of" class="headerlink" title="6. for of"></a>6. for of</h5><h6 id="1-遍历范围"><a href="#1-遍历范围" class="headerlink" title="1. 遍历范围"></a>1. 遍历范围</h6><p>  for…of 循环可以使用的范围包括：</p><pre><code>数组SetMap类数组对象，如 arguments 对象、DOM NodeList 对象Generator 对象字符串</code></pre><h6 id="2-优势"><a href="#2-优势" class="headerlink" title="2. 优势"></a>2. 优势</h6><p>  ES2015 引入了 for..of 循环，它结合了 forEach 的简洁性和中断循环的能力：</p><pre><code>// 例子 6-1for (const v of [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]) {  console.log(v);}// a b cfor (const [i, v] of [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].entries()) {  console.log(i, v);}// 0 &quot;a&quot;// 1 &quot;b&quot;// 2 &quot;c&quot;</code></pre><h6 id="3-遍历-Map"><a href="#3-遍历-Map" class="headerlink" title="3. 遍历 Map"></a>3. 遍历 Map</h6><pre><code>// 例子 6-2let map = new Map(arr);// 遍历 key 值for (let key of map.keys()) {  console.log(key);}// 遍历 value 值for (let value of map.values()) {  console.log(value);}// 遍历 key 和 value 值(一)for (let item of map.entries()) {  console.log(item[0], item[1]);}// 遍历 key 和 value 值(二)for (let [key, value] of data) {  console.log(key)}</code></pre><h5 id="7-Promise"><a href="#7-Promise" class="headerlink" title="7. Promise"></a>7. Promise</h5><h6 id="1-基本示例"><a href="#1-基本示例" class="headerlink" title="1. 基本示例"></a>1. 基本示例</h6><pre><code>// 例子 7-1// badrequest(url, function(err, res, body) {    if (err) handleError(err);    fs.writeFile(&apos;1.txt&apos;, body, function(err) {        request(url2, function(err, res, body) {            if (err) handleError(err)        })    })});// goodrequest(url).then(function(result) {    return writeFileAsynv(&apos;1.txt&apos;, result)}).then(function(result) {    return request(url2)}).catch(function(e){    handleError(e)});</code></pre><h6 id="2-finally"><a href="#2-finally" class="headerlink" title="2. finally"></a>2. finally</h6><pre><code>// 例子 7-2fetch(&apos;file.json&apos;).then(data =&gt; data.json()).catch(error =&gt; console.error(error)).finally(() =&gt; console.log(&apos;finished&apos;));</code></pre><h5 id="8-Async"><a href="#8-Async" class="headerlink" title="8. Async"></a>8. Async</h5><h6 id="1-代码更加简洁"><a href="#1-代码更加简洁" class="headerlink" title="1. 代码更加简洁"></a>1. 代码更加简洁</h6><pre><code>// 例子 8-1// goodfunction fetch() {  return (    fetchData()    .then(() =&gt; {      return &quot;done&quot;    });  )}// betterasync function fetch() {  await fetchData()  return &quot;done&quot;};// 例子 8-2// goodfunction fetch() {  return fetchData()  .then(data =&gt; {    if (data.moreData) {        return fetchAnotherData(data)        .then(moreData =&gt; {          return moreData        })    } else {      return data    }  });}// betterasync function fetch() {  const data = await fetchData()  if (data.moreData) {    const moreData = await fetchAnotherData(data);    return moreData  } else {    return data  }};// 例子 8-3// goodfunction fetch() {  return (    fetchData()    .then(value1 =&gt; {      return fetchMoreData(value1)    })    .then(value2 =&gt; {      return fetchMoreData2(value2)    })  )}// betterasync function fetch() {  const value1 = await fetchData()  const value2 = await fetchMoreData(value1)  return fetchMoreData2(value2)};</code></pre><h6 id="2-错误处理"><a href="#2-错误处理" class="headerlink" title="2. 错误处理"></a>2. 错误处理</h6><pre><code>// 例子 8-4// goodfunction fetch() {  try {    fetchData()      .then(result =&gt; {        const data = JSON.parse(result)      })      .catch((err) =&gt; {        console.log(err)      })  } catch (err) {    console.log(err)  }}// betterasync function fetch() {  try {    const data = JSON.parse(await fetchData())  } catch (err) {    console.log(err)  }};</code></pre><h6 id="3-“async-地狱”"><a href="#3-“async-地狱”" class="headerlink" title="3. “async 地狱”"></a>3. “async 地狱”</h6><pre><code>// 例子 8-5// bad(async () =&gt; {  const getList = await getList();  const getAnotherList = await getAnotherList();})();// good(async () =&gt; {  const listPromise = getList();  const anotherListPromise = getAnotherList();  await listPromise;  await anotherListPromise;})();// good(async () =&gt; {  Promise.all([getList(), getAnotherList()]).then(...);})();</code></pre><h5 id="9-Class"><a href="#9-Class" class="headerlink" title="9. Class"></a>9. Class</h5><h6 id="构造函数尽可能使用-Class-的形式"><a href="#构造函数尽可能使用-Class-的形式" class="headerlink" title="构造函数尽可能使用 Class 的形式"></a>构造函数尽可能使用 Class 的形式</h6><pre><code>// 例子 9-1class Foo {  static bar () {    this.baz();  }  static baz () {    console.log(&apos;hello&apos;);  }  baz () {    console.log(&apos;world&apos;);  }}Foo.bar(); // hello</code></pre><p>  // 例子 9-2<br>    class Shape {<br>      constructor(width, height) {<br>        this._width = width;<br>        this._height = height;<br>      }<br>      get area() {<br>        return this._width * this._height;<br>      }<br>    }<br>    const square = new Shape(10, 10);<br>    console.log(square.area);    // 100<br>    console.log(square._width);  // 10</p><h5 id="10-Decorator"><a href="#10-Decorator" class="headerlink" title="10.Decorator"></a>10.Decorator</h5><h6 id="1-log"><a href="#1-log" class="headerlink" title="1. log"></a>1. log</h6><pre><code>// 例子 10-1class Math {  @log  add(a, b) {    return a + b;  }}log 的实现可以参考 《ES6 系列之我们来聊聊装饰器》</code></pre><h6 id="2-autobind"><a href="#2-autobind" class="headerlink" title="2. autobind"></a>2. autobind</h6><p>  // 例子 10-2</p><pre><code>class Toggle extends React.Component {  @autobind  handleClick() {    console.log(this)  }  render() {    return (      &lt;button onClick={this.handleClick}&gt;        button      &lt;/button&gt;    );  }}autobind 的实现可以参考 《ES6 系列之我们来聊聊装饰器》###### 3. debounce// 例子 10-3class Toggle extends React.Component {  @debounce(500, true)  handleClick() {    console.log(&apos;toggle&apos;)  }  render() {    return (      &lt;button onClick={this.handleClick}&gt;        button      &lt;/button&gt;    );  }}debounce 的实现可以参考 《ES6 系列之我们来聊聊装饰器》</code></pre><h6 id="4-React-与-Redux"><a href="#4-React-与-Redux" class="headerlink" title="4. React 与 Redux"></a>4. React 与 Redux</h6><pre><code>// 例子 10-4// goodclass MyReactComponent extends React.Component {}export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);// better@connect(mapStateToProps, mapDispatchToProps)export default class MyReactComponent extends React.Component {};##### 11. 函数###### 1. 默认值// 例子 11-1// badfunction test(quantity) {  const q = quantity || 1;}// goodfunction test(quantity = 1) {  ...}// 例子 11-2doSomething({ foo: &apos;Hello&apos;, bar: &apos;Hey!&apos;, baz: 42 });// badfunction doSomething(config) {  const foo = config.foo !== undefined ? config.foo : &apos;Hi&apos;;  const bar = config.bar !== undefined ? config.bar : &apos;Yo!&apos;;  const baz = config.baz !== undefined ? config.baz : 13;}// goodfunction doSomething({ foo = &apos;Hi&apos;, bar = &apos;Yo!&apos;, baz = 13 }) {  ...}// betterfunction doSomething({ foo = &apos;Hi&apos;, bar = &apos;Yo!&apos;, baz = 13 } = {}) {  ...}// 例子 11-3// badconst Button = ({className}) =&gt; {  const classname = className || &apos;default-size&apos;;  return &lt;span className={classname}&gt;&lt;/span&gt;};// goodconst Button = ({className = &apos;default-size&apos;}) =&gt; (  &lt;span className={classname}&gt;&lt;/span&gt;);// betterconst Button = ({className}) =&gt;  &lt;span className={className}&gt;&lt;/span&gt;}Button.defaultProps = {  className: &apos;default-size&apos;}// 例子 11-4const required = () =&gt; {throw new Error(&apos;Missing parameter&apos;)};const add = (a = required(), b = required()) =&gt; a + b;add(1, 2) // 3add(1); // Error: Missing parameter.##### 12. 拓展运算符###### 1. arguments 转数组// 例子 12-1// badfunction sortNumbers() {  return Array.prototype.slice.call(arguments).sort();}// goodconst sortNumbers = (...numbers) =&gt; numbers.sort();###### 2. 调用参数// 例子 12-2// badMath.max.apply(null, [14, 3, 77])// goodMath.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77);##### 3. 构建对象剔除部分属性，将剩下的属性构建一个新的对象// 例子 12-3let [a, b, ...arr] = [1, 2, 3, 4, 5];const { a, b, ...others } = { a: 1, b: 2, c: 3, d: 4, e: 5 };</code></pre><p>  有条件的构建对象</p><pre><code>// 例子 12-4// badfunction pick(data) {  const { id, name, age} = data  const res = { guid: id }  if (name) {    res.name = name  }  else if (age) {    res.age = age  }  return res}// goodfunction pick({id, name, age}) {  return {    guid: id,    ...(name &amp;&amp; {name}),    ...(age &amp;&amp; {age})  }}</code></pre><p>  合并对象</p><pre><code>// 例子 12-5let obj1 = { a: 1, b: 2,c: 3 }let obj2 = { b: 4, c: 5, d: 6}let merged = {...obj1, ...obj2};###### 4. React</code></pre><p>  将对象全部传入组件</p><pre><code>// 例子 12-6const parmas =  {value1: 1, value2: 2, value3: 3}&lt;Test {...parmas} /&gt;##### 13. 双冒号运算符// 例子 13-1foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);</code></pre><p>  如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p><pre><code>// 例子 13-2var method = obj::obj.foo;// 等同于var method = ::obj.foo;let log = ::console.log;// 等同于var log = console.log.bind(console);</code></pre><h5 id="14-解构赋值"><a href="#14-解构赋值" class="headerlink" title="14. 解构赋值"></a>14. 解构赋值</h5><h6 id="1-对象的基本解构"><a href="#1-对象的基本解构" class="headerlink" title="1. 对象的基本解构"></a>1. 对象的基本解构</h6><pre><code>// 例子 14-1componentWillReceiveProps(newProps) {  this.setState({    active: newProps.active  })}componentWillReceiveProps({active}) {  this.setState({active})}// 例子 14-2// badhandleEvent = () =&gt; {  this.setState({    data: this.state.data.set(&quot;key&quot;, &quot;value&quot;)  })};// goodhandleEvent = () =&gt; {  this.setState(({data}) =&gt; ({    data: data.set(&quot;key&quot;, &quot;value&quot;)  }))};// 例子 14-3Promise.all([Promise.resolve(1), Promise.resolve(2)]).then(([x, y]) =&gt; {    console.log(x, y);});</code></pre><h5 id="2-对象深度解构"><a href="#2-对象深度解构" class="headerlink" title="2. 对象深度解构"></a>2. 对象深度解构</h5><pre><code>// 例子 14-4// badfunction test(fruit) {  if (fruit &amp;&amp; fruit.name)  {    console.log (fruit.name);  } else {    console.log(&apos;unknown&apos;);  }}// goodfunction test({name} = {}) {  console.log (name || &apos;unknown&apos;);}// 例子 14-5let obj = {    a: {      b: {        c: 1      }    }};const {a: {b: {c = &apos;&apos;} = &apos;&apos;} = &apos;&apos;} = obj;</code></pre><h5 id="3-数组解构"><a href="#3-数组解构" class="headerlink" title="3. 数组解构"></a>3. 数组解构</h5><pre><code>// 例子 14-6// badconst splitLocale = locale.split(&quot;-&quot;);const language = splitLocale[0];const country = splitLocale[1];// goodconst [language, country] = locale.split(&apos;-&apos;);</code></pre><h5 id="4-变量重命名"><a href="#4-变量重命名" class="headerlink" title="4. 变量重命名"></a>4. 变量重命名</h5><pre><code>// 例子 14-8let { foo: baz } = { foo: &apos;aaa&apos;, bar: &apos;bbb&apos; };console.log(baz); // &quot;aaa&quot;</code></pre><h5 id="5-仅获取部分属性"><a href="#5-仅获取部分属性" class="headerlink" title="5. 仅获取部分属性"></a>5. 仅获取部分属性</h5><pre><code>// 例子 14-9function test(input) {  return [left, right, top, bottom];}const [left, __, top] = test(input);function test(input) {  return { left, right, top, bottom };}const { left, right } = test(input);</code></pre><h4 id="15-增强的对象字面量"><a href="#15-增强的对象字面量" class="headerlink" title="15. 增强的对象字面量"></a>15. 增强的对象字面量</h4><pre><code>// 例子 15-1// badconst something = &apos;y&apos;const x = {  something: something}// goodconst something = &apos;y&apos;const x = {  something};</code></pre><p>  动态属性</p><p>  // 例子 15-2<br>  const x = {<br>    [‘a’ + ‘_’ + ‘b’]: ‘z’<br>  }<br>  console.log(x.a_b); // z</p><h5 id="16-数组的拓展方法"><a href="#16-数组的拓展方法" class="headerlink" title="16. 数组的拓展方法"></a>16. 数组的拓展方法</h5><h6 id="1-keys"><a href="#1-keys" class="headerlink" title="1. keys"></a>1. keys</h6><p>  // 例子 16-1</p><p>  var arr = [“a”, , “c”];</p><p>  var sparseKeys = Object.keys(arr);<br>  console.log(sparseKeys); // [‘0’, ‘2’]</p><p>  var denseKeys = […arr.keys()];<br>  console.log(denseKeys);  // [0, 1, 2]</p><h6 id="2-entries"><a href="#2-entries" class="headerlink" title="2. entries"></a>2. entries</h6><p>  // 例子 16-2</p><p>  var arr = [“a”, “b”, “c”];<br>  var iterator = arr.entries();</p><p>  for (let e of iterator) {<br>      console.log(e);<br>  }</p><h6 id="3-values"><a href="#3-values" class="headerlink" title="3. values"></a>3. values</h6><p>  // 例子 16-3</p><p>  let arr = [‘w’, ‘y’, ‘k’, ‘o’, ‘p’];<br>  let eArr = arr.values();</p><p>  for (let letter of eArr) {<br>    console.log(letter);<br>  }</p><h6 id="4-includes"><a href="#4-includes" class="headerlink" title="4. includes"></a>4. includes</h6><pre><code>// 例子 16-4// badfunction test(fruit) {  if (fruit == &apos;apple&apos; || fruit == &apos;strawberry&apos;) {    console.log(&apos;red&apos;);  }}// goodfunction test(fruit) {  const redFruits = [&apos;apple&apos;, &apos;strawberry&apos;, &apos;cherry&apos;, &apos;cranberries&apos;];  if (redFruits.includes(fruit)) {    console.log(&apos;red&apos;);  }}</code></pre><h6 id="5-find"><a href="#5-find" class="headerlink" title="5. find"></a>5. find</h6><pre><code>// 例子 16-5var inventory = [    {name: &apos;apples&apos;, quantity: 2},    {name: &apos;bananas&apos;, quantity: 0},    {name: &apos;cherries&apos;, quantity: 5}];function findCherries(fruit) {    return fruit.name === &apos;cherries&apos;;}console.log(inventory.find(findCherries)); // { name: &apos;cherries&apos;, quantity: 5 }</code></pre><h6 id="6-findIndex"><a href="#6-findIndex" class="headerlink" title="6. findIndex"></a>6. findIndex</h6><pre><code>// 例子 16-6function isPrime(element, index, array) {  var start = 2;  while (start &lt;= Math.sqrt(element)) {    if (element % start++ &lt; 1) {      return false;    }  }  return element &gt; 1;}console.log([4, 6, 8, 12].findIndex(isPrime)); // -1, not foundconsole.log([4, 6, 7, 12].findIndex(isPrime)); // 2</code></pre><p>  更多的就不列举了。</p><h5 id="17-optional-chaining"><a href="#17-optional-chaining" class="headerlink" title="17. optional-chaining"></a>17. optional-chaining</h5><p>  举个例子：</p><p>  // 例子 17-1</p><p>  const obj = {<br>    foo: {<br>      bar: {<br>        baz: 42,<br>      },<br>    },<br>  };</p><p>  const baz = obj?.foo?.bar?.baz; // 42</p><p>  同样支持函数：</p><pre><code>// 例子 17-2function test() {  return 42;}test?.(); // 42exists?.(); // undefined</code></pre><p>  需要添加 @babel/plugin-proposal-optional-chaining 插件支持</p><h5 id="18-logical-assignment-operators"><a href="#18-logical-assignment-operators" class="headerlink" title="18. logical-assignment-operators"></a>18. logical-assignment-operators</h5><pre><code>// 例子 18-1a ||= b;obj.a.b ||= c;a &amp;&amp;= b;obj.a.b &amp;&amp;= c;</code></pre><p>  Babel 编译为：</p><pre><code>var _obj$a, _obj$a2;a || (a = b);(_obj$a = obj.a).b || (_obj$a.b = c);a &amp;&amp; (a = b);(_obj$a2 = obj.a).b &amp;&amp; (_obj$a2.b = c);</code></pre><p>  出现的原因：</p><pre><code>// 例子 18-2function example(a = b) {  // a 必须是 undefined  if (!a) {    a = b;  }}function numeric(a = b) {  // a 必须是 null 或者 undefined  if (a == null) {    a = b;  }}// a 可以是任何 falsy 的值function example(a = b) {  // 可以，但是一定会触发 setter  a = a || b;  // 不会触发 setter，但可能会导致 lint error  a || (a = b);  // 就有人提出了这种写法：  a ||= b;}</code></pre><p>  需要 @babel/plugin-proposal-logical-assignment-operators 插件支持</p><h5 id="19-nullish-coalescing-operator"><a href="#19-nullish-coalescing-operator" class="headerlink" title="19. nullish-coalescing-operator"></a>19. nullish-coalescing-operator</h5><pre><code>a ?? b// 相当于(a !== null &amp;&amp; a !== void 0) ? a : b举个例子：var foo = object.foo ?? &quot;default&quot;;// 相当于var foo = (object.foo != null) ? object.foo : &quot;default&quot;;</code></pre><p>  需要 @babel/plugin-proposal-nullish-coalescing-operator 插件支持</p><h5 id="20-pipeline-operator"><a href="#20-pipeline-operator" class="headerlink" title="20. pipeline-operator"></a>20. pipeline-operator</h5><pre><code>const double = (n) =&gt; n * 2;const increment = (n) =&gt; n + 1;// 没有用管道操作符double(increment(double(5))); // 22// 用上管道操作符之后5 |&gt; double |&gt; increment |&gt; double; // 22</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 使用手册&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ES6 系列之迭代器与 for of</title>
    <link href="http://yoursite.com/post/2018-11-11-20181111/"/>
    <id>http://yoursite.com/post/2018-11-11-20181111/</id>
    <published>2018-11-11T00:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.234Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 系列之迭代器与 for of</p><a id="more"></a><p>起源<br>一段标准的 for 循环代码：</p><p>  var colors = [“red”, “green”, “blue”];</p><p>  for (var i = 0, len = colors.length; i &lt; len; i++) {<br>      console.log(colors[i]);<br>  }</p><p>看着很简单，但是再回顾这段代码，实际上我们仅仅是需要数组中元素的值，但是却需要提前获取数组长度，声明索引变量等，尤其当多个循环嵌套的时候，更需要使用多个索引变量，代码的复杂度就会大大增加，比如我们使用双重循环进行去重：</p><p>  function unique(array) {<br>      var res = [];<br>      for (var i = 0, arrayLen = array.length; i &lt; arrayLen; i++) {<br>          for (var j = 0, resLen = res.length; j &lt; resLen; j++) {<br>              if (array[i] === res[j]) {<br>                  break;<br>              }<br>          }<br>          if (j === resLen) {<br>              res.push(array[i]);<br>          }<br>      }<br>      return res;<br>  }</p><p>为了消除这种复杂度以及减少循环中的错误(比如错误使用其他循环中的变量)，ES6 提供了迭代器和 for of 循环共同解决这个问题。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>所谓迭代器，其实就是一个具有 next() 方法的对象，每次调用 next() 都会返回一个结果对象，该结果对象有两个属性，value 表示当前的值，done 表示遍历是否结束。</p><p>我们直接用 ES5 的语法创建一个迭代器：</p><p>  function createIterator(items) {<br>      var i = 0;<br>      return {<br>          next: function() {<br>              var done = i &gt;= item.length;<br>              var value = !done ? items[i++] : undefined;</p><pre><code>        return {            done: done,            value: value        };    }};</code></pre><p>  }</p><p>  // iterator 就是一个迭代器对象<br>  var iterator = createIterator([1, 2, 3]);</p><p>  console.log(iterator.next()); // { done: false, value: 1 }<br>  console.log(iterator.next()); // { done: false, value: 2 }<br>  console.log(iterator.next()); // { done: false, value: 3 }<br>  console.log(iterator.next()); // { done: true, value: undefined }</p><h4 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h4><p>除了迭代器之外，我们还需要一个可以遍历迭代器对象的方式，ES6 提供了 for of 语句，我们直接用 for of 遍历一下我们上节生成的遍历器对象试试：</p><p>  var iterator = createIterator([1, 2, 3]);</p><p>  for (let value of iterator) {<br>      console.log(value);<br>  }</p><p>结果报错 TypeError: iterator is not iterable，表明我们生成的 iterator 对象并不是 iterable(可遍历的)。</p><p>那什么才是可遍历的呢？</p><p>其实一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</p><p>ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是”可遍历的”（iterable）。</p><p>举个例子：</p><p>  const obj = {<br>      value: 1<br>  };</p><p>  for (value of obj) {<br>      console.log(value);<br>  }</p><p>// TypeError: iterator is not iterable<br>我们直接 for of 遍历一个对象，会报错，然而如果我们给该对象添加 Symbol.iterator 属性：</p><p>  const obj = {<br>      value: 1<br>  };</p><p>  obj[Symbol.iterator] = function() {<br>      return createIterator([1, 2, 3]);<br>  };</p><p>  for (value of obj) {<br>      console.log(value);<br>  }</p><p>  // 1<br>  // 2<br>  // 3</p><p>由此，我们也可以发现 for of 遍历的其实是对象的 Symbol.iterator 属性。</p><p>默认可遍历对象<br>然而如果我们直接遍历一个数组对象：</p><p>  const colors = [“red”, “green”, “blue”];</p><p>  for (let color of colors) {<br>      console.log(color);<br>  }</p><p>  // red<br>  // green<br>  // blue</p><p>尽管我们没有手动添加 Symbol.iterator 属性，还是可以遍历成功，这是因为 ES6 默认部署了 Symbol.iterator 属性，当然我们也可以手动修改这个属性：</p><p>  var colors = [“red”, “green”, “blue”];</p><p>  colors[Symbol.iterator] = function() {<br>      return createIterator([1, 2, 3]);<br>  };</p><p>  for (let color of colors) {<br>      console.log(color);<br>  }</p><p>  // 1<br>  // 2<br>  // 3</p><p>除了数组之外，还有一些数据结构默认部署了 Symbol.iterator 属性。</p><p>所以 for…of 循环可以使用的范围包括：</p><p>  数组<br>  Set<br>  Map<br>  类数组对象，如 arguments 对象、DOM NodeList 对象<br>  Generator 对象<br>  字符串</p><h4 id="模拟实现-for-of"><a href="#模拟实现-for-of" class="headerlink" title="模拟实现 for of"></a>模拟实现 for of</h4><p>其实模拟实现 for of 也比较简单，基本就是通过 Symbol.iterator 属性获取迭代器对象，然后使用 while 遍历一下：</p><p>  function forOf(obj, cb) {<br>      let iterable, result;</p><pre><code>if (typeof obj[Symbol.iterator] !== &quot;function&quot;)    throw new TypeError(result + &quot; is not iterable&quot;);if (typeof cb !== &quot;function&quot;) throw new TypeError(&quot;cb must be callable&quot;);iterable = obj[Symbol.iterator]();result = iterable.next();while (!result.done) {    cb(result.value);    result = iterable.next();}</code></pre><p>  }</p><p>#####　内建迭代器</p><p>为了更好的访问对象中的内容，比如有的时候我们仅需要数组中的值，但有的时候不仅需要使用值还需要使用索引，ES6 为数组、Map、Set 集合内建了以下三种迭代器：</p><p>  entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值。<br>  keys() 返回一个遍历器对象，用来遍历所有的键名。<br>  values() 返回一个遍历器对象，用来遍历所有的键值。</p><p>以数组为例：</p><p>  var colors = [“red”, “green”, “blue”];</p><p>  for (let index of colors.keys()) {<br>      console.log(index);<br>  }</p><p>  // 0<br>  // 1<br>  // 2</p><p>  for (let color of colors.values()) {<br>      console.log(color);<br>  }</p><p>  // red<br>  // green<br>  // blue</p><p>  for (let item of colors.entries()) {<br>      console.log(item);<br>  }</p><p>  // [ 0, “red” ]<br>  // [ 1, “green” ]<br>  // [ 2, “blue” ]</p><p>Map 类型与数组类似，但是对于 Set 类型需要注意以下：</p><p>  var colors = new Set([“red”, “green”, “blue”]);</p><p>  for (let index of colors.keys()) {<br>      console.log(index);<br>  }</p><p>  // red<br>  // green<br>  // blue</p><p>  for (let color of colors.values()) {<br>      console.log(color);<br>  }</p><p>  // red<br>  // green<br>  // blue</p><p>  for (let item of colors.entries()) {<br>      console.log(item);<br>  }</p><p>  // [ “red”, “red” ]<br>  // [ “green”, “green” ]<br>  // [ “blue”, “blue” ]</p><p>Set 类型的 keys() 和 values() 返回的是相同的迭代器，这也意味着在 Set 这种数据结构中键名与键值相同。</p><p>而且每个集合类型都有一个默认的迭代器，在 for-of 循环中，如果没有显式指定则使用默认的迭代器。数组和 Set 集合的默认迭代器是 values() 方法，Map 集合的默认迭代器是 entries() 方法。</p><p>这也就是为什么直接 for of 遍历 Set 和 Map 数据结构，会有不同的数据结构返回：</p><p>  const values = new Set([1, 2, 3]);</p><p>  for (let value of values) {<br>      console.log(value);<br>  }</p><p>  // 1<br>  // 2<br>  // 3</p><p>  const values = new Map([[“key1”, “value1”], [“key2”, “value2”]]);<br>  for (let value of values) {<br>      console.log(value);<br>  }</p><p>  // [“key1”, “value1”]<br>  // [“key2”, “value2”]</p><p>遍历 Map 数据结构的时候可以顺便结合解构赋值：</p><p>  const valuess = new Map([[“key1”, “value1”], [“key2”, “value2”]]);</p><p>  for (let [key, value] of valuess) {<br>      console.log(key + “:” + value);<br>  }</p><p>  // key1:value1<br>  // key2:value2</p><p>Babel 是如何编译 for of 的<br>我们可以在 Babel 的 Try it out 中查看编译的结果：</p><p>  const colors = new Set([“red”, “green”, “blue”]);</p><p>  for (let color of colors) {<br>      console.log(color);<br>  }</p><p>对于这样一段代码，编译的结果如下：</p><p>  “use strict”;</p><p>  var colors = new Set([“red”, “green”, “blue”]);</p><p>  var _iteratorNormalCompletion = true;<br>  var _didIteratorError = false;<br>  var _iteratorError = undefined;</p><p>  try {<br>      for (<br>          var _iterator = colors<a href>Symbol.iterator</a>, _step;<br>          !(_iteratorNormalCompletion = (_step = _iterator.next()).done);<br>          _iteratorNormalCompletion = true<br>      ) {<br>          var color = _step.value;</p><pre><code>    console.log(color);}</code></pre><p>  } catch (err) {<br>      _didIteratorError = true;<br>      _iteratorError = err;<br>  } finally {<br>      try {<br>          if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {<br>              _iterator.return();<br>          }<br>      } finally {<br>          if (_didIteratorError) {<br>              throw _iteratorError;<br>          }<br>      }<br>  }</p><p>至少由编译的结果可以看出，使用 for of 循环的背后，还是会使用 Symbol.iterator 接口。</p><p>而这段编译的代码稍微复杂的地方有两段，一段是 for 循环这里：</p><p>  for (<br>      var _iterator = colors<a href>Symbol.iterator</a>, _step;<br>      !(_iteratorNormalCompletion = (_step = _iterator.next()).done);<br>      _iteratorNormalCompletion = true<br>  ) {<br>      var color = _step.value;<br>      console.log(color);<br>  }</p><p>跟标准的 for 循环写法有些差别，我们看下 for 语句的语法：</p><p>  for (initialize; test; increment) statement;<br>  initialize、test 和 increment 三个表达式之间用分号分割，它们分别负责初始化操作、循环条件判断和计数器变量的更新。</p><p>  for 语句其实就相当于：</p><p>  initialize;<br>  while (test) {<br>      statement;<br>      increment;<br>  }</p><p>代码的逻辑为：先进行初始化，然后每次循环执行之前会执行 test 表达式，并判断表达式的结果来决定是否执行循环体，如果 test 计算结果为真值，则执行循环体中的 statement。最后，执行 increment 表达式。</p><p>而且值得注意的是，其实 for 循环中的三个表达式中任意一个都可以被忽略，不过分号还是要写的。</p><p>比如 for(;;)，不过这就是一个死循环……</p><p>比如：</p><p>  var i = 0,<br>      len = colors.length;<br>  for (; i &lt; len; i++) {<br>      console.log(colors[i]);<br>  }</p><p>又比如：</p><p>  var i = 0,<br>      len = colors.length;<br>  for (; i &lt; len; ) {<br>      i++;<br>  }</p><p>然后我们再来看 Babel 编译的这个 for 循环表达式：</p><p>  for (<br>      var _iterator = colors<a href>Symbol.iterator</a>, _step;<br>      !(_iteratorNormalCompletion = (_step = _iterator.next()).done);<br>      _iteratorNormalCompletion = true<br>  ) {<br>      var color = _step.value;<br>      console.log(color);<br>  }</p><p>用 while 的写法相当于：</p><p>  var _iterator = colors<a href>Symbol.iterator</a>,<br>      _step;<br>  while (!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) {<br>      var color = _step.value;<br>      console.log(color);<br>      _iteratorNormalCompletion = true;<br>  }</p><p>是不是就好懂了很多呢，然后你就会发现，其实 _iteratorNormalCompletion = true 这句是完全没有必要的……</p><p>另外一段稍微复杂的代码是:</p><p>  try {<br>    …<br>  } catch (err) {<br>    …<br>  } finally {<br>    try {<br>      if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {<br>        _iterator.return();<br>      }<br>    } finally {<br>      …<br>    }<br>  }</p><p>因为 _iteratorNormalCompletion = (_step = _iterator.next()).done，所以 _iteratorNormalCompletion 表示的就是是否完成了一次完整的迭代过程，如果没有正常的迭代完成，并且迭代器有 return 方法时，就会执行该方法。</p><p>而之所以这么做，就要提到迭代器的 return 方法。</p><p>引用阮一峰老师的 ECMAScript 6 入门:</p><p>遍历器对象除了具有 next 方法，还可以具有 return 方法和 throw 方法。如果你自己写遍历器对象生成函数，那么 next 方法是必须部署的，return 方法和 throw 方法是否部署是可选的。</p><p>return 方法的使用场合是，如果 for…of 循环提前退出（通常是因为出错，或者有 break 语句或 continue 语句），就会调用 return 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 return 方法。</p><p>我们可以举个例子：</p><p>  function createIterator(items) {<br>      var i = 0;<br>      return {<br>          next: function() {<br>              var done = i &gt;= items.length;<br>              var value = !done ? items[i++] : undefined;</p><pre><code>        return {            done: done,            value: value        };    },    return: function() {        console.log(&quot;执行了 return 方法&quot;);        return {            value: 23333,            done: true        };    }};</code></pre><p>  }</p><p>  var colors = [“red”, “green”, “blue”];</p><p>  var iterator = createIterator([1, 2, 3]);</p><p>  colors[Symbol.iterator] = function() {<br>      return iterator;<br>  };</p><p>  for (let color of colors) {<br>      if (color == 1) break;<br>      console.log(color);<br>  }</p><p>// 执行了 return 方法<br>不过正如你在编译后的代码中看到，仅仅是在有 return 函数的时候执行了 return 函数而已，return 函数中返回的值其实并不生效……</p><p>但是你不返回值或者返回一个基本类型的值的话，结果又会报错……</p><p>TypeError: Iterator result undefined is not an object<br>这是因为 return 方法必须返回一个对象，而这又是 Generator 规范决定的……</p><p>总之如果是在浏览器中使用的话，return 函数的返回值其实并不生效</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 系列之迭代器与 for of&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ES6 系列之箭头函数</title>
    <link href="http://yoursite.com/post/2018-11-05-20181105/"/>
    <id>http://yoursite.com/post/2018-11-05-20181105/</id>
    <published>2018-11-05T00:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.215Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 系列之箭头函数</p><a id="more"></a><h5 id="我们重点比较一下箭头函数与普通函数。"><a href="#我们重点比较一下箭头函数与普通函数。" class="headerlink" title="我们重点比较一下箭头函数与普通函数。"></a>我们重点比较一下箭头函数与普通函数。</h5><h4 id="1-没有-this"><a href="#1-没有-this" class="headerlink" title="1.没有 this"></a>1.没有 this</h4><h5 id="箭头函数没有-this，所以需要通过查找作用域链来确定-this-的值。"><a href="#箭头函数没有-this，所以需要通过查找作用域链来确定-this-的值。" class="headerlink" title="箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。"></a>箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。</h5><p>这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。</p><p>模拟一个实际开发中的例子：</p><p>我们的需求是点击一个按钮，改变该按钮的背景色。</p><p>为了方便开发，我们抽离一个 Button 组件，当需要使用的时候，直接：</p><p>  // 传入元素 id 值即可绑定该元素点击时改变背景色的事件<br>  new Button(“button”)<br>  HTML 代码如下：</p><p>  <button id="button">点击变色</button><br>  JavaScript 代码如下：</p><p>  function Button(id) {<br>      this.element = document.querySelector(“#” + id);<br>      this.bindEvent();<br>  }</p><p>  Button.prototype.bindEvent = function() {<br>      this.element.addEventListener(“click”, this.setBgColor, false);<br>  };</p><p>  Button.prototype.setBgColor = function() {<br>      this.element.style.backgroundColor = ‘#1abc9c’<br>  };</p><p>var button = new Button(“button”);<br>看着好像没有问题，结果却是报错 Uncaught TypeError: Cannot read property ‘style’ of undefined</p><p>这是因为当使用 addEventListener() 为一个元素注册事件的时候，事件函数里的 this 值是该元素的引用。</p><p>所以如果我们在 setBgColor 中 console.log(this)，this 指向的是按钮元素，那 this.element 就是 undefined，报错自然就理所当然了。</p><p>也许你会问，既然 this 都指向了按钮元素，那我们直接修改 setBgColor 函数为：</p><p>  Button.prototype.setBgColor = function() {<br>      this.style.backgroundColor = ‘#1abc9c’<br>  };</p><p>不就可以解决这个问题了？</p><p>确实可以这样做，但是在实际的开发中，我们可能会在 setBgColor 中还调用其他的函数，比如写成这种：</p><p>  Button.prototype.setBgColor = function() {<br>      this.setElementColor();<br>      this.setOtherElementColor();<br>  };</p><p>所以我们还是希望 setBgColor 中的 this 是指向实例对象的，这样就可以调用其他的函数。</p><p>利用 ES5，我们一般会这样做：</p><p>  Button.prototype.bindEvent = function() {<br>      this.element.addEventListener(“click”, this.setBgColor.bind(this), false);<br>  };</p><p>为避免 addEventListener 的影响，使用 bind 强制绑定 setBgColor() 的 this 为实例对象</p><p>使用 ES6，我们可以更好的解决这个问题：</p><p>  Button.prototype.bindEvent = function() {<br>      this.element.addEventListener(“click”, event =&gt; this.setBgColor(event), false);<br>  };</p><p>由于箭头函数没有 this，所以会向外层查找 this 的值，即 bindEvent 中的 this，此时 this 指向实例对象，所以可以正确的调用 this.setBgColor 方法， 而 this.setBgColor 中的 this 也会正确指向实例对象。</p><p>在这里再额外提一点，就是注意 bindEvent 和 setBgColor 在这里使用的是普通函数的形式，而非箭头函数，如果我们改成箭头函数，会导致函数里的 this 指向 window 对象 (非严格模式下)。</p><p>最后，因为箭头函数没有 this，所以也不能用 call()、apply()、bind() 这些方法改变 this 的指向，可以看一个例子：</p><p>  var value = 1;<br>  var result = (() =&gt; this.value).bind({value: 2})();<br>  console.log(result); // 1</p><h4 id="2-没有-arguments"><a href="#2-没有-arguments" class="headerlink" title="2. 没有 arguments"></a>2. 没有 arguments</h4><h5 id="箭头函数没有自己的-arguments-对象，这不一定是件坏事，因为箭头函数可以访问外围函数的-arguments-对象："><a href="#箭头函数没有自己的-arguments-对象，这不一定是件坏事，因为箭头函数可以访问外围函数的-arguments-对象：" class="headerlink" title="箭头函数没有自己的 arguments 对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象："></a>箭头函数没有自己的 arguments 对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象：</h5><p>  function constant() {<br>      return () =&gt; arguments[0]<br>  }</p><p>  var result = constant(1);<br>  console.log(result()); // 1</p><p>那如果我们就是要访问箭头函数的参数呢？</p><p>你可以通过命名参数或者 rest 参数的形式访问参数:</p><p>  let nums = (…nums) =&gt; nums;</p><h4 id="3-不能通过-new-关键字调用"><a href="#3-不能通过-new-关键字调用" class="headerlink" title="3. 不能通过 new 关键字调用"></a>3. 不能通过 new 关键字调用</h4><p>JavaScript 函数有两个内部方法：[[Call]] 和 [[Construct]]。</p><p>当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。</p><p>当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。</p><p>箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。</p><p>  var Foo = () =&gt; {};<br>  var foo = new Foo(); // TypeError: Foo is not a constructor</p><h4 id="4-没有-new-target"><a href="#4-没有-new-target" class="headerlink" title="4. 没有 new.target"></a>4. 没有 new.target</h4><p>因为不能使用 new 调用，所以也没有 new.target 值。</p><p>关于 new.target，可以参考 <a href="http://es6.ruanyifeng.com/#docs/class#new-target-%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/class#new-target-%E5%B1%9E%E6%80%A7</a></p><h4 id="5-没有原型"><a href="#5-没有原型" class="headerlink" title="5. 没有原型"></a>5. 没有原型</h4><p>由于不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性。</p><p>var Foo = () =&gt; {};<br>console.log(Foo.prototype); // undefined</p><h4 id="6-没有-super"><a href="#6-没有-super" class="headerlink" title="6. 没有 super"></a>6. 没有 super</h4><p>连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 系列之箭头函数&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ES6 系列之 let 和 const</title>
    <link href="http://yoursite.com/post/2018-11-01-20181101/"/>
    <id>http://yoursite.com/post/2018-11-01-20181101/</id>
    <published>2018-11-01T00:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.210Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 系列之 let 和 const</p><a id="more"></a><h5 id="块级作用域的出现"><a href="#块级作用域的出现" class="headerlink" title="块级作用域的出现"></a>块级作用域的出现</h5><p>通过 var 声明的变量存在变量提升的特性：</p><pre><code>if (condition) {    var value = 1;}console.log(value);</code></pre><p>初学者可能会觉得只有 condition 为 true 的时候，才会创建 value，如果 condition 为 false，结果应该是报错，然而因为变量提升的原因，代码相当于：</p><pre><code>var value;if (condition) {    value = 1;}console.log(value);</code></pre><p>如果 condition 为 false，结果会是 undefined。</p><p>除此之外，在 for 循环中：</p><pre><code>for (var i = 0; i &lt; 10; i++) {    ...}console.log(i); // 10</code></pre><p>即便循环已经结束了，我们依然可以访问 i 的值。</p><p>为了加强对变量生命周期的控制，ECMAScript 6 引入了块级作用域。</p><p>块级作用域存在于：</p><p>函数内部<br>块中(字符 { 和 } 之间的区域)</p><h5 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h5><p>块级声明用于声明在指定块的作用域之外无法访问的变量。</p><p>let 和 const 都是块级声明的一种。</p><p>我们来回顾下 let 和 const 的特点：</p><h6 id="1-不会被提升"><a href="#1-不会被提升" class="headerlink" title="1.不会被提升"></a>1.不会被提升</h6><pre><code>if (false) {    let value = 1;}console.log(value); // Uncaught ReferenceError: value is not defined</code></pre><h6 id="2-重复声明报错"><a href="#2-重复声明报错" class="headerlink" title="2.重复声明报错"></a>2.重复声明报错</h6><pre><code>var value = 1;let value = 2; // Uncaught SyntaxError: Identifier &apos;value&apos; has already been declared</code></pre><h6 id="3-不绑定全局作用域"><a href="#3-不绑定全局作用域" class="headerlink" title="3.不绑定全局作用域"></a>3.不绑定全局作用域</h6><p>当在全局作用域中使用 var 声明的时候，会创建一个新的全局变量作为全局对象的属性。</p><pre><code>var value = 1;console.log(window.value); // 1</code></pre><p>然而 let 和 const 不会：</p><pre><code>let value = 1;console.log(window.value); // undefined</code></pre><p>再来说下 let 和 const 的区别：</p><p>const 用于声明常量，其值一旦被设定不能再被修改，否则会报错。</p><p>值得一提的是：const 声明不允许修改绑定，但允许修改值。这意味着当用 const 声明对象时：</p><pre><code>const data = {    value: 1}// 没有问题data.value = 2;data.num = 3;// 报错data = {}; // Uncaught TypeError: Assignment to constant variable.</code></pre><h5 id="临时死区"><a href="#临时死区" class="headerlink" title="临时死区"></a>临时死区</h5><p>临时死区(Temporal Dead Zone)，简写为 TDZ。</p><p>let 和 const 声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，会导致报错：</p><p>console.log(typeof value); // Uncaught ReferenceError: value is not defined<br>let value = 1;<br>这是因为 JavaScript 引擎在扫描代码发现变量声明时，要么将它们提升到作用域顶部(遇到 var 声明)，要么将声明放在 TDZ 中(遇到 let 和 const 声明)。访问 TDZ 中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从 TDZ 中移出，然后方可访问。</p><p>看似很好理解，不保证你不犯错：</p><pre><code>var value = &quot;global&quot;;// 例子1(function() {    console.log(value);    let value = &apos;local&apos;;}());// 例子2{    console.log(value);    const value = &apos;local&apos;;};</code></pre><p>两个例子中，结果并不会打印 “global”，而是报错 Uncaught ReferenceError: value is not defined，就是因为 TDZ 的缘故。</p><p>如果let声明的变量没有变量提升，应该打印’global’；而它却报错，说明它是提升了的，只是规定了不能在其声明之前使用而已。我们称这特性叫“暂时性死区（temporal dead zone）”。且这一特性，仅对遵循‘块级作用域’的命令有效（let、const）。</p><p>循环中的块级作用域</p><pre><code>var funcs = [];for (var i = 0; i &lt; 3; i++) {    funcs[i] = function () {        console.log(i);    };}funcs[0](); // 3</code></pre><p>一个老生常谈的面试题，解决方案如下：</p><pre><code>var funcs = [];for (var i = 0; i &lt; 3; i++) {    funcs[i] = (function(i){        return function() {            console.log(i);        }    }(i))}funcs[0](); // 0</code></pre><p>ES6 的 let 为这个问题提供了新的解决方法：</p><pre><code>var funcs = [];for (let i = 0; i &lt; 3; i++) {    funcs[i] = function () {        console.log(i);    };}funcs[0](); // 0</code></pre><p>问题在于，上面讲了 let 不提升，不能重复声明，不能绑定全局作用域等等特性，可是为什么在这里就能正确打印出 i 值呢？</p><p>如果是不重复声明，在循环第二次的时候，又用 let 声明了 i，应该报错呀，就算因为某种原因，重复声明不报错，一遍一遍迭代，i 的值最终还是应该是 3 呀，还有人说 for 循环的<br>设置循环变量的那部分是一个单独的作用域，就比如：</p><pre><code>for (let i = 0; i &lt; 3; i++) {  let i = &apos;abc&apos;;  console.log(i);}// abc// abc// abc</code></pre><p>这个例子是对的，如果我们把 let 改成 var 呢？</p><pre><code>for (var i = 0; i &lt; 3; i++) {  var i = &apos;abc&apos;;  console.log(i);}// abc</code></pre><p>为什么结果就不一样了呢，如果有单独的作用域，结果应该是相同的呀……</p><p>总结：<br><a href="https://www.cnblogs.com/moumoon/p/10985250.html" target="_blank" rel="noopener">https://www.cnblogs.com/moumoon/p/10985250.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 系列之 let 和 const&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>浏览器 - 重绘和回流</title>
    <link href="http://yoursite.com/post/2018-10-03-20181003/"/>
    <id>http://yoursite.com/post/2018-10-03-20181003/</id>
    <published>2018-10-03T04:13:18.000Z</published>
    <updated>2020-03-10T01:17:54.196Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器采用流式布局模型（Flow Based Layout）<br>浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了渲染树（Render Tree）。<br>有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。<br>由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。</p><a id="more"></a><h5 id="1、浏览器渲染机制"><a href="#1、浏览器渲染机制" class="headerlink" title="1、浏览器渲染机制"></a>1、浏览器渲染机制</h5><p>浏览器采用流式布局模型（Flow Based Layout）<br>浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了渲染树（Render Tree）。<br>有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。<br>由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。</p><h5 id="2、-重绘"><a href="#2、-重绘" class="headerlink" title="2、 重绘"></a>2、 重绘</h5><p>由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如outline, visibility, color、background-color等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。</p><h5 id="3、回流"><a href="#3、回流" class="headerlink" title="3、回流"></a>3、回流</h5><p>回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。</p>  <body>  <div class="error">      <h4>我的组件</h4>      <p><strong>错误：</strong>错误的描述…</p>      <h5>错误纠正</h5>      <ol>          <li>第一步</li>          <li>第二步</li>      </ol>  </div>  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body><p>在上面的HTML片段中，对该段落(</p><p>标签)回流将会引发强烈的回流，因为它是一个子节点。这也导致了祖先的回流（div.error和body – 视浏览器而定）。此外，</p><h5>和<ol>也会有简单的回流，因为其在DOM中在回流元素之后。大部分的回流将导致页面的重新渲染。<p></p><h6 id="4、浏览器优化"><a href="#4、浏览器优化" class="headerlink" title="4、浏览器优化"></a>4、浏览器优化</h6><p>现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。<br>主要包括以下属性或方法：</p><pre><code>offsetTop、offsetLeft、offsetWidth、offsetHeightscrollTop、scrollLeft、scrollWidth、scrollHeightclientTop、clientLeft、clientWidth、clientHeightwidth、heightgetComputedStyle()getBoundingClientRect()</code></pre><p>所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。</p><h5 id="5、减少重绘与回流"><a href="#5、减少重绘与回流" class="headerlink" title="5、减少重绘与回流"></a>5、减少重绘与回流</h5><h6 id="1、CSS"><a href="#1、CSS" class="headerlink" title="1、CSS"></a>1、CSS</h6><p>使用 transform 替代 top</p><p>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局</p><p>避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。</p><p>尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。</p><p>避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。</p>  <div>    <a> <span></span> </a>  </div>  <style>    span {      color: red;    }    div > a > span {      color: red;    }  </style><p>对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平。</p><p>将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。</p><p>避免使用CSS表达式，可能会引发回流。</p><p>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。</p><p>CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</p><h6 id="2、JavaScript"><a href="#2、JavaScript" class="headerlink" title="2、JavaScript"></a>2、JavaScript</h6><p>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</p><p>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</p><p>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</p><p>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</p></ol></h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器采用流式布局模型（Flow Based Layout）&lt;br&gt;浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了渲染树（Render Tree）。&lt;br&gt;有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。&lt;br&gt;由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器 - 缓存机制</title>
    <link href="http://yoursite.com/post/2018-10-01-20181001/"/>
    <id>http://yoursite.com/post/2018-10-01-20181001/</id>
    <published>2018-10-01T02:23:18.000Z</published>
    <updated>2020-03-09T01:44:46.458Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说,浏览器缓存其实就是浏览器保存通过HTTP获取的所有资源,是浏览器将网络资源存储在本地的一种行为</p><a id="more"></a><h5 id="Service-Worker-Cache"><a href="#Service-Worker-Cache" class="headerlink" title="Service Worker Cache"></a>Service Worker Cache</h5><p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p><p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</p><p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p><p>Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，算是幕后工作，可以实现离线缓存，网络代理等</p><p>  window.navigator.serviceWorker.register(‘/kaikeba.js’).then(<br>    function () {<br>      console.log(‘注册成功’)<br>    }).catch(err =&gt; {<br>      console.error(“注册失败”)<br>  })</p><h5 id="memory-cache"><a href="#memory-cache" class="headerlink" title="memory cache"></a>memory cache</h5><p>Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p><p>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？<br>这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。</p><p>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</p><p>内存缓存中有一块重要的缓存资源是preloader相关指令（例如<link rel="prefetch">）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。</p><p>需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。</p><h5 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h5><p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。</p><p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。</p><p>浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？<br>关于这点，网上说法不一，不过以下观点比较靠得住：</p><p>对于大文件来说，大概率是不存储在内存中的，反之优先<br>当前系统内存使用率高的话，文件优先存储进硬盘</p><h5 id="push-cache"><a href="#push-cache" class="headerlink" title="push cache"></a>push cache</h5><p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</p><p>Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读Jake Archibald的 HTTP/2 push is tougher than I thought 这篇文章，文章中的几个结论：</p><p>所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差<br>可以推送 no-cache 和 no-store 的资源<br>一旦连接被关闭，Push Cache 就被释放<br>多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。<br>Push Cache 中的缓存只能被使用一次<br>浏览器可以拒绝接受已经存在的资源推送<br>你可以给其他域名推送资源</p><h6 id="如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。"><a href="#如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。" class="headerlink" title="如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。"></a>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</h6><p>那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的</p><h4 id="三、缓存过程分析"><a href="#三、缓存过程分析" class="headerlink" title="三、缓存过程分析"></a>三、缓存过程分析</h4><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的</p><p>由上图我们可以知道：</p><p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</p><p>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p><p>以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。</p><h4 id="四、强缓存"><a href="#四、强缓存" class="headerlink" title="四、强缓存"></a>四、强缓存</h4><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。</p><h6 id="1-Expires"><a href="#1-Expires" class="headerlink" title="1.Expires"></a>1.Expires</h6><p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><p>Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018</p><h6 id="2、Cache-Control"><a href="#2、Cache-Control" class="headerlink" title="2、Cache-Control"></a>2、Cache-Control</h6><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p><p>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：</p><p>public：所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如 Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。</p><p>private：所有内容只有客户端可以缓存，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。</p><p>no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</p><p>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p><p>max-age：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效</p><p>s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。</p><p>max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。</p><p>min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。</p><p><img src="http://github.com/unicorn.png" alt="github" title="github">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单来说,浏览器缓存其实就是浏览器保存通过HTTP获取的所有资源,是浏览器将网络资源存储在本地的一种行为&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解vue中的slot与slot-scope</title>
    <link href="http://yoursite.com/post/2018-09-21-20180921/"/>
    <id>http://yoursite.com/post/2018-09-21-20180921/</id>
    <published>2018-09-21T12:48:18.000Z</published>
    <updated>2020-03-09T01:44:46.427Z</updated>
    
    <content type="html"><![CDATA[<p>单个插槽 | 默认插槽 | 匿名插槽</p><a id="more"></a><h2 id="单个插槽"><a href="#单个插槽" class="headerlink" title="单个插槽"></a>单个插槽</h2><p>首先是单个插槽，单个插槽是vue的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置name属性。<br>单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（name属性）不同就可以了。</p><p>下面通过一个例子来展示。</p><p>父组件：</p><pre><code>&lt;template&gt;    &lt;div class=&quot;father&quot;&gt;        &lt;h3&gt;这里是父组件&lt;/h3&gt;        &lt;child&gt;            &lt;div class=&quot;tmpl&quot;&gt;            &lt;span&gt;菜单1&lt;/span&gt;            &lt;span&gt;菜单2&lt;/span&gt;            &lt;span&gt;菜单3&lt;/span&gt;            &lt;span&gt;菜单4&lt;/span&gt;            &lt;span&gt;菜单5&lt;/span&gt;            &lt;span&gt;菜单6&lt;/span&gt;            &lt;/div&gt;        &lt;/child&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><p>子组件：</p><pre><code>&lt;template&gt;    &lt;div class=&quot;child&quot;&gt;        &lt;h3&gt;这里是子组件&lt;/h3&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>匿名插槽没有name属性，所以是匿名插槽，那么，插槽加了name属性，就变成了具名插槽。具名插槽可以在一个组件中出现N次，出现在不同的位置。下面的例子，就是一个有两个具名插槽和单个插槽的组件，这三个插槽被父组件用同一套css样式显示了出来，不同的是内容上略有区别。</p><p>父组件：</p><pre><code>&lt;template&gt;&lt;div class=&quot;father&quot;&gt;    &lt;h3&gt;这里是父组件&lt;/h3&gt;    &lt;child&gt;    &lt;div class=&quot;tmpl&quot; slot=&quot;up&quot;&gt;        &lt;span&gt;菜单1&lt;/span&gt;        &lt;span&gt;菜单2&lt;/span&gt;        &lt;span&gt;菜单3&lt;/span&gt;        &lt;span&gt;菜单4&lt;/span&gt;        &lt;span&gt;菜单5&lt;/span&gt;        &lt;span&gt;菜单6&lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;tmpl&quot; slot=&quot;down&quot;&gt;        &lt;span&gt;菜单-1&lt;/span&gt;        &lt;span&gt;菜单-2&lt;/span&gt;        &lt;span&gt;菜单-3&lt;/span&gt;        &lt;span&gt;菜单-4&lt;/span&gt;        &lt;span&gt;菜单-5&lt;/span&gt;        &lt;span&gt;菜单-6&lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;tmpl&quot;&gt;        &lt;span&gt;菜单-&gt;1&lt;/span&gt;        &lt;span&gt;菜单-&gt;2&lt;/span&gt;        &lt;span&gt;菜单-&gt;3&lt;/span&gt;        &lt;span&gt;菜单-&gt;4&lt;/span&gt;        &lt;span&gt;菜单-&gt;5&lt;/span&gt;        &lt;span&gt;菜单-&gt;6&lt;/span&gt;    &lt;/div&gt;    &lt;/child&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><p>子组件：</p><pre><code>&lt;template&gt;    &lt;div class=&quot;child&quot;&gt;        // 具名插槽        &lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;        &lt;h3&gt;这里是子组件&lt;/h3&gt;        // 具名插槽        &lt;slot name=&quot;down&quot;&gt;&lt;/slot&gt;        // 匿名插槽        &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="作用域插槽-带数据的插槽"><a href="#作用域插槽-带数据的插槽" class="headerlink" title="作用域插槽 | 带数据的插槽"></a>作用域插槽 | 带数据的插槽</h2><p>最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的template里面写</p><pre><code>匿名插槽&lt;slot&gt;&lt;/slot&gt;具名插槽&lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;</code></pre><p>但是作用域插槽要求，在slot上面绑定数据。也就是你得写成大概下面这个样子。</p><pre><code>&lt;slot name=&quot;up&quot; :data=&quot;data&quot;&gt;&lt;/slot&gt;export default {    data: function(){    return {        data: [&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wanwu&apos;,&apos;zhaoliu&apos;,&apos;tianqi&apos;,&apos;xiaoba&apos;]    }    },}</code></pre><p>我们前面说了，插槽最后显示不显示是看父组件有没有在child下面写模板，像下面那样。</p><pre><code>&lt;child&gt;html模板&lt;/child&gt;</code></pre><p>写了，插槽就总得在浏览器上显示点东西，东西就是html该有的模样，没写，插槽就是空壳子，啥都没有。OK，我们说有html模板的情况，就是父组件会往子组件插模板的情况，那到底插一套什么样的样式呢，这由父组件的html+css共同决定，但是这套样式里面的内容呢？</p><p>正因为作用域插槽绑定了一套数据，父组件可以拿来用。于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。</p><p>我们再来对比，作用域插槽跟单个插槽和具名插槽的区别，因为单个插槽和具名插槽不绑定数据，所以父组件提供的模板一般要既包括样式又包括内容，上面的例子中，你看到的文字，“菜单1”，“菜单2”都是父组件自己提供的内容；而作用域插槽，父组件只需要提供一套样式（在确实用作用域插槽绑定的数据的前提下）。</p><p>下面的例子，你就能看到，父组件提供了三种样式(分别是flex、ul、直接显示)，都没有提供数据，数据使用的都是子组件插槽自己绑定的那个数组（一堆人名的那个数组）。</p><pre><code>&lt;template&gt;    &lt;div class=&quot;father&quot;&gt;        &lt;h3&gt;这里是父组件&lt;/h3&gt;        &lt;!--第一次使用：用flex展示数据--&gt;        &lt;child&gt;        &lt;template slot-scope=&quot;user&quot;&gt;            &lt;div class=&quot;tmpl&quot;&gt;            &lt;span v-for=&quot;item in user.data&quot;&gt;{{item}}&lt;/span&gt;            &lt;/div&gt;        &lt;/template&gt;        &lt;/child&gt;        &lt;!--第二次使用：用列表展示数据--&gt;        &lt;child&gt;        &lt;template slot-scope=&quot;user&quot;&gt;            &lt;ul&gt;            &lt;li v-for=&quot;item in user.data&quot;&gt;{{item}}&lt;/li&gt;            &lt;/ul&gt;        &lt;/template&gt;        &lt;/child&gt;        &lt;!--第三次使用：直接显示数据--&gt;        &lt;child&gt;        &lt;template slot-scope=&quot;user&quot;&gt;        {{user.data}}        &lt;/template&gt;        &lt;/child&gt;        &lt;!--第四次使用：不使用其提供的数据, 作用域插槽退变成匿名插槽--&gt;        &lt;child&gt;        我就是模板        &lt;/child&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单个插槽 | 默认插槽 | 匿名插槽&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex的state，actions，getters，mutations的使用</title>
    <link href="http://yoursite.com/post/2018-09-19-20180919/"/>
    <id>http://yoursite.com/post/2018-09-19-20180919/</id>
    <published>2018-09-19T12:48:18.000Z</published>
    <updated>2020-03-09T01:44:46.395Z</updated>
    
    <content type="html"><![CDATA[<p>vuex的state，actions，getters，mutations的使用 分为两种情况，有module和没有mudule</p><a id="more"></a><p>##有module</p><p>###看getters，有四种写法</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;getUserName()&quot;&gt;      点击获取用户名    &lt;/button&gt;    &lt;div&gt;获取到的用户名：{{userName}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import {mapGetters} from &apos;vuex&apos;  export default {    name: &quot;login&quot;,    data: function () {      return {        userName: &apos;&apos;,      }    },    methods:{      getUserName:function(){        /**         *  调用getters有四种方法         *  第一种：this.userName = this.gettersName ，需要在computed中写...mapGetters         *  第二种：this.userName = this[&apos;gettersName&apos;] ，需要在computed中写...mapGetters         *  第三种：this.userName = this.$store.getters.gettersName，直接调用getters.js中的gettersName方法，不需要mapGetters         *  第四种：this.userName = this.$store.getters[&apos;gettersName&apos;]，直接调用getters.js中的gettersName方法，不需要mapGetters         */        console.log(&apos;没有module的getters：&apos;+JSON.stringify(this.$store.getters))//{&quot;gettersName&quot;:&quot;111&quot;}        this.userName = this.$store.getters[&apos;gettersName&apos;]      }    },    computed: {      ...mapGetters([        &apos;gettersName&apos;      ])    },  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>###actions有三种写法：</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;input type=&quot;number&quot; v-model=&quot;userName&quot; placeholder=&quot;请输入用户名&quot; /&gt;    &lt;div @click=&apos;loginClick()&apos;&gt; 登录&lt;/div&gt;    &lt;div&gt;{{test}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import { mapActions } from &apos;vuex&apos;  export default {    name: &quot;login&quot;,    data:function () {      return{        userName:&apos;&apos;,      }    },    methods:{      ...mapActions([        &apos;setActionName&apos;      ]),      loginClick:function () {        /**         *  调用actions有三种方法         *  第一种：this.setActionName(this.userName)，需要在methods中写...mapActions         *  第二种：this[&apos;setActionName&apos;](this.userName)，需要在methods中写...mapActions         *  第三种：this.$store.dispatch(&apos;setActionName&apos;,this.userName)，直接调用actions.js中的setActionName方法，不需要mapActions         */        this.$store.dispatch(&apos;setActionName&apos;,this.userName)      },    },    computed:{      test(){        return this.$store.state.name;      }    }  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>###mutations有一种写法：</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;input type=&quot;number&quot; v-model=&quot;userName&quot; placeholder=&quot;请输入用户名&quot; /&gt;    &lt;button @click=&apos;loginClick()&apos;&gt; 登录&lt;/button&gt;    &lt;div&gt;{{test}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    name: &quot;login&quot;,    data:function () {      return{        userName:&apos;&apos;,      }    },    methods:{      loginClick:function () {        /**         *  调用mutations有一种方法         *   this.$store.commit(&apos;setMutationName&apos;,this.userName)         */        this.$store.commit(&apos;setMutationName&apos;,this.userName)      },    },    computed:{      test(){        return this.$store.state.name;      }    }  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>##state有四种写法：</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;button @click=&apos;loginClick()&apos;&gt; 获取用户名&lt;/button&gt;    &lt;div&gt;获取到的用户名：{{userName}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import { mapState } from &apos;vuex&apos;  export default {    name: &quot;login&quot;,    data:function () {      return{        userName:&apos;&apos;,      }    },    methods:{      loginClick:function () {        /**         *  调用state有四种方法         *  第一种：this.userName = this.$store.state.name,不需要...mapstate         *  第二种：this.userName = this.$store.state[&apos;name&apos;],不需要...mapstate         *  第三种：this.userName = this.getName，需要...mapstate         *  第四种：this.userName = this[&apos;getName&apos;]，需要...mapstate         */        console.log(&apos;没有module的state：&apos;+JSON.stringify(this.$store.state))//{&quot;name&quot;:&quot;111&quot;}        this.userName = this[&apos;getName&apos;]      },    },    computed:{      ...mapState({        getName: state =&gt; state.name,      }),    }  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>##再来看看有module的情况：</p><p>###接下来看看有module时getters的使用：getters有两种使用方法</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;getUserName()&quot;&gt;      点击获取用户名    &lt;/button&gt;    &lt;div&gt;获取到的用户名：{{userName}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import {mapGetters} from &apos;vuex&apos;  export default {    name: &quot;login&quot;,    data: function () {      return {        userName: &apos;&apos;,      }    },    methods:{      getUserName:function(){        /**         *  调用getters有两种方法         *  第一种：this.userName = this[&apos;mod1/getUserName&apos;] ，需要在computed中写...mapGetters         *  第二种：this.userName = this.$store.getters[&apos;mod1/getUserName&apos;]，直接调用gettersOne.js中的mod1的getUserName方法，不需要mapGetters         */        console.log(&apos;有module的getters：&apos;+JSON.stringify(this.$store.getters))//{&quot;getAddress&quot;:&quot;西安市&quot;,&quot;mod1/getUserName&quot;:&quot;testName&quot;,&quot;mod1/getUserNameTest&quot;:&quot;testName&quot;}        this.userName = this.$store.getters[&apos;mod1/getUserName&apos;];      }    },    computed: {      ...mapGetters([        &apos;mod1/getUserName&apos;      ])    },  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>###有module的state：state有四种使用方法</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;button @click=&apos;loginClick()&apos;&gt; 获取用户名&lt;/button&gt;    &lt;div&gt;获取到的用户名：{{userName}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import { mapState } from &apos;vuex&apos;  export default {    name: &quot;login&quot;,    data:function () {      return{        userName:&apos;&apos;,      }    },    methods:{      loginClick:function () {        /**         *  调用state有四种方法         *  第一种：this.userName = this.$store.state.mod1.userName,不需要...mapstate         *  第二种：this.userName = this.$store.state.mod1[&apos;userName&apos;],不需要...mapstate         *  第三种：this.userName = this.getName，需要...mapstate         *  第四种：this.userName = this[&apos;getName&apos;]，需要...mapstate         */        console.log(&apos;===&apos;+ JSON.stringify(this.$store.state))//{&quot;address&quot;:&quot;西安市&quot;,&quot;mod1&quot;:{&quot;userName&quot;:&quot;testName&quot;}}        this.userName = this.getName      },    },    computed:{      ...mapState({        /**         * 下面的方法也可以写为         *  getName: function(state){              console.log(JSON.stringify(state))//{&quot;address&quot;:&quot;西安市&quot;,&quot;mod1&quot;:{&quot;userName&quot;:&quot;testName&quot;}}              return  state.mod1.userName           }         * @param state         * @returns {*}         */        getName: state =&gt;state.mod1.userName//或者getName: state =&gt;state.mod1[&apos;userName&apos;]      }),    }  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>###有module的actions：action有两种使用方法</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;input type=&quot;number&quot; v-model=&quot;userName&quot; placeholder=&quot;请输入用户名&quot; /&gt;    &lt;div @click=&apos;loginClick()&apos;&gt; 登录&lt;/div&gt;    &lt;div&gt;{{test}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import { mapActions } from &apos;vuex&apos;  export default {    name: &quot;login&quot;,    data:function () {      return{        userName:&apos;&apos;,      }    },    methods:{      ...mapActions([        &apos;mod1/changeName&apos;      ]),      loginClick:function () {        /**         *  调用actions有两种方法         *  第一种：this[&apos;mod1/changeName&apos;](this.userName)，需要在methods中写...mapActions         *  第二种：this.$store.dispatch(&apos;mod1/changeName&apos;,this.userName)，直接调用actions.js中的changeName方法，不需要mapActions         */        this[&apos;mod1/changeName&apos;](this.userName)      },    },    computed:{      test(){        return this.$store.state.mod1.userName;      }    }  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>###有module的mutations：mutations有一种使用方法</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;input type=&quot;number&quot; v-model=&quot;userName&quot; placeholder=&quot;请输入用户名&quot; /&gt;    &lt;button @click=&apos;loginClick()&apos;&gt; 登录&lt;/button&gt;    &lt;div&gt;{{test}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    name: &quot;login&quot;,    data:function () {      return{        userName:&apos;&apos;,      }    },    methods:{      loginClick:function () {        /**         *  调用mutations有一种方法         *   this.$store.commit(&apos;setName&apos;,this.userName)         */        this.$store.commit(&apos;mod1/setName&apos;,this.userName)      },    },    computed:{      test(){        return this.$store.state.mod1.userName;      }    }  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vuex的state，actions，getters，mutations的使用 分为两种情况，有module和没有mudule&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue - vuex" scheme="http://yoursite.com/categories/vue-vuex/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>收藏 -记录</title>
    <link href="http://yoursite.com/post/2018-09-17-20180917/"/>
    <id>http://yoursite.com/post/2018-09-17-20180917/</id>
    <published>2018-09-17T12:48:18.000Z</published>
    <updated>2020-03-09T01:44:46.374Z</updated>
    
    <content type="html"><![CDATA[<p>网站地址收藏 -爱好收藏 </p><a id="more"></a><p>##js</p><p>彻底弄懂 JavaScript 执行机制  （<a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">https://juejin.im/post/59e85eebf265da430d571f89</a> ）</p><p>函数防抖和节流（<a href="https://www.jianshu.com/p/c8b86b09daf0" target="_blank" rel="noopener">https://www.jianshu.com/p/c8b86b09daf0</a> ）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网站地址收藏 -爱好收藏 &lt;/p&gt;
    
    </summary>
    
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="日志" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>sass（scss）、less、postcss、stylus等的用法与区别</title>
    <link href="http://yoursite.com/post/2018-01-02-20180102/"/>
    <id>http://yoursite.com/post/2018-01-02-20180102/</id>
    <published>2018-01-02T12:38:18.000Z</published>
    <updated>2020-03-09T01:44:46.320Z</updated>
    
    <content type="html"><![CDATA[<p> 它们都是css预处理器。css预处理器的概念：CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。</p><a id="more"></a><h5 id="一-Sass-Scss、Less、stylus是什么"><a href="#一-Sass-Scss、Less、stylus是什么" class="headerlink" title="一. Sass/Scss、Less、stylus是什么?"></a>一. Sass/Scss、Less、stylus是什么?</h5><p>  它们都是css预处理器。css预处理器的概念：CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。</p><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍:"></a>基本介绍:</h5><h6 id="sass-scss"><a href="#sass-scss" class="headerlink" title="sass/scss"></a>sass/scss</h6><p>  SASS 2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持和compass这一最强大的css框架<br>  Sass的缩排语法，对于写惯css前端的web开发者来说很不直观，sass 不兼容 css 代码<br>  Sass3 就变成了Scss(sassy css) 与原来的语法兼容，只是用{}取代了原来的缩进<br>  sass 的运行 依赖于 ruby 环境（compass 将 sass 编译为 css）<br>  现在可用 node-sass 来编译 sass/scss 文件</p><pre><code>node-sass 是一套在 node.js 用 LibSass 編 sass/scss 的工具原始的sass 是用 ruby 编写的，所以需要 ruby 环境，libSass 是原始sass引擎的一个 c/c++ 接口，使用它编译sass不依赖于ruby，可以使用其他语言使用libSassnode-sassruby-sass与libsass的区别安装node-sass时，会去GitHub 下载一个 .node的文件而这个文件托管在墙外的服务器上，所以失败了 node-sass安装失败解决方案</code></pre><p>  以 .sass 或 .scss 为文件后缀名称（现在一般都是用 scss）</p><h6 id="less"><a href="#less" class="headerlink" title="less"></a>less</h6><p>  less 2009年出现，受sass的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS，其缺点是比起SASS来，可编程功能不够，不过优点是简单和兼容CSS，反过来也影响了sass演变到了scss的时代，著名的Twitter Bootstrap就是采用LESS做底层语言的。<br>  less 可以使用 less.js 在浏览器运行时中解析 less 代码<br>  也可以在 node环境中 安装 less，提前编译 less 文件 npm install -g less &amp;lessc styles.less styles.css (可以加参数控制编译后的css排版及压缩)<br>  以 .less 为文件后缀名称</p><h6 id="stylus"><a href="#stylus" class="headerlink" title="stylus"></a>stylus</h6><p> Stylus，2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，由 TJ 大神开发安装及编译 npm install stylus -g &amp; stylus src/ (可以加参数控制编译后的css排版及压缩)以 .styl 为文件后缀<br> 使用现状：现在一般都是配合webpack使用这几种预处理语言，需要先安装 编译器、对应 loader，然后再 module.rules 配置其具体规则</p><h6 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h6><p>  less 基本语法属于 css 风格，而 sass，stylus 利用缩进，空格，换行来减少需要输入的 字符<br>  目前 scss, stylus 也可以支持 css 风格，用大括号 来书写</p><p>1、变量符 @ $ 无变量符号直接变量名</p><pre><code>less @size: 10px;.box {    width: @size;}scss$red: #c00;strong {    color: $red;}stylusred = #c00strong    color: redcss 的变量规范/* global scope */:root {    --red: #c00;}strong {    color: var(--red);}* 变量作用域：less 惰性加载，sass，stylus 就近加载</code></pre><p>2、嵌套语法一致，用 &amp; 引用父集 – 嵌套不建议超过 4 层</p><pre><code>* less 不支持跳出嵌套* sass `@at-root`<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@at-root 支持参数，跳出不同的嵌套 </span><br><span class="line">without： all，表示所有</span><br><span class="line">without: rule，表示常规css，rule是默认值</span><br><span class="line">without: media，表示media</span><br><span class="line">without: support，@support现在使用还不广泛</span><br><span class="line"></span><br><span class="line">// child1 将跳出 parent 的嵌套</span><br><span class="line">.parent1&#123;</span><br><span class="line">    color:#f00;</span><br><span class="line">    @at-root .child1 &#123;</span><br><span class="line">        width:200px;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>3、插值</p><pre><code>less@prefix: ui;.@{prefix}-button {color: #333;}sass$prefix: ui.#{$prefix}-button {    color: #333;}stylusprefix = ui.{prefix}-button    color #333</code></pre><p>4、混入（mixin）：预处理器最精髓的功能，样式层面上的抽象（相当于copy代码片段）<br>  less 直接引入<br>  scss 要先声明 @mixin,使用时 @include</p><p>5、继承<br>6、函数<br>7、逻辑控制：sass, stylus 支持 if else for each while, less 使用 mixin when 处理<br>具体语法看官方文档</p><h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>  sass 大而全，出现时间最久，但依赖于 ruby (compass)<br>  less 可以平滑的从 css 过度而来，可以在运行时解析，逻辑功能有些缺失<br>  stylus 起源 nodejs 社区，语法灵活， 有一个官方开发的样式库 nib，同样提供了不少好用的 mixin</p><h5 id="Postcss-是什么样的一种存在？"><a href="#Postcss-是什么样的一种存在？" class="headerlink" title="Postcss 是什么样的一种存在？"></a>Postcss 是什么样的一种存在？</h5><p>PostCSS 既不是预处理器也不是后处理器，而是一个平台，其本身并不处理任何具体任务，只有当我们为其附加各种插件之后，他才具有实用性<br>PostCSS 就像是一个使能器（enabler），他可以不用完全替代现有的预处理器或后处理器，而只是作为他们的补充工具。PostCSS的工作机制主要包含解析代码、执行插件、渲染结果三部分：<br>PostCSS 会将css代码解析成包含一系列节点的抽象语法树（AST, Abtract Syntax Tree）。<br>PostCSS常用插件 （用这些插件集合其实已经可以代替 三大 css 预处理器）</p><pre><code>cssnext, 未来语法，颜色函数...postcss-import, 导入文件autoprefixer, 自动前缀precss, 集成sass预处理器，功能强大包括 autoprefixer mixinspostcss-mixins, 混合宏，是用类似sass的混合宏，不可与 precss 混用postcss-conditions 逻辑判断...</code></pre><p>目前 Postcss 在一般项目中的用途</p><p>  使用其 autoprefixer 插件，为css 属性增加前缀<br>  创建 postcss.config.js</p><pre><code>// webpack.config.js{    test: /\.less$/,    loader: ExtractTextWebpackPlugin.extract([        {loader: &apos;css-loader&apos;, options: { minimize: true }},        &apos;postcss-loader&apos;, // 要在预处理器处理完之后，在使用 postcss-loader         &apos;less-loader&apos;,    ]),}// postcss.config.jsmodule.exports = {    plugins: [        require(&apos;autoprefixer&apos;)({            &apos;browsers&apos;: [&apos;&gt; 1%&apos;, &apos;last 2 versions&apos;]        })    ]}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 它们都是css预处理器。css预处理器的概念：CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>js判断当前浏览类型</title>
    <link href="http://yoursite.com/post/2017-06-28-20170628/"/>
    <id>http://yoursite.com/post/2017-06-28-20170628/</id>
    <published>2017-06-28T02:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.157Z</updated>
    
    <content type="html"><![CDATA[<p>js判断当前浏览类型</p><a id="more"></a><p>var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串<br>var isOpera = userAgent.indexOf(“Opera”) &gt; -1; //判断是否Opera浏览器<br>var isIE = userAgent.indexOf(“compatible”) &gt; -1 &amp;&amp; userAgent.indexOf(“MSIE”) &gt; -1 &amp;&amp; !isOpera; //判断是否IE浏览器<br>var isEdge = userAgent.indexOf(“Edge”) &gt; -1; //判断是否IE的Edge浏览器<br>var isFF = userAgent.indexOf(“Firefox”) &gt; -1; //判断是否Firefox浏览器<br>var isSafari = userAgent.indexOf(“Safari”) &gt; -1 &amp;&amp; userAgent.indexOf(“Chrome”) == -1; //判断是否Safari浏览器<br>var isChrome = userAgent.indexOf(“Chrome”) &gt; -1 &amp;&amp; userAgent.indexOf(“Safari”) &gt; -1; //判断Chrome浏览器</p><p>判断是否为IE浏览器，包括IE11(edge不属于IE浏览器)</p><p>var isIE = “ActiveXObject” in window</p><p>判断ie6-ie9<br>if(navigator.appName == “Microsoft Internet Explorer” &amp;&amp; navigator.appVersion .split(“;”)[1].replace(/[ ]/g,””)==”MSIE6.0”)<br>{<br>alert(“IE 6.0”);<br>}<br>else if(navigator.appName == “Microsoft Internet Explorer” &amp;&amp; navigator.appVersion .split(“;”)[1].replace(/[ ]/g,””)==”MSIE7.0”)<br>{<br>alert(“IE 7.0”);<br>}<br>else if(navigator.appName == “Microsoft Internet Explorer” &amp;&amp; navigator.appVersion .split(“;”)[1].replace(/[ ]/g,””)==”MSIE8.0”)<br>{<br>alert(“IE 8.0”);<br>}<br>else if(navigator.appName == “Microsoft Internet Explorer” &amp;&amp; navigator.appVersion .split(“;”)[1].replace(/[ ]/g,””)==”MSIE9.0”)<br>{<br>alert(“IE 9.0”);<br>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js判断当前浏览类型&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>IE和火狐的css兼容性问题</title>
    <link href="http://yoursite.com/post/2017-06-18-20170618/"/>
    <id>http://yoursite.com/post/2017-06-18-20170618/</id>
    <published>2017-06-18T02:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.116Z</updated>
    
    <content type="html"><![CDATA[<p>IE和火狐的css兼容性问题</p><a id="more"></a><pre><code>CSS对浏览器器的兼容性具有很高的价值，通常情况下IE和Firefox存在很大的解析差异，这里介绍一下兼容要点。</code></pre><p>　　1、DOCTYPE 影响 CSS 处理<br>　　2、FF: div 设置 margin-left, margin-right 为 auto 时已经居中, IE 不行<br>　　3、FF: body 设置 text-align 时, div 需要设置 margin: auto(主要是 margin-left,margin-right) 方可居中<br>　　4、FF: 设置 padding 后, div 会增加 height 和 width, 但 IE 不会, 故需要用 !important 多设一个 height 和 width<br>　　5、FF: 支持 !important, IE 则忽略, 可用 !important 为 FF 特别设置样式，值得注意的是，一定要将xxxx !important 这句放置在另一句之上<br>　　6、div 的垂直居中问题: vertical-align:middle; 将行距增加到和整个DIV一样高 line-height:200px; 然后插入文字，就垂直居中了。缺点是要控制内容不要换行<br>　　7、cursor: pointer 可以同时在 IE FF 中显示游标手指状， hand 仅 IE 可以<br>　　8、FF: 链接加边框和背景色，需设置 display: block, 同时设置 float: left 保证不换行。参照 menubar, 给 a 和 menubar 设置高度是为了避免底边显示错位, 若不设 height, 可以在 menubar 中插入一个空格。<br>　　9、在mozilla firefox和IE中的BOX模型解释不一致导致相差2px解决方法：div{margin:30px!important;margin:28px;}<br>　　注意这两个margin的顺序一定不能写反，据阿捷的说法!important这个属性IE不能识别，但别的浏览器可以识别。所以在IE下其实解释成这样：div{maring:30px;margin:28px}<br>　　重复定义的话按照最后一个来执行，所以不可以只写margin:XXpx!important;<br>　　10、IE5 和IE6的BOX解释不一致<br>　　IE5下div{width:300px;margin:0 10px 0 10px;}<br>　　div的宽度会被解释为300px-10px(右填充)-10px(左填充)最终div的宽度为280px，而在IE6和其他浏览器上宽度则是以 300px+10px(右填充)+10px(左填充)=320px来计算的。这时我们可以做如下修改div{width:300px! important;width /<strong>/:340px;margin:0 10px 0 10px}<br>　　关于这个/</strong>/是什么我也不太明白，只知道IE5和firefox都支持但IE6不支持，如果有人理解的话，请告诉我一声，谢了!：)<br>　　11、ul标签在Mozilla中默认是有padding值的,而在IE中只有margin有值所以先定义ul{margin:0;padding:0;}<br>　　就能解决大部分问题<br>　　<br>    注意事项：<br>　　1、float的div一定要闭合。<br>　　例如：(其中floatA、floatB的属性已经设置为float:left;)&lt;#div id=\”floatA\” &gt;<br>　　&lt;#div id=\”floatB\” &gt;<br>　　&lt;#div id=\”NOTfloatC\” &gt;<br>　　这里的NOTfloatC并不希望继续平移，而是希望往下排。<br>　　这段代码在IE中毫无问题，问题出在FF。原因是NOTfloatC并非float标签，必须将float标签闭合。<br>　　在&lt;#div class=\”floatB\”&gt;<br>　　&lt;#div class=\”NOTfloatC\”&gt;<br>　　之间加上&lt;#div class=\”clear\”&gt;<br>　　这个div一定要注意声明位置，一定要放在最恰当的地方，而且必须与两个具有float属性的div同级，之间不能存在嵌套关系，否则会产生异常。<br>　　并且将clear这种样式定义为如下即可：.clear{clear:both;}<br>　　此外，为了让高度能自动适应，要在wrapper里面加上overflow:hidden;<br>　　当包含float的box的时候，高度自动适应在IE下无效，这时候应该触发IE的layout私有属性(万恶的IE啊!)用zoom:1;可以做到，这样就达到了兼容。<br>　　例如某一个wrapper如下定义：.colwrapper{<br>　　overflow:hidden;<br>　　zoom:1;<br>　　margin:5px auto;}<br>　　2、margin加倍的问题。<br>　　设置为float的div在ie下设置的margin会加倍。这是一个ie6都存在的bug。<br>　　解决方案是在这个div里面加上display:inline;<br>　　例如：<br>　　&lt;#div id=\”imfloat\”&gt;<br>　　相应的css为<br>　　#IamFloat{<br>　　float:left;<br>　　margin:5px;/<em>IE下理解为10px</em>/<br>　　display:inline;/<em>IE下再理解为5px</em>/}<br>　　3、关于容器的包涵关系<br>　　很多时候，尤其是容器内有平行布局，例如两、三个float的div时，宽度很容易出现问题。在IE中，外层的宽度会被内层更宽的div挤破。一定要用Photoshop或者Firework量取像素级的精度。<br>　　4、关于高度的问题<br>　　如果是动态地添加内容，高度最好不要定义。浏览器可以自动伸缩，然而如果是静态的内容，高度最好定好。(似乎有时候不会自动往下撑开，不知道具体怎么回事)<br>　　5、最狠的手段 - !important;<br>　　如果实在没有办法解决一些细节问题,可以用这个方法.FF对于”!important”会自动优先解析,然而IE则会忽略.如下.tabd1{<br>　　background:url(/res/images/up/tab1.gif) no-repeat 0px 0px !important; /<em>Style for FF</em>/<br>　　background:url(/res/images/up/tab1.gif) no-repeat 1px 0px; /* Style for IE <em>/}<br>　　值得注意的是，一定要将xxxx !important 这句放置在另一句之上，上面已经提过;<br>　　IE7.0出来了，对CSS的支持又有新问题。浏览器多了，网页兼容性更差了，疲于奔命的还是我们 ，为解决IE7.0的兼容问题，找来了下面这篇文章：<br>　　现在我大部分都是用!important来hack，对于ie6和firefox测试可以正常显示，但是ie7对!important可以正确解释，会导致页面没按要求显示!搜索了一下，找到一个针对IE7不错的hack方式就是使用“</em>+html”，现在用IE7浏览一下，应该没有问题了。<br>　　现在写一个CSS可以这样：<br>　　#example { color: #333; } /* Moz <em>/<br>　　* html #example { color: #666; } /</em> IE6 <em>/<br>　　*+html #example { color: #999; } /</em> IE7 <em>/<br>　　那么在firefox下字体颜色显示为#333，IE6下字体颜色显示为#666，IE7下字体颜色显示为#999，他们都互不干扰。<br>　　先温习一下对于IE的box-model的破解<br>　　IE box-model这个臭名昭著的bug存在于IE6/Win以前的每一只版本，这个虫子直到tantak发布了流传最为广泛的那个hack才开始被驯服<br>　　IE5.X/win对box-model的解析是一样的，他们认为width包括了边框(border)和补白(padding)，幸运的是这个情况在IE6中有了好转<br>　　但是IE6在向后兼容的同时也包容了以前的错误，IE6其实有两个核心，在旧的页面前他仍旧表现出对错误的宽容，只有在文档中严格地加上文档类型(DOCTYPE)声明，IE6才能够接受正确的box-model<br>　　所以，tantak的hack必须和正确的DOCTYPE同时包含在文档中才能够正常工作<br>　　Quote<br>　　div.content {<br>　　width:400px; //这个是错误的width，所有浏览器都读到了<br>　　voice-family: “&quot;}&quot;“; //IE5.X/win忽略了”&quot;}&quot;“后的内容<br>　　voice-family:inherit;<br>　　width:300px; //包括IE6/win在内的部分浏览器读到这句，新的数值(300px)覆盖掉了旧的<br>　　}<br>　　html&gt;body .content { //html&gt;body是CSS2的写法<br>　　width:300px; //支持CSS2该写法的浏览器有幸读到了这一句<br>　　}<br>　　现在回到主题，我们经常看到!important和(空格)/*</em>/:组合在一起使用，这个写法有什么奥妙呢?<br>　　看刚才那个写法，我这里可以提供另一种写法也能达到这样的效果<br>　　Quote<br>　　div.content {<br>　　width:300px !important; //这个是正确的width，大部分支持!important标记的浏览器使用这里的数值<br>　　width(空格)/<strong>/:400px; //IE6/win不解析这句，所以IE6/win仍然认为width的值是300px;而IE5.X/win读到这句，新的数值(400px)覆盖掉了旧的，因为!important标记对他们不起作用<br>　　}<br>　　html&gt;body .content { //html&gt;body是CSS2的写法<br>　　width:300px; //支持CSS2该写法的浏览器有幸读到了这一句<br>　　}<br>　　同样，这个方法仍必须依靠正确的文档类型声明才能够正常工作，原因在前面已经说过。<br>　　文档类型声明就像一个开关，打开向后兼容的未来，而错误使用的话，就是一个Pandora box<br>　　ie7.0的面世，尚且不论他是否较之ie6.0进步， ie7和ie6 之间不兼容，毫无疑问又引入了新的痛处，至少在调试的过程中，又多了一道程序以及随之而来的大量不兼容。<br>　　目前，使用ie7.0的用户尚且是少数，使用ie6.0的用户仍然占据很大的比重。然而，大量通过ie6 测试的网页，在ie7.0中都显示不正常。<br>　　据ie7.0官方解说：<br>　　ie7.0在IE6的基础上引入了strict模式，包含了许多有关于层叠样式表(CSS)解析与呈现的改进。这些改进意在提高Internet Explorer解释层叠样式表的一致性，以达到W3C的推荐的标准，同时为开发者提供一个可以依赖的功能集合。<br>　　不管官方的语言是多么动听，也不管ie7.0是不是真的W3C了，浏览器之间太多个性化的东西，太多差异，让我们无可奈何。在ie7.0下设计出的网页，ie6下面显示的几乎是不堪入目。那么，我们在设计网页的时候，在解决好ie6.0与火狐的兼容问题的同时，我们是更多的服从符合W3C一些的 ie7.0，还是对96%的ie6.0妥协?这个问题其实有些多余，我们能做的，或许只有选择中庸，只有尽量调试到各个浏览器都显示正常吧。<br>　　ie7.0与ie6.0的之间不兼容，目前就我知道的有如下几个方面，如有遗漏或者说错了的地方，欢迎在后面补充或者纠正。<br>　　1. ie7,ie6 div+css出现宽度定义不同<br>　　在宽度定义上出现宽度的解释不同,IE7宽度在IE6上要宽一些,,正是这个原因网页可能会出现溢出问题, 还好这个问题可以通过更改数值或者修改一下百分比解决.<br>　　2. ie7.0修复了!important这个bug。<br>　　先前由于ie6.0对!important识别存在bug, 在firefox和IE中的BOX模型解释不一致导致相差2px，大部分网页标准设计师通过这个bug来兼容ie6.0和firefox，即采用：div {margin:30px!important;margin:28px;}。但是ie7.0把这个bug给修复了,所以问题又出现了,怎么兼容 ie.7.0的同时又能兼容ie6.0和firefox?<br>　　3. Box Model的改变<br>　　在IE7中，为了适应CSS2.1 box model修改了溢出的行为。<br>　　4. ie7.0中一些CSS filter将不再可用<br>　　IE7中修改了许多潜在解析错误，这些可能会阻止filter在以前的IE版本中正常工作。如：*HTML filter，下划线filter和/</strong>/注释filter等等。<br>　　5. ie7.0对很多不规范的css不再支持，对js语法要求更严格规范。<br>　　很多在IE6下正常显示的js页面，在IE7下均不能正常显示，并且还没有提示错误。ie7.0对js语法要求更严格规范，只是这个规范似乎并没有说明，也没有明白的告诉大家，他们是怎么“规”怎么“范”的。</p><p>png透明 AlphaImageLoader<br>filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled=bEnabled,sizingMethod=sSize,src=sURL)</p><p>enabled：可选项。布尔值(Boolean)。设置或检索滤镜是否激活。true：默认值。滤镜激活。false：滤镜被禁止。<br>sizingMethod：可选项。字符串(String)。设置或检索滤镜作用的对象的图片在对象容器边界内的显示方式。crop：剪切图片以适应对象尺寸。image：默认值。增大或减小对象的尺寸边界以适应图片的尺寸。scale：缩放图片以适应对象的尺寸边界。<br>src：必选项。字符串(String)。使用绝对或相对 url 地址指定背景图像。假如忽略此参数，滤镜将不会作用。</p><p>firefox不能对innerText支持<br>firefox支持innerHTML但却不支持innerText，它支持textContent来实现innerText，不过默认把多余的空格也保留了。如果不用textContent，如果字符串里面不包含HTML代码也可以用innerHTML代替。</p><p>禁止选取网页内容<br>在IE中一般用js：obj.onselectstart=function(){return false;}<br>而firefox用CSS:-moz-user-select:none</p><p>滤镜的支持(例：透明滤镜)<br>IE:filter：alpha(opacity=10);<br>firefox：-moz-opacity:.10;</p><p>捕获事件<br>IE：obj.setCapture() 、obj.releaseCapture()<br>Firefox：document.addEventListener(”mousemove”,mousemovefunction,true);<br>document.removeEventListener(”mousemove”,mousemovefunction,true);</p><p>获取鼠标位置<br>IE:event.clientX、event.clientY<br>firefox：需要事件函数传递事件对象<br>obj.onmousemove=function(ev){<br>X= ev.pageX;Y=ev.pageY;<br>}</p><p>DIV等元素的边界问题<br>比如：设置一个div的CSS:：{width:100px;height:100px;border:#000000 1px solid;}<br>IE中：div的宽度（包括边框宽度）：100px，div的高度（包括边框宽度）：100px；<br>而firefox：div的宽度（包括边框宽度）：102px，div的高度（包括边框宽度）：102px；</p><p>判断浏览器类型<br>var isIE=document.all ? true : false;<br>我写了一个变量，如果支持document.all语法那么isIE=true，否则isIE=false</p><p>在不同浏览器下的CSS处理<br>一般可以用!important来优先使用css语句（仅firefox支持）<br>比如：{border-width:0px!important;border-width:1px;}<br>在firefox下这个元素是没有边框的，在IE下边框宽度是1px</p><p>document.formName.item(”itemName”) 问题<br>问题说明：IE下，可以使用 document.formName.item(”itemName”) 或 document.formName.elements [“elementName”]；Firefox下，只能使用document.formName.elements[“elementName”]。<br>解决方法：统一使用document.formName.elements[“elementName”]。</p><p>集合类对象问题<br>问题说明：IE下，可以使用()或[]获取集合类对象；Firefox下，只能使用[]获取集合类对象。<br>解决方法：统一使用 [] 获取集合类对象。</p><p>自定义属性问题<br>问题说明：IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用 getAttribute() 获取自定义属性；Firefox下，只能使用 getAttribute() 获取自定义属性。<br>解决方法：统一通过 getAttribute() 获取自定义属性。</p><p>eval(”idName”)问题<br>问题说明：IE下，可以使用 eval(”idName”) 或 getElementById(”idName”) 来取得 id 为 idName 的HTML对象；Firefox下，只能使用 getElementById(”idName”) 来取得 id 为 idName 的HTML对象。<br>解决方法：统一用 getElementById(”idName”) 来取得 id 为 idName 的HTML对象。</p><p>变量名与某HTML对象ID相同的问题<br>问题说明：IE下，HTML对象的ID可以作为 document 的下属对象变量名直接使用，Firefox下则不能；Firefox下，可以使用与HTML对象ID相同的变量名，IE下则不能。<br>解决方法：使用 document.getElementById(”idName”) 代替 document.idName。最好不要取HTML对象ID相同的变量名，以减少错误；在声明变量时，一律加上var关键字，以避免歧义。</p><p>const问题<br>问题说明：Firefox下，可以使用const关键字或var关键字来定义常量；IE下，只能使用var关键字来定义常量。<br>解决方法：统一使用var关键字来定义常量。</p><p>input.type属性问题<br>问题说明：IE下 input.type 属性为只读；但是Firefox下 input.type 属性为读写。<br>解决办法：不修改 input.type 属性。如果必须要修改，可以先隐藏原来的input，然后在同样的位置再插入一个新的input元素。</p><p>window.event问题<br>问题说明：window.event 只能在IE下运行，而不能在Firefox下运行，这是因为Firefox的event只能在事件发生的现场使用。<br>解决方法：在事件发生的函数上加上event参数，在函数体内(假设形参为evt)使用 var myEvent = evt?evt:(window.event?window.event:null)<br>示例：</p><pre><code>&lt;input type=”button” onclick=”doSomething(event)”/&gt;&lt;script language=”javascript”&gt;function doSomething(evt) {var myEvent = evt ? evt: (window.event ? window.event : null)…}</code></pre><p>event.x与event.y问题<br>问题说明：IE下，even对象有x、y属性，但是没有pageX、pageY属性；Firefox下，even对象有pageX、pageY属性，但是没有x、y属性。<br>解决方法：var myX = event.x ? event.x : event.pageX;var myY = event.y ? event.y:event.pageY;<br>如果考虑第8条问题，就改用myEvent代替event即可。</p><p>event.srcElement问题<br>问题说明：IE下，even对象有srcElement属性，但是没有target属性；Firefox下，even对象有target属性，但是没有srcElement属性。<br>解决方法：使用srcObj = event.srcElement ? event.srcElement : event.target;<br>如果考虑第8条问题，就改用myEvent代替event即可。</p><p>window.location.href问题<br>问题说明：IE或者Firefox2.0.x下，可以使用window.location或window.location.href；Firefox1.5.x下，只能使用window.location。<br>解决方法：使用 window.location 来代替 window.location.href。当然也可以考虑使用 location.replace()方法。</p><p>模态和非模态窗口问题<br>问题说明：IE下，可以通过showModalDialog和showModelessDialog打开模态和非模态窗口；Firefox下则不能。<br>解决方法：直接使用 window.open(pageURL,name,parameters) 方式打开新窗口。<br>如果需要将子窗口中的参数传递回父窗口，可以在子窗口中使用window.opener来访问父窗口。如果需要父窗口控制子窗口的话，使用var subWindow = window.open(pageURL,name,parameters);来获得新开的窗口对象。</p><p>frame和iframe问题<br>以下面的frame为例：</p><frame src="”xxx.html”" id="”frameId”" name="”frameName”">(1)访问frame对象IE：使用window.frameId或者window.frameName来访问这个frame对象；Firefox：使用window.frameName来访问这个frame对象；解决方法：统一使用 window.document.getElementById(”frameId”) 来访问这个frame对象；<p>(2)切换frame内容<br>在IE和Firefox中都可以使用window.document.getElementById(”frameId”).src = “xxx.html”或window.frameName.location = “xxx.html”来切换frame的内容；<br>如果需要将frame中的参数传回父窗口，可以在frame中使用parent关键字来访问父窗口。</p><p>body载入问题<br>问题说明：Firefox的body对象在body标签没有被浏览器完全读入之前就存在；而IE的body对象则必须在body标签被浏览器完全读入之后才存在。<br>[注] 这个问题尚未实际验证，待验证后再来修改。<br>[注] 经验证，IE6、Opera9以及FireFox2中不存在上述问题，单纯的JS脚本可以访问在脚本之前已经载入的所有对象和元素，即使这个元素还没有载入完成。</p><p>事件委托方法<br>问题说明：IE下，使用 document.body.onload = inject;其中function inject()在这之前已被实现；在Firefox下，使用 document.body.onload = inject();<br>解决方法：统一使用 document.body.onload=new Function(”inject()”);或者 document.body.onload = function(){/* 这里是代码 */}<br>[注意] Function和function的区别</p><p>访问的父元素的区别<br>问题说明：在IE下，使用 obj.parentElement 或 obj.parentNode 访问obj的父结点；在firefox下，使用 obj.parentNode 访问obj的父结点。<br>解决方法：因为firefox与IE都支持DOM，因此统一使用obj.parentNode 来访问obj的父结点。</p><p>cursor:hand VS cursor:pointer<br>问题说明：firefox不支持hand，但ie支持pointer ，两者都是手形指示。<br>解决方法：统一使用pointer。</p><p>innerText的问题<br>问题说明：innerText在IE中能正常工作，但是innerText在FireFox中却不行。<br>解决方法：在非IE浏览器中使用textContent代替innerText。<br>示例：<br>if(navigator.appName.indexOf(”Explorer”) &gt;-1){<br>document.getElementById(”element”).innerText = “my text”;<br>}else{<br>document.getElementById(”element”).textContent = “my text”;<br>}<br>[注] innerHTML 同时被ie、firefox等浏览器支持，其他的，如outerHTML等只被ie支持，最好不用。</p><p>对象宽高赋值问题<br>问题说明：FireFox中类似 obj.style.height = imgObj.height 的语句无效。<br>解决方法：统一使用 obj.style.height = imgObj.height + “px”;</p><p>Table操作问题<br>问题说明：ie、firefox以及其它浏览器对于 table 标签的操作都各不相同，在ie中不允许对table和tr的innerHTML赋值，使用js增加一个tr时，使用appendChild方法也不管用。<br>解决方法：<br>//向table追加一个空行：<br>var row = otable.insertRow(-1);<br>var cell = document.createElement(”td”);<br>cell.innerHTML = “”;<br>cell.className = “XXXX”;<br>row.appendChild(cell);<br>[注] 由于俺很少使用JS直接操作表格，这个问题没有遇见过。建议使用JS框架集来操作table，如JQuery。</p><p>ul和ol列表缩进问题<br>消除ul、ol等列表的缩进时，样式应写成：list-style:none;margin:0px;padding:0px;<br>其中margin属性对IE有效，padding属性对FireFox有效。← 此句表述有误，详细见↓<br>[注] 这个问题尚未实际验证，待验证后再来修改。<br>[注] 经验证，在IE中，设置margin:0px可以去除列表的上下左右缩进、空白以及列表编号或圆点，设置padding对样式没有影响；在Firefox中，设置margin:0px仅仅可以去除上下的空白，设置padding:0px后仅仅可以去掉左右缩进，还必须设置list-style:none才能去除列表编号或圆点。也就是说，在IE中仅仅设置margin:0px即可达到最终效果，而在Firefox中必须同时设置margin:0px、padding:0px以及list-style:none三项才能达到最终效果。</p><p>CSS透明问题<br>IE：filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=60)。<br>FF：opacity:0.6。<br>[注] 最好两个都写，并将opacity属性放在下面。</p><p>CSS圆角问题<br>IE：ie7以下版本不支持圆角。<br>FF：-moz-border-radius:4px，或者-moz-border-radius-topleft:4px;-moz-border- radius-topright:4px;-moz-border-radius-bottomleft:4px;-moz-border-radius- bottomright:4px;。<br>[注] 圆角问题是CSS中的经典问题，建议使用JQuery框架集来设置圆角，让这些复杂的问题留给别人去想吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IE和火狐的css兼容性问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>你需要了解JS框架</title>
    <link href="http://yoursite.com/post/2017-06-03-20170603/"/>
    <id>http://yoursite.com/post/2017-06-03-20170603/</id>
    <published>2017-06-03T02:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.097Z</updated>
    
    <content type="html"><![CDATA[<p>你需要了解JS框架</p><a id="more"></a><p>excanvas.js/Chart.js/cubism.js/d3.js/dc.js/dx.chartjs.js/echarts.js/flot.js</p><pre><code>用途：构建数据统计图表，兼容多浏览器</code></pre><p>jquery.tagcanvas.js</p><pre><code>用途：构建tag云下载地址：http://www.goat1000.com/tagcanvas.php</code></pre><p>jquery.fullPage.js</p><pre><code>用途：网站整屏轮番 下载地址：http://www.jq22.com/jquery-info1124 案例：http://www.dowebok.com/77.html</code></pre><p>analytics.js/ga.js</p><pre><code>用途：谷歌广告分析</code></pre><p>edge.js   </p><pre><code>用途：js和.net相互调用。案例：http://www.cnblogs.com/shanyou/p/3325249.html</code></pre><p>bower.js</p><pre><code>用途：包管理器案例：http://blog.csdn.net/chszs/article/details/8907577</code></pre><p>gulp.js</p><pre><code>用途：js/css压缩案例：http://www.cnblogs.com/code/articles/4103070.html</code></pre><p>jshint.js</p><pre><code>用途：js编写格式验证工具</code></pre><p>alertify.js/simplemodal.js</p><pre><code>用途：构建提示框</code></pre><p>amd.loader.js/Require.js/Sea.js/Head.js</p><pre><code>用途：按需动态加载js文件</code></pre><p>Behave.js/epiceditor.js</p><pre><code>用途：编辑器，使textarea具有IDE编辑能力</code></pre><p>bonsai.js/caman.js/canvas.js/fabric.js/paper.js/raphael.js/sigma.js</p><pre><code>用途：图形处理</code></pre><p>bucky.js</p><pre><code>用途：前端测试自动化工具+页面性能分析工具</code></pre><p>chosen.js</p><pre><code>用途：选择框插件</code></pre><p>classlist.js</p><pre><code>用途：操作DOM</code></pre><p>Cookies.js</p><pre><code>用途：操作Cookie</code></pre><p>crossfilter.js/Lodash.js/Underscore.js</p><pre><code>用途：用来过滤json数据，类似sql</code></pre><p>cryptico.js</p><pre><code>用途：数据加密</code></pre><p>curl.js</p><pre><code>用途：使图片产生卷曲效果</code></pre><p>date.format.js</p><pre><code>用途：日期格式化</code></pre><p>dojo.js</p><pre><code>用途：DHTML开源包 ，有统一的UI控件</code></pre><p>draggabilly.js</p><pre><code>用途：实现拖拽功能</code></pre><p>dropzone.js</p><pre><code>用途：拖拽上传</code></pre><p>easyXDM.js</p><pre><code>用途：js跨域访问</code></pre><p>ember-data.js</p><pre><code>用途：使用一个模型库来管理查询、更改和将更改保存回服务器，将会大大的简化代码，同时也能提升应用的健壮性和性能，这便产生了Ember-Data数据模型。</code></pre><p>equalize.js</p><pre><code>用途：内容对其插件 例如：百度关键词标签</code></pre><p>Faker.js</p><pre><code>用途：虚假数据生成器</code></pre><p>fancybox.js/layer.js</p><pre><code>用途：弹出层展示插件</code></pre><p>fastclick.js</p><pre><code>用途：触摸UI上的消除点击延迟js库</code></pre><p>favico.js</p><pre><code>用途：图片上实现动画角标</code></pre><p>FitText.js</p><pre><code>用途：FitText.js是一款经典的jQuery响应式标题文字插件。FitText.js可以将标题文字自适应容器的大小，缩放容器时标题字体大小随之改变。FitText.js可用于桌面设备、手提电脑、平板电脑和手机等众多设备，非常强大。</code></pre><p>floatlabels.js</p><p>   用途：jquery浮动标签floatlabels.js在输入文本框键入任何行动中看到漂浮的标签。它对一个输入字段占位符值移动用户交互，并键入文本上方显示，允许用户自定义标签样式、效果。</p><p>lightGallery.js/Lighterbox.js/Rebox.js/LiteBox.js/Image Lightbox.js/TosRus.js/Fluidbox.js/Swipebox.js/iLightbox.js/VenoBox.js/Magnific Popup.js/Featherlight.js/flipLightBox.js/Colorbox.js/Lightbox_me.js/Shadowbox.js/Superbox.js/Lightview.js</p><p>用途：灯箱插件</p><p>frozenui.css</p><p>用途：移动端前端框架</p><p>galleriffic.js</p><p>用途：图片相册展示</p><p>garlic.js</p><p>用途：可以让你自动的持久化表单中的数据到本地，直到表单被提交。这样用户就不用担心因为误操作导致表单输入的数据丢失。</p><p>AudioPlayer.js/GrindPlayer.js/GrindPlayerCN.js/muplayer.js</p><p>用途：播放器</p><p>modernizr.js</p><p>用途：传统浏览器目前不会被完全取代，令你难以将最新的 CSS3 或 HTML5 功能嵌入你的网站。 Modernizr 正是为解决这一难题应运而生，作为一个开源的 JavaScript 库，Modernizr 检测浏览器对 CSS3 或 HTML5 功能支持情况。 Modernizr 并非试图添加老版本浏览器不支持的功能，而是令你通过创建可选风格配置修改页面设计。 它也可以通过加载定制的脚本来模拟老版本浏览器不支持的功能。</p><p>hallo.js</p><p>用途：一款所见即所得的web编辑器</p><p>Hammer.js/quo.js/swipe.js</p><p>用途：hammer.js是一款开源的移动端脚本框架，他可以完美的实现在移端开发的大多数事件，如：点击、滑动、拖动、多点触控等事件。</p><p>handsontable.js</p><p>用途：web版excel</p><p>Headroom.js</p><p>用途：一个轻量级、高性能的JS小工具（不依赖任何工具库！），它能在页面滚动时做出响应。此页面顶部的导航条就是一个鲜活的案例，当页面向下滚动时，导航条消失，当页面向上滚动时，导航条就出现了。</p><p>history.js</p><p>用途：无刷新就可改变浏览器栏地址的插件（不依赖jquery）</p><p>holder.js</p><p>用途：完全在客户端上呈现图像占位符。在线和离线工作，并提供一个可链接的API的风格和轻松的创建占位符。在线和离线工作，并提供一个可链接的API的风格和轻松的创建占位符。</p><p>Pikaday.js</p><p>用途：这是一个令人耳目一新的JavaScript日期选择器。轻量轻（压缩和gzip后小于5KB），没有依赖其它JS框架(但能够与Moment.js一起使用)，模块化的CSS类，方便</p><p>Mailcheck.js</p><p>用途：个Javascript库和jQuery插件，用于检测email地址的域名。当域名不正确时，会提供相应的建议。</p><p>Lenticular.js</p><p>用途：一个jQuery插件用于创建图片动画，可响应倾斜或鼠标事件。这个插件主要用于移动浏览器（倾斜倾斜设备），但也可以用于桌面浏览器（鼠标控制）。</p><p>Jarallax.js/skrollr.js</p><p>用途：页面实现视差滚动</p><p>jsPDF.js</p><p>用途：JS实现生成pdf</p><p>oriDomi.js<br>用途：使dom元素实现折叠效果</p><p>Mousetrap.js/Keymaster.js<br>用途：用于创建和管理键盘快捷键。这个JS是一个单独的JS包，非常小只有1.6kb。支持大部分浏览器包括IE6。它可以实现单键，组合键或一个序列组合键。此外还可以监听keypress, keydown 或 keyup事件,然后据此决定触发哪个函数。</p><p>humane.js</p><p>用途：一个简单、现代、无需其他框架支持的网页上的提醒库，使用 CSS 进行定制，支持手机使用。</p><p>imagesloaded.js</p><p>用途：imagesLoaded是一款用于检测页面中的图片是否被加载的js插件。imagesLoaded是非常有用的插件，当你的页面中某幅图片没有被加载时，默认会显示一个红叉或图片alt文本，imagesLoaded可以将未加载的图片替换为你设置的图片。</p><p>instantclick.js</p><p>用途：让你的页面提前加载200ms</p><p>intro.js</p><p>用途：js引导插件。 例如：你的网站你增加了某个功能，那么可以通过这个插件引导改动点。</p><p>jquery-scrollUp.js</p><p>用途： ScrollUp是一个轻量级的Jquery插件，它创建一个可自定义的“滚动到顶部”的按钮，在任意的网站中进行简单的调用就能达到效果</p><p>jquery.infinitescroll.js</p><p>用途：它是基于Jquery的，另外还要明白无限滚动的概念：无限滚动的实现原理就是当你在网页上的滚动条滚动到离网页底部一定长度的时候，触发某ajax函数（infinite-scroll内已经封装好）,往后台加载文件或者数据，又或者从外部引入静态html形式文件。</p><p>jquery.url.js</p><p>用途：很方便地对URL进行操作。</p><p>justgage.js</p><p>用途：JS仪表盘。</p><p>Moment.js</p><p>用途：日期格式化，支持多国语言</p><p>nprogress.js</p><p>用途：进度条</p><p>Odometer.js</p><p>用途：计时器效果</p><p>opentip.js/pnotify.js/qtip2.js</p><p>用途：示框插件，支持多种样式风格。</p><p>owl-carousel.js/sequence.js/slides.js/reveal.js</p><p>用途：幻灯片插件。</p><p>pace.js<br>用途：页面加载进度条，支持ajax.</p><p>parallax.js</p><p>用途：简单，轻量级的的视差引擎，智能设备的方向作出反应。凡没有陀螺仪或运动检测硬件是可用的，光标的位置来代替。</p><p>piecon.js/tinycon.js</p><p>用途：能够动态生成饼图（Pie Charts）模式的网页图标，同时可以显示加载的百分比.</p><p>recorder.js</p><p>用途：录音框架。</p><p>select2.js/selectize.js</p><p>用途：强大dropdown 插件，支持tag/分类。</p><p>shine.js</p><p>用途：文字阴影，支持动画。</p><p>swfobject.js</p><p>用途：只需要包含 swfobject.js这个js文件，然后在DOM中插入一些简单的JS代码，就能嵌入Flash媒体资源了</p><p>timeline.js</p><p>用途：超酷全屏时间轴幻灯片，时间轴可放大缩小，需要在服务器环境下运行，可用本地服务器环境测试。</p><p>ueditor.js/FCK</p><p>用途：百度网页内容编辑器。</p><p>jquery.lazyload.js/unveil.js</p><p>用途：图片延时加载。</p><p>video.js</p><p>用途：视频播放器，支持html5以及flash。</p><p>wow.js</p><p>用途：有的页面在向下滚动的时候，有些元素会产生细小的动画效果。虽然动画比较小，但却能吸引你的注意。</p><p>zeroclipboard.js</p><p>用途：复制到剪贴板，自制粘贴。</p><p>Rotate.js </p><p>用途：旋转插件 图片360旋转</p><p>注：该文由fang_beny原创，转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你需要了解JS框架&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>H5 调用摄像头</title>
    <link href="http://yoursite.com/post/2017-05-26-20170526/"/>
    <id>http://yoursite.com/post/2017-05-26-20170526/</id>
    <published>2017-05-26T02:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.080Z</updated>
    
    <content type="html"><![CDATA[<p>H5 调用摄像头</p><a id="more"></a><p>WebRTC（Web Real-Time Communication，网页实时通信），是一个支持网页浏览器进行实时语音对话或视频对话的API。 </p><p>1、getUserMedia<br>要播放摄像头的影像，首先需要一个video标签：</p><pre><code>&lt;video id=&quot;video&quot;&gt;&lt;/video&gt;</code></pre><p>获取摄像头影像主要是通过navigator.getUserMedia这个接口，这个接口的支持情况已经逐渐变好了：点这里</p><p>不过，使用的时候还是要加上前缀的，兼容代码：</p><pre><code>navigator.getUserMedia =  navigator.getUserMedia                         || navigator.webkitGetUserMedia                         || navigator.mozGetUserMedia;语法： navigator.getUserMedia(constraints, successCallback, errorCallback);　参数说明：</code></pre><p>constraints：Object类型，指定了请求使用媒体的类型<br>succeCallback：启用成功时的函数，它传入一个参数，为视频流对象，可以进一步通过window.URL.createObjectURL()接口把视频流转换为对象URL。<br>errorCallback：启动失败时的函数。它传入一个参数，为错误对象（chrome）或错误信息字符串（Firefox），可能值：<br>　PERMISSION_DENIED：用户拒绝提供信息。</p><p>   NOT_SUPPORTED_ERROR：浏览器不支持硬件设备。</p><p>   MANDATORY_UNSATISFIED_ERROR：无法发现指定的硬件设备。</p><p>　例如：要启用视频设备（摄像头），可这样：</p><pre><code>navigator.getUserMedia({    video: true });</code></pre><p>　如果要同时启用视频设备和音频设备，可这样：</p><pre><code>navigator.getUserMedia({    video: true,    audio: true });</code></pre><p>2、 获取摄像头</p><pre><code>var URL = window.URL || window.webkitURL; // 获取到window.URL对象   navigator.getUserMedia({    video: true  }, function(stream) {    video.src = URL.createObjectURL(stream);// 将获取到的视频流对象转换为地址    video.play();     }, function(error) {    console.log(error.name || error);  });</code></pre><p>　　<br>3 截图<br>除了实时直播外，我们还可以做实时截图效果，这时我们需要利用<canvas>元素来画图，代码如下：</canvas></p><pre><code>&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;var canvas = document.getElementById(&apos;canvas&apos;);  var ctx = canvas.getContext(&apos;2d&apos;);  var width = video.width;  var height = video.height;  canvas.width = width;  canvas.height = height;ctx.drawImage(video, 0, 0, width, height);</code></pre><p>4、 保存图片<br>当然，截图后，你也可以保存下来：<br>　　<br>    <a download="snap.png" id="download">下载图片</a>  </p><pre><code>var url = canvas.toDataURL(&apos;image/png&apos;); document.getElementById(&apos;download&apos;).src = url;</code></pre><p>5、 完整实例<br>实例代码（由于安全限制问题，请将代码复制到本地运行）：</p><pre><code>&lt;!DOCTYPE html&gt; &lt;html&gt;    &lt;head&gt;      &lt;meta charset=&quot;UTF-8&quot;&gt;      &lt;title&gt;&lt;/title&gt;      &lt;style&gt;      #canvas,#video {        float: left;          margin-right: 10px;          background: #fff;        }            .box {          overflow: hidden;          margin-bottom: 10px;        }    &lt;/style&gt;  &lt;/head&gt;    &lt;body&gt;      &lt;div class=&quot;box&quot;&gt;      &lt;video id=&quot;video&quot; width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/video&gt;      &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;    &lt;/div&gt;    &lt;button id=&quot;live&quot;&gt;直播&lt;/button&gt;    &lt;button id=&quot;snap&quot;&gt;截图&lt;/button&gt;    &lt;script&gt;        var video = document.getElementById(&apos;video&apos;);      var canvas = document.getElementById(&apos;canvas&apos;);        var ctx = canvas.getContext(&apos;2d&apos;);        var width = video.width;        var height = video.height;        canvas.width = width;        canvas.height = height;         function liveVideo(){          var URL = window.URL || window.webkitURL;   // 获取到window.URL对象        navigator.getUserMedia({            video: true          }, function(stream){            video.src = URL.createObjectURL(stream);   // 将获取到的视频流对象转换为地址          video.play();   // 播放          //点击截图               document.getElementById(&quot;snap&quot;).addEventListener(&apos;click&apos;, function() {              ctx.drawImage(video, 0, 0, width, height);              var url = canvas.toDataURL(&apos;image/png&apos;);              document.getElementById(&apos;download&apos;).href = url;            });        }, function(error){            console.log(error.name || error);          });        }        document.getElementById(&quot;live&quot;).addEventListener(&apos;click&apos;,function(){          liveVideo();        });        &lt;/script&gt;    &lt;/body&gt; &lt;/html&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;H5 调用摄像头&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>IE6兼容性问题及解决办法汇总</title>
    <link href="http://yoursite.com/post/2017-05-21-20170521/"/>
    <id>http://yoursite.com/post/2017-05-21-20170521/</id>
    <published>2017-05-21T02:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.055Z</updated>
    
    <content type="html"><![CDATA[<p> IE6兼容性问题及解决办法汇总</p><a id="more"></a><p>1、IE6怪异解析之padding与border算入宽高<br>原因：未加文档声明造成非盒模型解析<br>解决方法：加入文档声明<!doctype html> </p><p>2、IE6在块元素、左右浮动、设定marin时造成margin双倍（双边距）<br>解决方法：display:inline </p><p>3、以下三种其实是同一种bug，其实也不算是个bug，举个例子：父标签高度20，子标签11，垂直居中，20-11=9，9要分给文字的上面与下面，怎么分？IE6就会与其它的不同，所以，尽量避免。<br>1）字体大小为奇数之边框高度少1px<br>解决方法：字体大小设置为偶数或line-height为偶数<br>2）line-height，文本垂直居中差1px<br>解决方法：padding-top代替line-height居中，或line-height加1或减1<br>3）与父标签的宽度的奇偶不同的居中造成1px的偏离<br>解决方法：如果父标签是奇数宽度，则子标签也用奇数宽度;如果是父标签偶数宽度，则子标签也用偶数宽度 </p><p>4、内部盒模型超出父级时，父级被撑大<br>解决方法：父标签使用overflow:hidden </p><p>5、line-height默认行高bug<br>解决方法：line-height设值 </p><p>6、行标签之间会有一小段空白<br>解决方法：float或结构并排(可读性差，不建议) </p><p>7、标签高度无法小于19px<br>解决方法：overflow: hidden; </p><p>8、左浮元素margin-bottom失效<br>解决方法：显示设置高度 or 父标签设置_padding-bottom代替子标签的margin-bottom or 再放个标签让父标签浮动，子标签<br>margin- bottom，即(margin-bottom与float不同时作用于一个标签) </p><p>9、img于块元素中，底边多出空白<br>解决方法：父级设置overflow: hidden; 或 img { display: block; } 或 _margin: -5px; </p><p>10、li之间会有间距 </p><p>解决方法：float: left; </p><p>11、块元素中有文字及右浮动的行元素，行元素换行<br>解决方法：将行元素置于块元素内的文字前 </p><p>12、position下的left，bottom错位<br>解决方法：为父级(relative层)设置宽高或添加*zoom:1 </p><p>13、子级中有设置position，则父级overflow失效<br>解决方法：为父级设置position:relative</p><p>解决IE6兼容性问题的方法：</p><p>1、终极方法：条件注释 </p><!--[if lte IE 6]> 这段文字仅显示在 IE6及IE6以下版本。 <![endif]--> <!--[if gte IE 6]> 这段文字仅显示在 IE6及IE6以上版本。 <![endif]--> <!--[if gt IE 6]> 这段文字仅显示在 IE6以上版本（不包含IE6）。 <![endif]--> <!--[if IE 5.5]> 这段文字仅显示在 IE5.5。 <![endif]--> <!--在 IE6及IE6以下版本中加载css--> <!--[if lte IE 6]> <link type="text/css" rel="stylesheet" href="css/ie6.css" mce_href="css/ie6.css" /><![endif]--> <p>缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p><p>2、CSS选择器区分<br>IE6不支持子选择器；先针对IE6使用常规申明CSS选择器，然后再用子选择器针对IE7+及其他浏览器</p><pre><code>&lt;span style=&quot;font-family:Microsoft YaHei;font-size:14px;&quot;&gt;   /* IE6 专用 */   .content {color:red;}   /* 其他浏览器 */   div&gt;p .content {color:blue;}  &lt;/span&gt;  </code></pre><p>3、PNG半透明图片的问题<br>虽然可以通过JS等方式解决，但依然存在载入速度等问题，所以，这个在设计上能避免还是尽量避免为好。以达到网站最大优化。<br>4、IE6下的圆角<br>IE6不支持CSS3的圆角属性，性价比最高的解决方法就是用图片圆角来替代，或者放弃IE6的圆角。 </p><p>5、IE6背景闪烁<br>如果你给链接、按钮用CSS sprites作为背景，你可能会发现在IE6下会有背景图闪烁的现象。造成这个的原因是由于IE6没有将背景图缓存，每次触发hover的时候都会重新加载，可以用JavaScript设置IE6缓存这些图片： </p><pre><code>&lt;span style=&quot;font-family:Microsoft YaHei;font-size:14px;&quot;&gt;   document.execCommand(&quot;BackgroundImageCache&quot;,false,true);   &lt;/span&gt;  </code></pre><p>6、最小高度<br>IE6 不支持min-height属性，但它却认为height就是最小高度。解决方法：使用ie6不支持但其余浏览器支持的属性!important。 </p><pre><code>&lt;span style=&quot;font-family:Microsoft YaHei;font-size:14px;&quot;&gt;   #container {min-height:200px; height:auto !important; height:200px;}   &lt;/span&gt;  </code></pre><p>7、最大高度</p><pre><code>&lt;span style=&quot;font-family:Microsoft YaHei;font-size:14px;&quot;&gt;   //直接使用ID来改变元素的最大高度   var container = document.getElementById(&apos;container&apos;);   container.style.height = (container.scrollHeight &gt; 199) ? &quot;200px&quot; : &quot;auto&quot;;   //写成函数来运行   function setMaxHeight(elementId, height){   var container = document.getElementById(elementId);   container.style.height = (container.scrollHeight &gt; (height - 1)) ? height + &quot;px&quot; : &quot;auto&quot;;   }   //函数示例   setMaxHeight(&apos;container1&apos;, 200);   setMaxHeight(&apos;container2&apos;, 500);   &lt;/span&gt;  </code></pre><p>8、100% 高度<br>在IE6下，如果要给元素定义100%高度，必须要明确定义它的父级元素的高度，如果你需要给元素定义满屏的高度，就得先给html和body定义height:100%;。 </p><p>9、最小宽度<br>同max-height和max-width一样，IE6也不支持min-width。</p><pre><code>&lt;span style=&quot;font-family:Microsoft YaHei;font-size:14px;&quot;&gt;   //直接使用ID来改变元素的最小宽度   var container = document.getElementById(&apos;container&apos;);   container.style.width = (container.clientWidth &lt; width) ? &quot;500px&quot; : &quot;auto&quot;;   //写成函数来运行   function setMinWidth(elementId, width){   var container = document.getElementById(elementId);   container.style.width = (container.clientWidth &lt; width) ? width + &quot;px&quot; : &quot;auto&quot;;   }   //函数示例   setMinWidth(&apos;container1&apos;, 200);   setMinWidth(&apos;container2&apos;, 500);   &lt;/span&gt;  </code></pre><p>10、最大宽度</p><pre><code>&lt;span style=&quot;font-family:Microsoft YaHei;font-size:14px;&quot;&gt;   //直接使用ID来改变元素的最大宽度   var container = document.getElementById(elementId);   container.style.width = (container.clientWidth &gt; (width - 1)) ? width + &quot;px&quot; : &quot;auto&quot;;   //写成函数来运行   function setMaxWidth(elementId, width){   var container = document.getElementById(elementId);   container.style.width = (container.clientWidth &gt; (width - 1)) ? width + &quot;px&quot; : &quot;auto&quot;;   }   //函数示例   setMaxWidth(&apos;container1&apos;, 200);   setMaxWidth(&apos;container2&apos;, 500);   &lt;/span&gt; </code></pre><p>11、双边距Bug<br>当元素浮动时，IE6会错误的把浮动方向的margin值双倍计算。个人觉得较好解决方法是避免float和margin同时使用。 </p><p>12、清除浮动<br>如果你想用div(或其他容器)包裹一个浮动的元素，你会发现必须给div(容器)定义明确的height、width、overflow之中一个属性（除了auto值）才能将浮动元素严实地包裹。 </p><pre><code>&lt;span style=&quot;font-family:Microsoft YaHei;font-size:14px;&quot;&gt;   #container {border:1px solid #333; overflow:auto; height:100%;}   #floated1 {float:left; height:300px; width:200px; background:#00F;}   #floated2 {float:right; height:400px; width:200px; background:#F0F;}   更多：http://www.twinsenliang.net/skill/20090413.html   &lt;/span&gt;  </code></pre><p>13、浮动层错位<br>当内容超出外包容器定义的宽度时，在IE6中容器会忽视定义的width值，宽度会错误地随内容宽度增长而增长。<br>浮动层错位问题在IE6下没有真正让人满意的解决方法，虽然可以使用overflow:hidden;或overflow:scroll;来修正， 但hidden容易导致其他一些问题，scroll会破坏设计；JavaScript也没法很好地解决这个问题。所以建议是一定要在布局上避免这个问题发 生，使用一个固定的布局或者控制好内容的宽度（给内层加width）。 </p><p>14、躲猫猫bug<br>在IE6和IE7下，躲猫猫bug是一个非常恼人的问题。一个撑破了容器的浮动元素，如果在他之后有不浮动的内容，并且有一些定义了:hover的链接，当鼠标移到那些链接上时，在IE6下就会触发躲猫猫。<br>解决方法很简单：<br>1.在（那个未浮动的）内容之后添加一个<span style="clear: both;"> </span><br>2.触发包含了这些链接的容器的hasLayout，一个简单的方法就是给其定义height:1%; </p><p>15、绝对定位元素的1像素间距bug<br>IE6下的这个错误是由于进位处理误差造成（IE7已修复），当绝对定位元素的父元素高或宽为奇数时，bottom和right会产生错误。唯一的解决办法就是给父元素定义明确的高宽值，但对于液态布局没有完美的解决方法。 </p><p>16、3像素间距bug<br>在IE6中，当文本(或无浮动元素)跟在一个浮动的元素之后，文本和这个浮动元素之间会多出3像素的间隔。<br>给浮动层添加 display:inline 和 -3px 负值margin<br>给中间的内容层定义 margin-right 以纠正-3px </p><p>17、IE下z-index的bug<br>在IE浏览器中，定位元素的z-index层级是相对于各自的父级容器，所以会导致z-index出现错误的表现。解决方法是给其父级元素定义z-index，有些情况下还需要定义position:relative。 </p><p>18、Overflow Bug<br>在IE6/7中，overflow无法正确的隐藏有相对定位position:relative;的子元素。解决方法就是给外包容器.wrap加上position:relative;。 </p><p>19、横向列表宽度bug<br>如果你使用float:left;把<li>横向摆列，并且</li><li>内包含的<a>（或其他）触发了 hasLayout，在IE6下就会有错误的表现。解决方法很简单，只需要给<a>定义同样的float:left;即可。 </a></a></li></p><p>20、列表阶梯bug<br>列表阶梯bug通常会在给<li>的子元素<a>使用float:left;时触发，我们本意是要做一个横向的列表(通常 是导航栏)，但IE却可能呈现出垂直的或者阶梯状。解决办法就是给<li>定义float:left;而非子元素<a>，或者 给<li>定义display:inline;也可以解决。 </li></a></li></a></li></p><p>21、垂直列表间隙bug<br>当我们使用<li> 包含一个块级子元素时，IE6(IE7也有可能)会错误地给每条列表元素（</li><li>）之间添加空隙。<br>解决方法：把<a>flaot并且清除float来解决这个问题；另外一个办法就是触发<a>的hasLayout（如定 义高宽、使用zoom:1;）；也可以给<li> 定义display:inline;来解决此问题；另外还有一个极有趣的方法，给包含的文本末尾添加一个空格。 </li></a></a></li></p><p>22、IE6中的:hover<br>在IE6中，除了(需要有href属性)才能触发:hover行为，这妨碍了我们实现许多鼠标触碰效果，但还是有一些法子是可以解决它的。最好是不要用:hover来实现重要的功能，仅仅只用它来强化效果。 </p><p>23、IE6调整窗口大小的 Bug<br>当把body居中放置，改变IE浏览器大小的时候，任何在body里面的相对定位元素都会固定不动了。解决办法：给body定义position:relative;就行了。 </p><p>24、文本重复Bug<br>在IE6中，一些隐藏的元素（如注释、display:none;的元素）被包含在一个浮动元素里，就有可能引发文本重复bug。解决办法：给浮动元素添加display:inline;。 </p><p>再补充：</p><p>10要点解决IE6兼容性问题</p><p>1、使用声明</p><p>你必须经常在html网页头部放置一个声明，推荐使用严格的标准。例如</p><pre><code>&lt;!DOCTYPEHTMLPUBLIC“-//W3C//DTDHTML4.01//EN”   &quot;http://www.w3.org/TR/html4/strict.dtd”&gt; or,forXHTML:  &lt;!DOCTYPEhtmlPUBLIC“-//W3C//DTDXHTML1.0Strict//EN”   &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd”&gt; </code></pre><p>最后你需要是IE6进入兼容模式，这已经足够兼容了。</p><p>2、使用position:relative</p><p>IE6兼容性问题解决方案二：使用position:relative。设置一个标签position:relative可以解决很多问题，特别是曾经有过看不见的经历或者奇怪布局的框架。明显的，你需要小心，绝对位置放置的子元素是否都参照找到新位置。</p><p>3、为浮动元素使用display:inline</p><p>浮动元素会有一个著名的IE6双边距marginbug。假如你设置了左边距5px但实际上得到了10px左边距。display:inline可以解决这个问题，尽管它不是必需的，但是css仍然有效。</p><p>4、设置元素启动hasLayout</p><p>大部分IE6（IE7）的渲染问题都可以通过起来元素的hasLayout属性来兼容。这是IE内置的设定，确定一个内容块相对其它内容块是有界限和位置的。当你需要设置一个行内元素例如一个连接变成块状元素或者是透明效果，设置hasLayout也是必须的。</p><p>5、修复重复字符的bug</p><p>复杂的布局会触发一个bug：浮动对象的最后字符会出现在已经清除浮动的元素后面。这里有几种解决的办法，部分是理想的，并且一些测试和出错是必须的。<br>a、确保浮动元素都使用：display:inline；<br>b、最后一个浮动元素使用margin-right:-3px;<br>c、在浮动对象最后一个元素后使用一个条件注释。例如&lt;!—&gt;这里输入注释…&lt;![endif]<br>d、在容器内的最后使用一个div空标签（它也必须设置90%宽度甚至更小）</p><p>6、使用a标签完成可点击和hover原理</p><p>IE6只支持a标签的css定义hover效果<br>你可以使用它去控制JavaScript启动的widgets，使得他们仍然保持键盘操作。这里有个二择一的问题，但是a标签是所有解决方案中最可靠的。</p><p>7、使用!important，或是高级选择符替代IE特定代码</p><p>IE6兼容性问题解决方案七;：使用!important。在外置的css文件里，放弃凭借传统的hacks和条件判断，使用有效的css代码去针对IE6仍然是有可能的。例如：最小高度可以使用一下定义。（在IE6中无法识别！important优先级别标签，所以一般用法为：{margin-top:20px !important; margin-top:0px;}）</p><p>#element{  min-height:20em;  height:auto!important;  height:20em;  } </p><p>9、早点和经常测试</p><p>在你的网站和应用程序完成之前，不要放弃IE6的测试。问题将会更加严重并且需要很长时间去修复。如果你的网站可以运行于firefox和IE6，它将差不多肯定可以在其它浏览器下运行。</p><p>10、重构你的代码</p><p>IE6兼容性问题解决方案十：重构代码。经常的，修复会比重新考虑布局问题更加花费时间。Html细微的修改和更加简单的css经常是最有效的。这意味着你要放弃完美的合法的代码，但是将会更少的问题出现，并且你知道怎样处理将要出现的情况。</p><p> #element[id]{  height:auto;  } </p><p>注意事项</p><p><em>margin-top:10px; 属性前加“</em>”,这个只有IE6/IE7才能识别。</p><p>例如:</p><p>div{    margin-top:10px; *margin-top:0px;}</p><p>“*”或“+”或“_” + 属性，这个只有IE6和IE7才支持此种标签。</p><p>*margin-top:10px \9; 属性值的后面加“\9”,这个只有IE才能识别。以上两种方法结合起来可以区分IE6、IE7、IE8+、非IE内核浏览器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; IE6兼容性问题及解决办法汇总&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
</feed>
