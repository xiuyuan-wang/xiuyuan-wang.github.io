<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>倘若有一天</title>
  
  <subtitle>深夜狂奔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-12T01:58:35.673Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>笑余笙</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法 - 排序</title>
    <link href="http://yoursite.com/post/2019-05-10-20190510/"/>
    <id>http://yoursite.com/post/2019-05-10-20190510/</id>
    <published>2019-05-10T09:25:23.000Z</published>
    <updated>2020-03-12T01:58:35.673Z</updated>
    
    <content type="html"><![CDATA[<p>排序</p><a id="more"></a><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度。</p><p>没有循环语句，记作O(1)，也称为常数阶。只有一重循环，则算法的基本操作的执行频度与问题规模n呈线性增大关系，记作O（n），也叫线性阶。</p><p>常见的时间复杂度有：</p><p>O(1): Constant Complexity: Constant 常数复杂度<br>O(log n): Logarithmic Complexity: 对数复杂度<br>O(n): Linear Complexity: 线性时间复杂度<br>O(n^2): N square Complexity 平⽅方<br>O(n^3): N square Complexity ⽴立⽅方<br>O(2^n): Exponential Growth 指数<br>O(n!): Factorial 阶乘</p><p><img src="/images/blog/20190510/1.webp" alt></p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。</p><p>一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。</p><p>排序或许是前端接触最多的算法了，很多人的算法之路是从一个冒泡排序开始的，排序的方法有非常多中，它们各自有各自的应用场景和优缺点，这里我推荐如下6种应用最多的排序方法，如果你有兴趣也可以研究下其他几种。</p><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>选择一个目标值，比目标值小的放左边，比目标值大的放右边，目标值的位置已排好，将左右两侧再进行快排。</p><h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p>将大序列二分成小序列，将小序列排序后再将排序后的小序列归并成大序列。</p><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>每次排序取一个最大或最小的数字放到前面的有序序列中。</p><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。</p><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>循环数组，比较当前元素和下一个元素，如果当前元素比下一个元素大，向上冒泡。下一次循环继续上面的操作，不循环已经排序好的数。</p><h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><p>创建一个大顶堆，大顶堆的堆顶一定是最大的元素。交换第一个元素和最后一个元素，让剩余的元素继续调整为大顶堆。从后往前以此和第一个元素交换并重新构建，排序完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 - 回溯算法</title>
    <link href="http://yoursite.com/post/2019-05-06-20190506/"/>
    <id>http://yoursite.com/post/2019-05-06-20190506/</id>
    <published>2019-05-06T09:25:23.000Z</published>
    <updated>2020-03-11T09:57:06.650Z</updated>
    
    <content type="html"><![CDATA[<p> 回溯算法</p><a id="more"></a><p>从解决问题每一步的所有可能选项里系统选择出一个可行的解决方案。</p><p>在某一步选择一个选项后，进入下一步，然后面临新的选项。重复选择，直至达到最终状态。</p><p>回溯法解决的问题的所有选项可以用树状结构表示。</p><ul><li>在某一步有n个可能的选项，该步骤可看作树中一个节点。</li><li>节点每个选项看成节点连线，到达它的n个子节点。</li><li>叶节点对应终结状态。</li><li>叶节点满足约束条件，则为一个可行的解决方案。</li><li>叶节点不满足约束条件，回溯到上一个节点，并尝试其他叶子节点。</li><li>节点所有子节点均不满足条件，再回溯到上一个节点。</li><li>所有状态均不能满足条件，问题无解。</li></ul><p><img src="/images/blog/20190506/1.png" alt></p><h5 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h5><h5 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h5><h5 id="和为sum的n个数"><a href="#和为sum的n个数" class="headerlink" title="和为sum的n个数"></a>和为sum的n个数</h5><h5 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h5><h5 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h5><h5 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 回溯算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 - 排序 — 时间复杂度为O(n)的三种排序算法</title>
    <link href="http://yoursite.com/post/2019-05-02-20190502/"/>
    <id>http://yoursite.com/post/2019-05-02-20190502/</id>
    <published>2019-05-02T09:25:23.000Z</published>
    <updated>2020-03-11T09:52:51.546Z</updated>
    
    <content type="html"><![CDATA[<p>时间复杂度为O(n)的三种排序算法</p><a id="more"></a><p>这三种排序算法分别是桶排序、计数排序和基数排序，之所以它们的时间复杂度能到达O(n)，是因为它们都是非基于比较的排序算法，不涉及元素之间的比较操作。</p><h4 id="1-桶排序"><a href="#1-桶排序" class="headerlink" title="1 桶排序"></a>1 桶排序</h4><h5 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h5><p>将待排数据元素分配到几个有序的桶中，然后对每个桶中的数据元素分别进行排序，每个桶中的数据元素有序后按桶的顺序将数据元素依次取出，这样整个序列就有序。</p><p>1.2 算法分析</p><h5 id="1-2-1-时间复杂度"><a href="#1-2-1-时间复杂度" class="headerlink" title="1.2.1 时间复杂度"></a>1.2.1 时间复杂度</h5><p>假设待排序列数据元素个数为n，桶的数量为m；那么平均每个桶中的数据元素个数为k = n / m，对每个桶中的数据元素进行快速排序，那么每个桶中的时间复杂度为O(k * logk)，也就是(n / m) * O(log (n / m))，总的时间复杂度为O(n * log(n / m))；当桶的个数m接近数据元素个数时，那么log(n / m)就是一个常数，此时时间复杂度为O(n)。</p><h5 id="1-2-2-空间复杂度"><a href="#1-2-2-空间复杂度" class="headerlink" title="1.2.2 空间复杂度"></a>1.2.2 空间复杂度</h5><p>实现过程中，所有桶大小之和等于待排序列数据元素个数；对桶内数据元素进行排序时，可以使用快速排序和归并排序，快速排序的时间复杂度为O(1)，归并排序的时间复杂度为O(n)；所以桶排序的时间复杂度为O(n)。</p><h5 id="1-2-3-稳定性"><a href="#1-2-3-稳定性" class="headerlink" title="1.2.3 稳定性"></a>1.2.3 稳定性</h5><p>桶排序的稳定性与桶内元素排序算法是否稳定有关，如果桶内排序算法是稳定的，那么桶排序也是稳定的，反之，则桶排序不是稳定的。</p><h5 id="1-2-4-适用场景"><a href="#1-2-4-适用场景" class="headerlink" title="1.2.4 适用场景"></a>1.2.4 适用场景</h5><p>1）待排数据元素在一定区间内分布均匀，可以容易的划分到桶中，而且各个桶中的数据元素个数均匀；</p><p>2）桶排序比较适用于外部排序，外部排序就是当数据量过大，无法全部加载到内存中。</p><h4 id="2-计数排序"><a href="#2-计数排序" class="headerlink" title="2 计数排序"></a>2 计数排序</h4><h5 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h5><p>计数排序可以看成是特殊的桶排序。待排序序列有n个数据元素且数值范围不大，最大值为k，我们可以划分为k个桶，每个桶内的数据元素值相同，节省了桶内排序的时间。</p><h5 id="2-2-算法分析"><a href="#2-2-算法分析" class="headerlink" title="2.2 算法分析"></a>2.2 算法分析</h5><h5 id="2-2-1-时间复杂度"><a href="#2-2-1-时间复杂度" class="headerlink" title="2.2.1 时间复杂度"></a>2.2.1 时间复杂度</h5><p>计数排序的实现过程中，需要遍历两次序列，第一次从前往后划分数据元素，第二次从后往前重新排序，所以计数排序的时间复杂度为O(n)。</p><h5 id="2-2-2-空间复杂度"><a href="#2-2-2-空间复杂度" class="headerlink" title="2.2.2 空间复杂度"></a>2.2.2 空间复杂度</h5><p>计数排序过程中，首先需要长度为k+1的数组存储每个数值的元素个数，然后重新排序过程中，需要临时数组存放排序结果，所以计数排序的空间复杂度为O(n)。</p><h5 id="2-2-3-稳定性"><a href="#2-2-3-稳定性" class="headerlink" title="2.2.3 稳定性"></a>2.2.3 稳定性</h5><p>计数排序的实现过程中只有将原序列中数据元素存放到临时数组时会发生位置改变，但是实现使得并不会改变相同元素的相对位置，所以计数排序是稳定的。</p><h5 id="2-3-适用场景"><a href="#2-3-适用场景" class="headerlink" title="2.3 适用场景"></a>2.3 适用场景</h5><p>1）计数排序适合数据范围不大的场景；</p><p>2）计数排序只适合于非负整数排序，如果是其他数据类型，要在不改变其相对大小的情况下，将其转换为非负整数再进行排序。</p><h4 id="3-基数排序"><a href="#3-基数排序" class="headerlink" title="3 基数排序"></a>3 基数排序</h4><p>将数据元素划分出独立的位进行比较，而且位之间有递进关系，如果a的高位比b大，那么低位就不用进行比较了。除此之外，每一个位的数据范围不能太大，要可以用桶排序或者计数排序进行排序，这样基数排序的时间复杂度才为O(n)。例如，我们对10个电话号码进行排序，就可以使用基数排序算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间复杂度为O(n)的三种排序算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>vue源码分析 - vue运行机制全局概览</title>
    <link href="http://yoursite.com/post/2019-04-08-20190408/"/>
    <id>http://yoursite.com/post/2019-04-08-20190408/</id>
    <published>2019-04-08T09:25:23.000Z</published>
    <updated>2020-03-11T06:03:08.548Z</updated>
    
    <content type="html"><![CDATA[<p> 运行机制全局概览</p><a id="more"></a><h4 id="Vue-js-运行机制全局概览"><a href="#Vue-js-运行机制全局概览" class="headerlink" title="Vue.js 运行机制全局概览"></a>Vue.js 运行机制全局概览</h4><h5 id="全局概览"><a href="#全局概览" class="headerlink" title="全局概览"></a>全局概览</h5><p>这一节笔者将为大家介绍一下 Vue.js 内部的整个流程，希望能让大家对全局有一个整体的印象，然后我们再来逐个模块进行讲解。从来没有了解过 Vue.js 实现的同学可能会对一些内容感到疑惑，这是很正常的，这一节的目的主要是为了让大家对整个流程有一个大概的认识，算是一个概览预备的过程，当把整本小册认真读完以后，再来阅读这一节，相信会有收获的。<br>首先我们来看一下笔者画的内部流程图。</p><p><img src="/images/blog/20190408/1.png" alt></p><p>大家第一次看到这个图一定是一头雾水的，没有关系，我们来逐个讲一下这些模块的作用以及调用关系。相信讲完之后大家对Vue.js内部运行机制会有一个大概的认识。</p><h5 id="初始化及挂载"><a href="#初始化及挂载" class="headerlink" title="初始化及挂载"></a>初始化及挂载</h5><p><img src="/images/blog/20190408/2.png" alt></p><p>在 new Vue() 之后。 Vue 会调用 _init 函数进行初始化，也就是这里的 init 过程，它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现「响应式」以及「依赖收集」，后面会详细讲到，这里只要有一个印象即可。<br>初始化之后调用 $mount会挂载组件，如果是运行时编译，即不存在 render function 但是存在 template 的情况，需要进行「编译」步骤。</p><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>compile编译可以分成 parse、optimize 与 generate 三个阶段，最终需要得到 render function。</p><p><img src="/images/blog/20190408/3.png" alt></p><ul><li>parse</li></ul><p>parse 会用正则等方式解析 template 模板中的指令、class、style等数据，形成AST。</p><ul><li>optimize</li></ul><p>optimize 的主要作用是标记 static 静态节点，这是 Vue 在编译过程中的一处优化，后面当 update 更新界面时，会有一个 patch 的过程， diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 patch 的性能。</p><ul><li>generate</li></ul><p>generate 是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。<br>在经历过 parse、optimize 与 generate 这三个阶段以后，组件中就会存在渲染 VNode 所需的 render function 了。</p><h5 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h5><p>接下来也就是 Vue.js 响应式核心部分。</p><p><img src="/images/blog/20190408/4.png" alt></p><p>这里的 getter 跟 setter 已经在之前介绍过了，在 init 的时候通过 Object.defineProperty 进行了绑定，它使得当被设置的对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter 函数。<br>当 render function 被渲染的时候，因为会读取所需对象的值，所以会触发 getter 函数进行「依赖收集」，「依赖收集」的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。形成如下所示的这样一个关系。</p><p><img src="/images/blog/20190408/5.png" alt></p><p>在修改对象的值的时候，会触发对应的 setter， setter 通知之前「依赖收集」得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图，当然这中间还有一个 patch 的过程以及使用队列来异步更新的策略，这个我们后面再讲。<br>Virtual DOM</p><p>我们知道，render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（ VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。</p><p>比如说下面这样一个例子：</p><pre><code>{tag: &apos;div&apos;,           /*说明这是一个div标签*/children: [           /*存放该标签的子节点*/    {    tag: &apos;a&apos;,         /*说明这是一个a标签*/    text: &apos;click me&apos;  /*标签的内容*/    }]}</code></pre><p>渲染后可以得到:</p><pre><code>&lt;div&gt;&lt;a&gt;click me&lt;/a&gt;&lt;/div&gt;</code></pre><p>这只是一个简单的例子，实际上的节点有更多的属性来标志节点，比如 isStatic （代表是否为静态节点）、 isComment （代表是否为注释节点）等。</p><p>更新视图</p><p><img src="/images/blog/20190408/6.png" alt></p><p>前面我们说到，在修改一个对象值的时候，会通过 setter -&gt; Watcher -&gt; update 的流程来修改对应的视图，那么最终是如何更新视图的呢？<br>当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode 节点，然后用 innerHTML 直接全部渲染到真实 DOM 中。但是其实我们只对其中的一小块内容进行了修改，这样做似乎有些「浪费」。</p><p>那么我们为什么不能只修改那些「改变了的地方」呢？这个时候就要介绍我们的「patch」了。我们会将新的 VNode 与旧的 VNode 一起传入 patch 进行比较，经过 diff 算法得出它们的「差异」。最后我们只需要将这些「差异」的对应 DOM 进行修改即可。</p><p>再看全局</p><p><img src="/images/blog/20190408/7.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 运行机制全局概览&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue源码分析 - observer,dep,watch实现数据双向绑定</title>
    <link href="http://yoursite.com/post/2019-04-01-20190401/"/>
    <id>http://yoursite.com/post/2019-04-01-20190401/</id>
    <published>2019-04-01T09:25:23.000Z</published>
    <updated>2020-03-11T06:03:12.062Z</updated>
    
    <content type="html"><![CDATA[<p>vue源码分析 - observer,dep,watch,实现数据双向绑定</p><a id="more"></a><p>我们把双向数据绑定分为两个流程：</p><h4 id="1、收集依赖流程："><a href="#1、收集依赖流程：" class="headerlink" title="1、收集依赖流程："></a>1、收集依赖流程：</h4><pre><code>observe -&gt; walk -&gt; defineReactive -&gt; get -&gt; dep.depend() -&gt; watcher.addDep(new Dep()) -&gt; watcher.newDeps.push(dep) -&gt; dep.addSub(new Watcher()) -&gt; dep.subs.push(watcher)</code></pre><p>依赖收集会经过以上流程，最终watcher.newDeps数组中存放dep列表，dep.subs数组中存放watcher列表。</p><h6 id="为什么要进行依赖收集？"><a href="#为什么要进行依赖收集？" class="headerlink" title="为什么要进行依赖收集？"></a>为什么要进行依赖收集？</h6><pre><code>new Vue({    data(){        return {            name:&apos;zane&apos;,            sex:&apos;男&apos;        }    }})</code></pre><p>有上面这个data，实际上页面只使用到了name，并没有使用age，根据Object.defineProperty的转换，如果我们设置了this.sex=’女’，那么Vue也会去执行一遍虚拟DOM的比较，这样就无形的浪费了一些性能，因此才需要做依赖收集，界面用到了就收集，没有用到就不收集。</p><p>我们跟着流程走来理一遍源码：</p><p>直接进入Object.defineProperty的get方法：</p><p><img src="/images/blog/20190401/1.png" alt></p><p>考验你闭包能力的时候到了，这个dep对象就是一个闭包。记下来我们看看dep.depend()方法的实现。</p><p><img src="/images/blog/20190401/2.png" alt></p><p>先暂停一下，上面两处都用到了 Dep.target ，我也说了它就是一个Watcher实例化对象，你是不是很想搞懂它到底在哪里赋值的呢，不急请跟着我下面的代码看看。</p><p><img src="/images/blog/20190401/3.png" alt><br><img src="/images/blog/20190401/4.png" alt><br><img src="/images/blog/20190401/5.png" alt></p><p>搞懂了Dep.target等于一个Watche对象，现在继续回到之前的思路看watcher.addDep做了什么。</p><p><img src="/images/blog/20190401/6.png" alt><br><img src="/images/blog/20190401/7.png" alt></p><p>就这样依赖收集的流程就走完了，是否感觉很绕。</p><h6 id="总结：依赖收集最终在-watcher-newDeps-中push了闭包中传过来的dep对象，在dep-subs中push了初始化Vue是简历的Watcher对象，这个对象的，this-getter-expOrFn-传过来的expOrFn是后期数据更新页面渲染的核心步骤，需要沉下心来好好去理理。"><a href="#总结：依赖收集最终在-watcher-newDeps-中push了闭包中传过来的dep对象，在dep-subs中push了初始化Vue是简历的Watcher对象，这个对象的，this-getter-expOrFn-传过来的expOrFn是后期数据更新页面渲染的核心步骤，需要沉下心来好好去理理。" class="headerlink" title="总结：依赖收集最终在 watcher.newDeps 中push了闭包中传过来的dep对象，在dep.subs中push了初始化Vue是简历的Watcher对象，这个对象的，this.getter = expOrFn,传过来的expOrFn是后期数据更新页面渲染的核心步骤，需要沉下心来好好去理理。"></a>总结：依赖收集最终在 watcher.newDeps 中push了闭包中传过来的dep对象，在dep.subs中push了初始化Vue是简历的Watcher对象，这个对象的，this.getter = expOrFn,传过来的expOrFn是后期数据更新页面渲染的核心步骤，需要沉下心来好好去理理。</h6><h4 id="2、视图更新流程："><a href="#2、视图更新流程：" class="headerlink" title="2、视图更新流程："></a>2、视图更新流程：</h4><pre><code>set -&gt; dep.notify() -&gt; subs[i].update() -&gt; watcher.run() || queueWatcher(this) -&gt; watcher.get() || watcher.cb -&gt; watcher.getter() -&gt; vm._update() -&gt; vm.__patch__()</code></pre><p>视图更新会经过以上流程，最终调用Vue的虚拟Dom diff过程实时更新界面视图</p><p><img src="/images/blog/20190401/8.png" alt><br><img src="/images/blog/20190401/9.png" alt><br><img src="/images/blog/20190401/10.png" alt><br><img src="/images/blog/20190401/11.png" alt><br><img src="/images/blog/20190401/12.png" alt><br><img src="/images/blog/20190401/13.png" alt></p><p>走到此处后面我就不去跟踪了，后面会调用vm.<strong>patch</strong> 方法，进而执行虚拟DOM的diff过程实时的更新界面。</p><h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>要很好的理解vue的数据双向绑定就要比较耐心，沉下心来慢慢理解，同时也需要对vue的源码有个大致的理解，不然你只会看的越来越烦躁越来越没有信心。vue很好的利用了Object.defineProperty方法的 get和set方法，订阅者发布者的设计思路，巧妙的组织代码，值得我们很深入的去学习和理解，从而促使我们更好的去使用它。谢谢尤大的无私奉献，让我们提高了生产力，把更多的精力花到业务逻辑中去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue源码分析 - observer,dep,watch,实现数据双向绑定&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>js处理的8种跨域方法</title>
    <link href="http://yoursite.com/post/2019-02-12-20190212/"/>
    <id>http://yoursite.com/post/2019-02-12-20190212/</id>
    <published>2019-02-12T09:25:23.000Z</published>
    <updated>2020-03-11T09:28:24.308Z</updated>
    
    <content type="html"><![CDATA[<p>js处理的8种跨域方法</p><a id="more"></a><p>这里说的js跨域是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。只要协议、域名、端口有任何一个不同，都被当作是不同的域。</p><p>特别注意两点：</p><p>#1、如果是协议和端口造成的跨域问题“前台”是无能为力的； </p><p>#2、在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。<br>要解决跨域的问题，我们可以使用以下几种方法：</p><h5 id="方法一、通过jsonp跨域"><a href="#方法一、通过jsonp跨域" class="headerlink" title="方法一、通过jsonp跨域"></a>方法一、通过jsonp跨域</h5><p>JSONP包含两部分：回调函数和数据。<br>回调函数：当响应到来时要放在当前页面被调用的函数。<br>数据：就是传入回调函数中的json数据，也就是回调函数的参数了。</p><pre><code>/*handleResonse({&quot;data&quot;: &quot;zhe&quot;})*///原理如下：//当我们通过script标签请求时//后台就会根据相应的参数(json,handleResponse)//来生成相应的json数据(handleResponse({&quot;data&quot;: &quot;zhe&quot;}))//最后这个返回的json数据(代码)就会被放在当前js文件中被执行//至此跨域通信完成//1、使用JS动态生成script标签，进行跨域操作function handleResponse(response){    console.log(&apos;The responsed data is: &apos;+response.data);    //处理获得的Json数据}var script = document.createElement(&apos;script&apos;);script.src = &apos;http://www.example.com/data/?callback=handleResponse&apos;;document.body.insertBefore(script, document.body.firstChild);--------------------------//2、手动生成script标签function handleResponse(response){    console.log(&apos;The responsed data is: &apos;+response.data);    //处理获得的Json数据}&lt;script src=&quot;http://www.example.com/data/?callback=handleResponse&quot;&gt;&lt;/script&gt;--------------------------//3、使用jQuery进行jsonp操作//jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁//$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。&lt;script&gt;    $.getJson(&apos;http://www.example.com/data/?callback=?&apos;,function(jsondata){    //处理获得的Json数据});&lt;/script&gt;</code></pre><p>jsonp虽然很简单，但是有如下缺点：</p><p>#1）安全问题(请求代码中可能存在安全隐患)</p><p>#2）要确定jsonp请求是否失败并不容易</p><h5 id="方法二、通过document-domain-iframe来跨子域-只有在主域相同的时候才能使用该方法"><a href="#方法二、通过document-domain-iframe来跨子域-只有在主域相同的时候才能使用该方法" class="headerlink" title="方法二、通过document.domain+iframe来跨子域(只有在主域相同的时候才能使用该方法)"></a>方法二、通过document.domain+iframe来跨子域(只有在主域相同的时候才能使用该方法)</h5><p>#（1）不能通过ajax的方法去请求不同源中的文档。</p><p>#（2）浏览器中不同域的框架之间是不能进行js的交互操作的。</p><p>所以，在不同的框架之间（父子或同辈），是能够获取到彼此的window对象的，但不能使用获取到的window对象的属性和方法(html5中的postMessage方法是一个例外)，总之，你可以当做是只能获取到一个几乎无用的window对象。 </p><p>　　例如，在一个页面 http:// <a href="http://www.example.com/a.html" target="_blank" rel="noopener">www.example.com/a.html</a> 中，有一个iframe框架它的src是http:// example.com/b.html, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：</p><pre><code>//  http://www.example.com/a.html 页面中 &lt;script&gt; function onLoad(){     var iframe = document.getElementById(&apos;iframe&apos;);     var win = iframe.contentWindow;     //这里能够获取到iframe中的window对象，但是window对象的属性和方法几乎不可用。     var doc = win.document;//这里获取不到iframe中的document对象     var name = win.name;//这里获取不到window对象的name属性     ······ } &lt;iframe id = &quot;iframe&quot; src =&quot;http:// example.com/b.html&quot; onload = &quot;onLoad()&quot;&gt;&lt;/iframe&gt; </code></pre><p>所以我们就要用到document.domain</p><p>1) 在页面http:// <a href="http://www.a.com/dir/a.html中设置document.domain：" target="_blank" rel="noopener">www.a.com/dir/a.html中设置document.domain：</a></p><pre><code>1 &lt;iframe src = &quot;http://script.a.com/dir/b.html&quot; id=&quot;iframe&quot; onload = &quot;loLoad()&quot;&gt;&lt;/iframe&gt;2 &lt;script&gt;3 document.domain = &quot;a.com&quot;;//设置成主域4 function test(){5     var iframe = document.getElementById(&quot;iframe&quot;);6     var win = iframe.contentWindow;7     //在这里就可以操作b.html8 }9 &lt;/script&gt;</code></pre><p>2) 在http:// script.a.com/dir/b.html也需要显示的设置document.domain</p><pre><code>&lt;script&gt;     document.domain = &quot;a.com&quot;;&lt;/script&gt;</code></pre><p>注意，document.domain的设置是有限制的：</p><p>　　我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。<br>　　例如：a.b.c.com 中某个文档的document.domain 可以设成a.b.c.com、b.c.com 、c.com中的任意一个</p><h5 id="方法三、使用window-name-iframe来进行跨域"><a href="#方法三、使用window-name-iframe来进行跨域" class="headerlink" title="方法三、使用window.name+iframe来进行跨域"></a>方法三、使用window.name+iframe来进行跨域</h5><p>window的name属性特征：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB），即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面window.name都有读写的权限。</p><p>　　正是由于window的name属性的特征，所以可以使用window.name来进行跨域。<br>　　举例：<br>　　1）在一个a.html页面中，有如下代码：</p><pre><code>&lt;script&gt;    window.name = &quot;哈哈，我是页面a设置的值哟！&quot;;    //设置window.name的值    setTimeout(function(){        window.location = &apos;b.html&apos;;    },3000);//3秒后把一个新页面载入当前window&lt;/script&gt;</code></pre><p>2）再在b.html中读取window.name的值：</p><pre><code>&lt;script&gt;    alert(window.name);//读取window.name的值&lt;/script&gt;</code></pre><p>3）a.html载入3秒后，跳转到b.html页面中，结果为  弹出框”哈哈，我是页面a设置的值哟！”</p><p>#注意： </p><p>#1.window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器。</p><p>接下来使用window.name进行跨域举例</p><p>　　比如：有一个example.com/a.html页面,需要通过a.html页面里的js来获取另一个位于不同域上的页面cnblogs.com/data.html里的数据。 </p><p>　　1)创建cnblogs.com/data.html代码：<br>        <script><br>             window.name = "我是data.html的数据，所有可以转化为字符串来传递的数据都可以在这里使用，比如这里可以传递Json数据";<br>        </script></p><p>2)创建example.com/a.html的代码：<br>    想要即使a.html页面不跳转也能得到data.html里的数据。在a.html页面中使用一个隐藏的iframe来充当一个中间人角色，由iframe去获取data.html的数据，然后a.html再去得到iframe获取到的数据。</p><pre><code>&lt;script&gt;    function getData(){    //iframe载入data.html页面会执行此函数        var ifr = document.getElementById(&quot;iframe&quot;);        ifr.onload = function(){        //这个时候iframe和a.html已经处于同一源，可以互相访问            var data = ifr.contentWindow.name;//获取iframe中的window.name，也就是data.html中给它设置的数据            alert(data);        }        ifr.src = &apos;b.html&apos;;//这里的b.html为随便一个页面，只要与a.html同源就行，目的是让a.html能够访问到iframe中的东西，否则访问不到    }&lt;/script&gt;&lt;iframe id = &quot;iframe&quot; src = &quot;cnblogs.com/data.html&quot; style = &quot;display:none&quot; onload = &quot;getData()&quot;&gt;&lt;/iframe&gt;</code></pre><h5 id="方法四、使用window-postMessage方法来跨域-不常用"><a href="#方法四、使用window-postMessage方法来跨域-不常用" class="headerlink" title="方法四、使用window.postMessage方法来跨域(不常用)"></a>方法四、使用window.postMessage方法来跨域(不常用)</h5><p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源(可实现跨域)，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。<br>　　message：为要发送的消息，类型只能为字符串；<br>　　targetOrigin：用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 “*”。</p><p>1)创建<a href="http://www.test.com/a.html页面代码：" target="_blank" rel="noopener">www.test.com/a.html页面代码：</a></p><pre><code>&lt;script&gt;function onLoad(){    var iframe = document.getElementById(&quot;iframe&quot;);    var win = iframe.contentWindow;    win.postMessage(&apos;哈哈，我是来自页面a.html的信息哟！&apos;,&apos;*&apos;);//向不同域的www.script.com/b.html发送消息}&lt;/script&gt;&lt;iframe id=&quot;iframe&quot; src=&quot;www.script.com/b.html&quot; onload=&quot;onLoad()&quot;&gt;&lt;/iframe&gt;</code></pre><p>2)创建<a href="http://www.script.com/b.html页面代码：" target="_blank" rel="noopener">www.script.com/b.html页面代码：</a></p><pre><code>&lt;script&gt;window.onmessage = function(e){//注册message时间来接收消息    e = e || event;            //获取时间对象    alert(e.data);             //通过data属性来得到传送的消息}&lt;/script&gt;</code></pre><p>优点：使用postMessage来跨域传送数据还是比较直观和方便的；<br>缺点： IE6、IE7不支持，所以用不用还得根据实际需要来决定。</p><h5 id="方法五、使用跨域资源共享（CORS）来跨域"><a href="#方法五、使用跨域资源共享（CORS）来跨域" class="headerlink" title="方法五、使用跨域资源共享（CORS）来跨域"></a>方法五、使用跨域资源共享（CORS）来跨域</h5><p>CORS：一种跨域访问的机制，可以让AJAX实现跨域访问；CORS允许一个域上的网络应用向另一个域提交跨域AJAX请求。<br>服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求．<br>就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p><p>1) IE中对CORS的实现是通过xdr</p><pre><code>var xdr = new XDomainRequest();xdr.onload = function(){    console.log(xdr.responseText);}xdr.open(&apos;get&apos;, &apos;http://www.test.com&apos;);......xdr.send(null);</code></pre><p>2) 其它浏览器中的实现就在xhr中</p><pre><code>var xhr =  new XMLHttpRequest();xhr.onreadystatechange = function () {if(xhr.readyState === 4 &amp;&amp; xhr.status === 200){        console.log(xhr.responseText);        }     }}xhr.open(&apos;get&apos;, &apos;http://www.test.com&apos;);......xhr.send(null);</code></pre><p>3) 实现跨浏览器的CORS</p><pre><code>function createCORS(method, url){    var xhr = new XMLHttpRequest();    if(&apos;withCredentials&apos; in xhr){        xhr.open(method, url, true);    }else if(typeof XDomainRequest != &apos;undefined&apos;){        var xhr = new XDomainRequest();        xhr.open(method, url);    }else{        xhr = null;    }    return xhr;}var request = createCORS(&apos;get&apos;, &apos;http://www.test.com&apos;);if(request){    request.onload = function(){        ......    };    request.send();}</code></pre><h5 id="方法六、使用location-hash-iframe来跨域（不常用）"><a href="#方法六、使用location-hash-iframe来跨域（不常用）" class="headerlink" title="方法六、使用location.hash+iframe来跨域（不常用）"></a>方法六、使用location.hash+iframe来跨域（不常用）</h5><p>假设域名test.com下的文件a.html要和csdnblogs.com域名下的b.html传递信息。<br>　　1) 创建test.com下的a.html页面， 同时在a.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一旦有变化则获取获取hash值，代码如下：</p><pre><code>&lt;script&gt;function startRequest(){    var ifr = document.createElement(&apos;iframe&apos;);    //创建一个隐藏的iframe    ifr.style.display = &apos;none&apos;;    ifr.src = &apos;http://www.csdnblogs.com/b.html#paramdo&apos;;    //传递的location.hash     document.body.appendChild(ifr);}function checkHash() {    try {        var data = location.hash ? location.hash.substring(1):&apos;&apos;;        if (console.log) {            console.log(&apos;Now the data is &apos; + data);        }    } catch (e) {};}setInterval(checkHash, 5000);window.onload = startRequest;&lt;/script&gt;</code></pre><p> 2) b.html响应请求后再将通过修改a.html的hash值来传递数据，代码如下：      </p><pre><code>&lt;script&gt;function checkHash() {    var data = &apos;&apos;;    //模拟一个简单的参数处理操作    switch (location.hash) {        case &apos;#paramdo&apos;:            data = &apos;somedata&apos;;            break;        case &apos;#paramset&apos;:            //do something……            break;        default:            break;    }    data &amp;&amp; callBack(&apos;#&apos; + data);}function callBack(hash) {    // ie、chrome的安全机制无法修改parent.location.hash    //所以要利用一个中间的www.csdnblogs.com域下的代理iframe    var proxy = document.createElement(&apos;iframe&apos;);    proxy.style.display = &apos;none&apos;;    proxy.src = &apos;http://www.csdnblogs.com/c.html&apos; + hash;     // 注意该文件在&quot;www.csdnblogs.com&quot;域下    document.body.appendChild(proxy);}window.onload = checkHash;&lt;/script&gt;</code></pre><p>3) test.com域下的c.html代码：</p><pre><code>&lt;script&gt; //因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值parent.parent.location.hash = self.location.hash.substring(1);&lt;/script&gt;</code></pre><h5 id="方法七、使用Web-sockets来跨域"><a href="#方法七、使用Web-sockets来跨域" class="headerlink" title="方法七、使用Web sockets来跨域"></a>方法七、使用Web sockets来跨域</h5><p>web sockets： 是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)</p><p>web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。</p><pre><code>&lt;script&gt;var socket = new WebSockt(&apos;ws://www.test.com&apos;);//http-&gt;ws; https-&gt;wsssocket.send(&apos;hello WebSockt&apos;);socket.onmessage = function(event){    var data = event.data;}</code></pre><h5 id="方法八、使用flash-URLLoader来跨域"><a href="#方法八、使用flash-URLLoader来跨域" class="headerlink" title="方法八、使用flash URLLoader来跨域"></a>方法八、使用flash URLLoader来跨域</h5><p>flash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。<br>例如：当跨域访问资源时，例如从域baidu.com请求域google.com上的数据，我们可以借助flash来发送HTTP请求。</p><p>跨域实现方式： 　</p><p>#1. 首先，修改域google.com上的crossdomain.xml(一般存放在根目录，如果没有需要手动创建) ，把baidu.com加入到白名单。 </p><p>#2. 其次，通过Flash URLLoader发送HTTP请求 </p><p>#3. 最后，通过Flash API把响应结果传递给JavaScript。</p><p>Flash URLLoader是一种很普遍的跨域解决方案，不过需要支持iOS的话，这个方案就不可行了。 </p><p>以上八种方法，可以根据项目的实际情况来进行选择应用，个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js处理的8种跨域方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入之继承的多种方式和优缺点</title>
    <link href="http://yoursite.com/post/2019-02-01-20190201/"/>
    <id>http://yoursite.com/post/2019-02-01-20190201/</id>
    <published>2019-02-01T09:25:23.000Z</published>
    <updated>2020-03-11T09:28:31.648Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲解JavaScript各种继承方式和优缺点。</p><a id="more"></a><h5 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h5><pre><code>function Parent () {    this.name = &apos;kevin&apos;;}Parent.prototype.getName = function () {    console.log(this.name);}function Child () {}Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName()) // kevin</code></pre><p>问题：</p><p>1.引用类型的属性被所有实例共享，举个例子：</p><pre><code>function Parent () {    this.names = [&apos;kevin&apos;, &apos;daisy&apos;];}function Child () {}Child.prototype = new Parent();var child1 = new Child();child1.names.push(&apos;yayu&apos;);console.log(child1.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]var child2 = new Child();console.log(child2.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</code></pre><p>2.在创建 Child 的实例时，不能向Parent传参</p><h4 id="2-借用构造函数-经典继承"><a href="#2-借用构造函数-经典继承" class="headerlink" title="2.借用构造函数(经典继承)"></a>2.借用构造函数(经典继承)</h4><pre><code>function Parent () {    this.names = [&apos;kevin&apos;, &apos;daisy&apos;];}function Child () {    Parent.call(this);}var child1 = new Child();child1.names.push(&apos;yayu&apos;);console.log(child1.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]var child2 = new Child();console.log(child2.names); // [&quot;kevin&quot;, &quot;daisy&quot;]</code></pre><p>优点：</p><p>1.避免了引用类型的属性被所有实例共享</p><p>2.可以在 Child 中向 Parent 传参</p><p>举个例子：</p><p>function Parent (name) {<br>    this.name = name;<br>}</p><p>function Child (name) {<br>    Parent.call(this, name);<br>}</p><p>var child1 = new Child(‘kevin’);</p><p>console.log(child1.name); // kevin</p><p>var child2 = new Child(‘daisy’);</p><p>console.log(child2.name); // daisy</p><p>缺点：</p><p>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</p><h4 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h4><p>原型链继承和经典继承双剑合璧。</p><pre><code>function Parent (name) {    this.name = name;    this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];}Parent.prototype.getName = function () {    console.log(this.name)}function Child (name, age) {    Parent.call(this, name);    this.age = age;}Child.prototype = new Parent();Child.prototype.constructor = Child;var child1 = new Child(&apos;kevin&apos;, &apos;18&apos;);child1.colors.push(&apos;black&apos;);console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var child2 = new Child(&apos;daisy&apos;, &apos;20&apos;);console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</code></pre><p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p><h4 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h4><pre><code>function createObj(o) {    function F(){}    F.prototype = o;    return new F();}</code></pre><p>就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</p><p>缺点：</p><p>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p><pre><code>var person = {    name: &apos;kevin&apos;,    friends: [&apos;daisy&apos;, &apos;kelly&apos;]}var person1 = createObj(person);var person2 = createObj(person);person1.name = &apos;person1&apos;;console.log(person2.name); // kevinperson1.firends.push(&apos;taylor&apos;);console.log(person2.friends); // [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]</code></pre><p>注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = ‘person1’，给person1添加了 name 值，并非修改了原型上的 name 值。</p><ol start="5"><li>寄生式继承</li></ol><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p><pre><code>function createObj (o) {    var clone = Object.create(o);    clone.sayName = function () {        console.log(&apos;hi&apos;);    }    return clone;}</code></pre><p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法</p><h4 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h4><p>为了方便大家阅读，在这里重复一下组合继承的代码：</p><pre><code>function Box(name) {    this.name = name;    this.arr = [&apos;哥哥&apos;,&apos;妹妹&apos;,&apos;父母&apos;];}Box.prototype.run = function () {    return this.name;};function Desk(name, age) {    Box.call(this, name);//第二次调用 Box    this.age = age;}Desk.prototype = new Box();//第一次调用 Box</code></pre><p>以上代码是之前的组合继承，那么寄生组合继承寄生组合继承，解决了两次调用的问题</p><pre><code>function obj(o) {    function F() {}    F.prototype = o;    return new F();}function create(box, desk) {    var f = obj(box.prototype);    f.constructor = desk;    desk.prototype = f;}function Box(name) {    this.name = name;    this.arr = [&apos;哥哥&apos;,&apos;妹妹&apos;,&apos;父母&apos;];}Box.prototype.run = function () {    return this.name;};function Desk(name, age) {    Box.call(this, name);    this.age = age;}create(Box, Desk);//通过这里实现继承var desk = new Desk(&apos;Lee&apos;,100);desk.arr.push(&apos;姐姐&apos;);alert(desk.arr);alert(desk.run());//只共享了方法var desk2 = new Desk(&apos;Jack&apos;, 200);alert(desk2.arr);//引用问题解决</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲解JavaScript各种继承方式和优缺点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>当勤精进</title>
    <link href="http://yoursite.com/post/2019-01-17-20190117/"/>
    <id>http://yoursite.com/post/2019-01-17-20190117/</id>
    <published>2019-01-17T09:25:23.000Z</published>
    <updated>2020-03-10T01:32:07.036Z</updated>
    
    <content type="html"><![CDATA[<p>当勤精进</p><a id="more"></a><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><p>尝试着指定日计划/周计划/月计划，有针对性的复习；<br>数学，专业课为主，英语居中，政治中后期主背诵，辅刷题；<br>算法还要持续学习；</p><h4 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h4><p>每天要坚持锻炼，健身卡要充分利用</p><h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p>小时候沉迷于网络小说，看了n多的网络小说，但影响最深的还是蓝大的&lt;高手寂寞&gt;，大概主角的三观和我这种内向的人比较相符的原因，实际上喜欢此书的读者少之又少．最近发现许多的名著读起来还是挺有感觉的，最近接触&lt;白夜行&gt; ，感觉打开了新世界的大门．遂有了下面这个书单：</p><p>&lt;恶意&gt;　东野圭吾<br>&lt;倾城之恋&gt;　张爱玲<br>&lt;百年孤独&gt; 加西亚·马尔克斯<br>&lt;挪威的森林&gt; 村上春树<br>&lt;自控力&gt; 凯利·麦格尼格尔<br>&lt;时间简史&gt; 霍金<br>&lt;阿Ｑ正传&gt; 鲁迅<br>&lt;乌合之众&gt; 勒庞<br>&lt;当我谈跑步时我谈些什么&gt;　村上春树<br>&lt;人间失格&gt; 太宰治<br>电影没什么想看的，也没什么闲着的时间了，唔，还要学着写写书评，嗯，算读后感？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当勤精进&lt;/p&gt;
    
    </summary>
    
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="日志" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>ES6 系列之 defineProperty 与 proxy</title>
    <link href="http://yoursite.com/post/2019-01-12-20190112/"/>
    <id>http://yoursite.com/post/2019-01-12-20190112/</id>
    <published>2019-01-12T02:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.253Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 系列之 defineProperty 与 proxy </p><a id="more"></a><h5 id="definePropety"><a href="#definePropety" class="headerlink" title="definePropety"></a>definePropety</h5><p>ES5 提供了 Object.defineProperty 方法，该方法可以在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。</p><p>语法<br>    Object.defineProperty(obj, prop, descriptor)</p><pre><code>obj: 要在其上定义属性的对象。prop:  要定义或修改的属性的名称。descriptor: 将被定义或修改的属性的描述符。</code></pre><p>举个例子：</p><pre><code>var obj = {};Object.defineProperty(obj, &quot;num&quot;, {    value : 1,    writable : true,    enumerable : true,    configurable : true});//  对象 obj 拥有属性 num，值为 1</code></pre><p>虽然我们可以直接添加属性和值，但是使用这种方式，我们能进行更多的配置。</p><p>函数的第三个参数 descriptor 所表示的属性描述符有两种形式：数据描述符和存取描述符。</p><h6 id="两者均具有以下两种键值："><a href="#两者均具有以下两种键值：" class="headerlink" title="两者均具有以下两种键值："></a>两者均具有以下两种键值：</h6><p>configurable</p><p>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，也能够被删除。默认为 false。<br>enumerable</p><p>当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。</p><h6 id="数据描述符同时具有以下可选键值："><a href="#数据描述符同时具有以下可选键值：" class="headerlink" title="数据描述符同时具有以下可选键值："></a>数据描述符同时具有以下可选键值：</h6><p>value</p><p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。<br>writable</p><p>当且仅当该属性的 writable 为 true 时，该属性才能被赋值运算符改变。默认为 false。</p><h6 id="存取描述符同时具有以下可选键值："><a href="#存取描述符同时具有以下可选键值：" class="headerlink" title="存取描述符同时具有以下可选键值："></a>存取描述符同时具有以下可选键值：</h6><p>get</p><p>一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。<br>set</p><p>一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。<br>值得注意的是：</p><p>属性描述符必须是数据描述符或者存取描述符两种形式之一，不能同时是两者 。这就意味着你可以：</p><pre><code>Object.defineProperty({}, &quot;num&quot;, {    value: 1,    writable: true,    enumerable: true,    configurable: true});</code></pre><p>也可以：</p><pre><code>var value = 1;Object.defineProperty({}, &quot;num&quot;, {    get : function(){      return value;    },    set : function(newValue){      value = newValue;    },    enumerable : true,    configurable : true});</code></pre><p>但是不可以：</p><pre><code>// 报错Object.defineProperty({}, &quot;num&quot;, {    value: 1,    get: function() {        return 1;    }});</code></pre><p>此外，所有的属性描述符都是非必须的，但是 descriptor 这个字段是必须的，如果不进行任何配置，你可以这样：</p><pre><code>var obj = Object.defineProperty({}, &quot;num&quot;, {});console.log(obj.num); // undefined</code></pre><h5 id="Setters-和-Getters"><a href="#Setters-和-Getters" class="headerlink" title="Setters 和 Getters"></a>Setters 和 Getters</h5><p>之所以讲到 defineProperty，是因为我们要使用存取描述符中的 get 和 set，这两个方法又被称为 getter 和 setter。由 getter 和 setter 定义的属性称做”存取器属性“。</p><p>当程序查询存取器属性的值时，JavaScript 调用 getter方法。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，JavaScript 调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责“设置”属性值。可以忽略 setter 方法的返回值。</p><p>举个例子：</p><pre><code>var obj = {}, value = null;Object.defineProperty(obj, &quot;num&quot;, {    get: function(){        console.log(&apos;执行了 get 操作&apos;)        return value;    },    set: function(newValue) {        console.log(&apos;执行了 set 操作&apos;)        value = newValue;    }})obj.num = 1 // 执行了 set 操作console.log(obj.num); // 执行了 get 操作 // 1</code></pre><p>这不就是我们要的监控数据改变的方法吗？我们再来封装一下：</p><pre><code>function Archiver() {    var value = null;    // archive n. 档案    var archive = [];    Object.defineProperty(this, &apos;num&apos;, {        get: function() {            console.log(&apos;执行了 get 操作&apos;)            return value;        },        set: function(value) {            console.log(&apos;执行了 set 操作&apos;)            value = value;            archive.push({ val: value });        }    });    this.getArchive = function() { return archive; };}var arc = new Archiver();arc.num; // 执行了 get 操作arc.num = 11; // 执行了 set 操作arc.num = 13; // 执行了 set 操作console.log(arc.getArchive()); // [{ val: 11 }, { val: 13 }]</code></pre><p>watch API</p><p>既然可以监控数据的改变，那我可以这样设想，即当数据改变的时候，自动进行渲染工作。举个例子：</p><p>HTML 中有个 span 标签和 button 标签</p><pre><code>&lt;span id=&quot;container&quot;&gt;1&lt;/span&gt;&lt;button id=&quot;button&quot;&gt;点击加 1&lt;/button&gt;</code></pre><p>当点击按钮的时候，span 标签里的值加 1。</p><p>传统的做法是：</p><pre><code>document.getElementById(&apos;button&apos;).addEventListener(&quot;click&quot;, function(){    var container = document.getElementById(&quot;container&quot;);    container.innerHTML = Number(container.innerHTML) + 1;});</code></pre><p>如果使用了 defineProperty：</p><pre><code>var obj = {    value: 1}// 储存 obj.value 的值var value = 1;Object.defineProperty(obj, &quot;value&quot;, {    get: function() {        return value;    },    set: function(newValue) {        value = newValue;        document.getElementById(&apos;container&apos;).innerHTML = newValue;    }});document.getElementById(&apos;button&apos;).addEventListener(&quot;click&quot;, function() {    obj.value += 1;});</code></pre><p>代码看似增多了，但是当我们需要改变 span 标签里的值的时候，直接修改 obj.value 的值就可以了。</p><p>然而，现在的写法，我们还需要单独声明一个变量存储 obj.value 的值，因为如果你在 set 中直接 obj.value = newValue 就会陷入无限的循环中。此外，我们可能需要监控很多属性值的改变，要是一个一个写，也很累呐，所以我们简单写个 watch 函数。使用效果如下：</p><pre><code>var obj = {    value: 1}watch(obj, &quot;value&quot;, function(newvalue){    document.getElementById(&apos;container&apos;).innerHTML = newvalue;})document.getElementById(&apos;button&apos;).addEventListener(&quot;click&quot;, function(){    obj.value += 1});</code></pre><p>我们来写下这个 watch 函数：</p><pre><code>(function(){    var root = this;    function watch(obj, name, func){        var value = obj[name];        Object.defineProperty(obj, name, {            get: function() {                return value;            },            set: function(newValue) {                value = newValue;                func(value)            }        });        if (value) obj[name] = value    }    this.watch = watch;})()</code></pre><p>现在我们已经可以监控对象属性值的改变，并且可以根据属性值的改变，添加回调函数，棒棒哒~</p><h5 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h5><p>使用 defineProperty 只能重定义属性的读取（get）和设置（set）行为，到了 ES6，提供了 Proxy，可以重定义更多的行为，比如 in、delete、函数调用等更多行为。</p><p>Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。我们来看看它的语法：</p><p>  var proxy = new Proxy(target, handler);</p><p>proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p><pre><code>var proxy = new Proxy({}, {    get: function(obj, prop) {        console.log(&apos;设置 get 操作&apos;)        return obj[prop];    },    set: function(obj, prop, value) {        console.log(&apos;设置 set 操作&apos;)        obj[prop] = value;    }});proxy.time = 35; // 设置 set 操作console.log(proxy.time); // 设置 get 操作 // 35</code></pre><p>除了 get 和 set 之外，proxy 可以拦截多达 13 种操作，比如 has(target, propKey)，可以拦截 propKey in proxy 的操作，返回一个布尔值。</p><pre><code>// 使用 has 方法隐藏某些属性，不被 in 运算符发现var handler = {  has (target, key) {    if (key[0] === &apos;_&apos;) {      return false;    }    return key in target;  }};var target = { _prop: &apos;foo&apos;, prop: &apos;foo&apos; };var proxy = new Proxy(target, handler);console.log(&apos;_prop&apos; in proxy); // false</code></pre><p>又比如说 apply 方法拦截函数的调用、call 和 apply 操作。</p><p>apply 方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组，不过这里我们简单演示一下：</p><pre><code>var target = function () { return &apos;I am the target&apos;; };var handler = {  apply: function () {    return &apos;I am the proxy&apos;;  }};var p = new Proxy(target, handler);p();// &quot;I am the proxy&quot;</code></pre><p>又比如说 ownKeys 方法可以拦截对象自身属性的读取操作。具体来说，拦截以下操作：</p><pre><code>Object.getOwnPropertyNames()Object.getOwnPropertySymbols()Object.keys()</code></pre><p>下面的例子是拦截第一个字符为下划线的属性名，不让它被 for of 遍历到。</p><pre><code>let target = {  _bar: &apos;foo&apos;,  _prop: &apos;bar&apos;,  prop: &apos;baz&apos;};let handler = {  ownKeys (target) {    return Reflect.ownKeys(target).filter(key =&gt; key[0] !== &apos;_&apos;);  }};let proxy = new Proxy(target, handler);for (let key of Object.keys(proxy)) {  console.log(target[key]);}// &quot;baz&quot;</code></pre><p>更多的拦截行为可以查看阮一峰老师的 《ECMAScript 6 入门》</p><p>值得注意的是，proxy 的最大问题在于浏览器支持度不够，而且很多效果无法使用 poilyfill 来弥补。</p><h5 id="watch-API-优化"><a href="#watch-API-优化" class="headerlink" title="watch API 优化"></a>watch API 优化</h5><p>我们使用 proxy 再来写一下 watch 函数。使用效果如下：</p><pre><code>(function() {    var root = this;    function watch(target, func) {        var proxy = new Proxy(target, {            get: function(target, prop) {                return target[prop];            },            set: function(target, prop, value) {                target[prop] = value;                func(prop, value);            }        });        return proxy;    }    this.watch = watch;})()var obj = {    value: 1}var newObj = watch(obj, function(key, newvalue) {    if (key == &apos;value&apos;) document.getElementById(&apos;container&apos;).innerHTML = newvalue;})document.getElementById(&apos;button&apos;).addEventListener(&quot;click&quot;, function() {    newObj.value += 1});</code></pre><p>我们也可以发现，使用 defineProperty 和 proxy 的区别，当使用 defineProperty，我们修改原来的 obj 对象就可以触发拦截，而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 系列之 defineProperty 与 proxy &lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS异步解决方案的发展历程以及优缺点</title>
    <link href="http://yoursite.com/post/2019-01-02-20190102/"/>
    <id>http://yoursite.com/post/2019-01-02-20190102/</id>
    <published>2019-01-02T02:23:18.000Z</published>
    <updated>2020-03-09T01:44:46.505Z</updated>
    
    <content type="html"><![CDATA[<p>js 异步已经告一段落了，这里来一波小总结</p><a id="more"></a><h5 id="1-回调函数（callback）"><a href="#1-回调函数（callback）" class="headerlink" title="1. 回调函数（callback）"></a>1. 回调函数（callback）</h5><p>  setTimeout(() =&gt; {<br>      // callback 函数体<br>  }, 1000)</p><h6 id="缺点：回调地狱，不能用-try-catch-捕获错误，不能-return"><a href="#缺点：回调地狱，不能用-try-catch-捕获错误，不能-return" class="headerlink" title="缺点：回调地狱，不能用 try catch 捕获错误，不能 return"></a>缺点：回调地狱，不能用 try catch 捕获错误，不能 return</h6><p>回调地狱的根本问题在于：</p><p>缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符<br>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转）<br>嵌套函数过多的多话，很难处理错误</p><p>  ajax(‘XXX1’, () =&gt; {<br>      // callback 函数体<br>      ajax(‘XXX2’, () =&gt; {<br>          // callback 函数体<br>          ajax(‘XXX3’, () =&gt; {<br>              // callback 函数体<br>          })<br>      })<br>  })</p><h6 id="优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）"><a href="#优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）" class="headerlink" title="优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）"></a>优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）</h6><h5 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2.Promise"></a>2.Promise</h5><p>Promise就是为了解决callback的问题而产生的。</p><p>Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装</p><h6 id="优点：解决了回调地狱的问题"><a href="#优点：解决了回调地狱的问题" class="headerlink" title="优点：解决了回调地狱的问题"></a>优点：解决了回调地狱的问题</h6><p>  ajax(‘XXX1’)<br>    .then(res =&gt; {<br>        // 操作逻辑<br>        return ajax(‘XXX2’)<br>    }).then(res =&gt; {<br>        // 操作逻辑<br>        return ajax(‘XXX3’)<br>    }).then(res =&gt; {<br>        // 操作逻辑<br>    })</p><h6 id="缺点：无法取消-Promise-，错误需要通过回调函数来捕获"><a href="#缺点：无法取消-Promise-，错误需要通过回调函数来捕获" class="headerlink" title="缺点：无法取消 Promise ，错误需要通过回调函数来捕获"></a>缺点：无法取消 Promise ，错误需要通过回调函数来捕获</h6><h5 id="3-Generator"><a href="#3-Generator" class="headerlink" title="3. Generator"></a>3. Generator</h5><h6 id="特点：可以控制函数的执行，可以配合-co-函数库使用"><a href="#特点：可以控制函数的执行，可以配合-co-函数库使用" class="headerlink" title="特点：可以控制函数的执行，可以配合 co 函数库使用"></a>特点：可以控制函数的执行，可以配合 co 函数库使用</h6><p>  function *fetch() {<br>      yield ajax(‘XXX1’, () =&gt; {})<br>      yield ajax(‘XXX2’, () =&gt; {})<br>      yield ajax(‘XXX3’, () =&gt; {})<br>  }<br>  let it = fetch()<br>  let result1 = it.next()<br>  let result2 = it.next()<br>  let result3 = it.next()</p><h5 id="4-Async-await"><a href="#4-Async-await" class="headerlink" title="4. Async/await"></a>4. Async/await</h5><p>  async、await 是异步的终极解决方案  </p><h5 id="优点是：代码清晰，不用像-Promise-写一大堆-then-链，处理了回调地狱的问题"><a href="#优点是：代码清晰，不用像-Promise-写一大堆-then-链，处理了回调地狱的问题" class="headerlink" title="优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题"></a>优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题</h5><h5 id="缺点：await-将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用-await-会导致性能上的降低。"><a href="#缺点：await-将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用-await-会导致性能上的降低。" class="headerlink" title="缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。"></a>缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。</h5><p>  async function test() {<br>    // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式<br>    // 如果有依赖性的话，其实就是解决回调地狱的例子了<br>    await fetch(‘XXX1’)<br>    await fetch(‘XXX2’)<br>    await fetch(‘XXX3’)<br>  }</p><p>下面来看一个使用 await 的例子：</p><p>  let a = 0<br>  let b = async () =&gt; {<br>    a = a + await 10<br>    console.log(‘2’, a) // -&gt; ‘2’ 10<br>  }<br>  b()<br>  a++<br>  console.log(‘1’, a) // -&gt; ‘1’ 1</p><p>对于以上代码你可能会有疑惑，让我来解释下原因</p><p>首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来<br>因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码<br>同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10</p><p>上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js 异步已经告一段落了，这里来一波小总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>完全理解JS--arguments</title>
    <link href="http://yoursite.com/post/2019-01-02-20190106/"/>
    <id>http://yoursite.com/post/2019-01-02-20190106/</id>
    <published>2019-01-02T02:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.247Z</updated>
    
    <content type="html"><![CDATA[<p>什么是arguments?</p><a id="more"></a><h5 id="什么是arguments"><a href="#什么是arguments" class="headerlink" title="什么是arguments?"></a>什么是arguments?</h5><p>它是JS的一个内置对象，常被人们所忽略，但实际上确很重要，JS不像JAVA是显示传递参数，JS传的是形参，可以传也可以不传，若方法里没有写参数却传入了参数，该如何拿到参数呢，答案就是arguments了，在一些插件里通常这样使用。</p><p>每一个函数都有一个arguments对象，它包括了函数所要调的参数，通常我们把它当作数组使用，用它的length得到参数数量，但它却不是数组，使用instanceof查看下，若使用push添加数据将报错，代码如下：</p><p>  (function(){<br>      console.log([] instanceof Array)<br>      console.log(arguments instanceof Array)<br>      if(arguments.push) arguments.push(‘test’)<br>  })()</p><h5 id="创建一个灵活的格式化函数"><a href="#创建一个灵活的格式化函数" class="headerlink" title="创建一个灵活的格式化函数"></a>创建一个灵活的格式化函数</h5><p>上面说了arguments可以使用函数使用数量不定的参数，下面看看它的一个实际应用：</p><p>  function format(string) {<br>    var args = arguments;<br>    var pattern = new RegExp(“%([1-“ + arguments.length + “])”, “g”);<br>    return String(string).replace(pattern, function(match, index) {<br>      return args[index];<br>    });<br>  };<br>  format(“And the %1 want to know whose %2 you %3”, “papers”, “shirt”, “wear”);</p><p>这里我借用了别人的一个例子，一个模板字符串，可以使用%1到%9等9个占位符，然后提供9个参数给这些占位符，最后替换生成真正的字符串。<br>上面的代码返回：“And the papers want to know whose shirt you wear”</p><h5 id="把arguments转换成一个真正的数组"><a href="#把arguments转换成一个真正的数组" class="headerlink" title="把arguments转换成一个真正的数组"></a>把arguments转换成一个真正的数组</h5><p>有时我们希望将它转换成真正的数组使用，可以使用下面的代码：</p><p>  var args = Array.prototype.slice.call(arguments);</p><p>现在args就是一个标准的js数组了，可以使用数组的标准方法了。</p><p>  arguments允许我们去执行所有类型的js方法，下面通过一个makeFunc函数，展示了函数允许我们去提供一个函数引用和这个函数的所有参数，它将返回一个匿名函数去调用你规定的函数(就是闭包)，也提供了匿名函数调用时所附带的参数。</p><p>  function makeFunc() {<br>    var args = Array.prototype.slice.call(arguments);<br>    var func = args.shift();<br>    return function() {<br>      return func.apply(null, args.concat(Array.prototype.slice.call(arguments)));<br>    };<br>  }</p><p>第一个arguments给makeFunc提供了你调用的函数的引用，它将第一个参数从arguments数组里移除，然后makeFunc返回了一个匿名函数去运行规定的方法。<br>apply的第一个参数是函数调用的范围，主要是函数内部关联部分所指向的，这里设为null，它的arguments是一个数组，即匿名函数调用时传入的参数，匿名函数将传入的参数串联到原参数对象args里组成完整的匿名函数所需要参数。</p><p>你需要输出一个模板，总是相同位置的字符发生改变，这样就可以使用makeFunc去生成一个模板函数，传入不同的参数多次调用生成不同的内容了</p><p>  “I like js not java.”<br>  “I like java not python.”</p><p>  这样封装format是不是很酷，不过arguments还有更多惊喜。</p><h5 id="创建引用自身的函数"><a href="#创建引用自身的函数" class="headerlink" title="创建引用自身的函数"></a>创建引用自身的函数</h5><p>  arguments.callee包括了一个函数的引用去创建一个arguments对象，它能让一个匿名函数很方便的指向本身。<br>下面的Repeat是一个承载了一个函数引用和两个数字的函数，第一个数字是调用次数，第二个是间隔时间，单位毫秒。</p><p>  function repeat(fn, times, delay) {<br>    return function() {<br>      if(times– &gt; 0) {<br>        fn.apply(null, arguments);<br>        var args = Array.prototype.slice.call(arguments);<br>        var self = arguments.callee;<br>        setTimeout(function(){self.apply(null,args)}, delay);<br>      }<br>    };<br>  }</p><p>Repeat函数使用了arguments.callee方法从变量self获取一个引用，指向运行原始指令的函数。这样，匿名函数就可以再次调用自身，看看下面的调用：</p><p>  var somethingWrong = repeat(function(s){console.log(s)}, 3, 2000);<br>  somethingWrong(“Can you hear me, major tom?”);</p><p>  可以看到somethingWrong函数的结果被打印了3次，每隔2秒。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是arguments?&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ES6 使用手册</title>
    <link href="http://yoursite.com/post/2018-11-12-20181212/"/>
    <id>http://yoursite.com/post/2018-11-12-20181212/</id>
    <published>2018-11-12T00:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.240Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 使用手册</p><a id="more"></a><h5 id="1-let-和-const"><a href="#1-let-和-const" class="headerlink" title="1. let 和 const"></a>1. let 和 const</h5><p>  在我们开发的时候，可能认为应该默认使用 let 而不是 var，这种情况下，对于需要写保护的变量要使用 const。</p><p>  然而另一种做法日益普及：默认使用 const，只有当确实需要改变变量的值的时候才使用 let。这是因为大部分的变量的值在初始化后不应再改变，而预料之外的变量的修改是很多 bug 的源头。</p><pre><code>// 例子 1-1// badvar foo = &apos;bar&apos;;// goodlet foo = &apos;bar&apos;;// betterconst foo = &apos;bar&apos;;</code></pre><h5 id="2-模板字符串"><a href="#2-模板字符串" class="headerlink" title="2. 模板字符串"></a>2. 模板字符串</h5><h6 id="需要拼接字符串的时候尽量改成使用模板字符串"><a href="#需要拼接字符串的时候尽量改成使用模板字符串" class="headerlink" title="需要拼接字符串的时候尽量改成使用模板字符串:"></a>需要拼接字符串的时候尽量改成使用模板字符串:</h6><pre><code>// 例子 2-1// badconst foo = &apos;this is a&apos; + example;// goodconst foo = `this is a ${example}`;</code></pre><h6 id="2-标签模板"><a href="#2-标签模板" class="headerlink" title="2. 标签模板"></a>2. 标签模板</h6><p>  可以借助标签模板优化书写方式:</p><pre><code>let url = oneLine `    www.taobao.com/example/index.html    ?foo=${foo}    &amp;bar=${bar}`;console.log(url); // www.taobao.com/example/index.html?foo=foo&amp;bar=bar</code></pre><p>  oneLine 的源码可以参考 《ES6 系列之模板字符串》</p><h5 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3. 箭头函数"></a>3. 箭头函数</h5><p>  优先使用箭头函数，不过以下几种情况避免使用：</p><h6 id="1-使用箭头函数定义对象的方法"><a href="#1-使用箭头函数定义对象的方法" class="headerlink" title="1. 使用箭头函数定义对象的方法"></a>1. 使用箭头函数定义对象的方法</h6><pre><code>// 例子 3-1// badlet foo = {  value: 1,  getValue: () =&gt; console.log(this.value)}foo.getValue();  // undefined</code></pre><h6 id="2-定义原型方法"><a href="#2-定义原型方法" class="headerlink" title="2. 定义原型方法"></a>2. 定义原型方法</h6><pre><code>// 例子 3-2// badfunction Foo() {  this.value = 1}Foo.prototype.getValue = () =&gt; console.log(this.value)let foo = new Foo()foo.getValue();  // undefined</code></pre><h6 id="3-作为事件的回调函数"><a href="#3-作为事件的回调函数" class="headerlink" title="3. 作为事件的回调函数"></a>3. 作为事件的回调函数</h6><pre><code>// 例子 3-3// badconst button = document.getElementById(&apos;myButton&apos;);button.addEventListener(&apos;click&apos;, () =&gt; {    console.log(this === window); // =&gt; true    this.innerHTML = &apos;Clicked button&apos;;});</code></pre><h5 id="4-Symbol"><a href="#4-Symbol" class="headerlink" title="4. Symbol"></a>4. Symbol</h5><h6 id="1-唯一值"><a href="#1-唯一值" class="headerlink" title="1. 唯一值"></a>1. 唯一值</h6><pre><code>// 例子 4-1// bad// 1. 创建的属性会被 for-in 或 Object.keys() 枚举出来// 2. 一些库可能在将来会使用同样的方式，这会与你的代码发生冲突if (element.isMoving) {  smoothAnimations(element);}element.isMoving = true;// goodif (element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__) {  smoothAnimations(element);}element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = true;// bettervar isMoving = Symbol(&quot;isMoving&quot;);...if (element[isMoving]) {  smoothAnimations(element);}element[isMoving] = true;</code></pre><h6 id="2-魔术字符串"><a href="#2-魔术字符串" class="headerlink" title="2. 魔术字符串"></a>2. 魔术字符串</h6><p>  魔术字符串指的是在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。</p><p>  魔术字符串不利于修改和维护，风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p><pre><code>// 例子 4-1// badconst TYPE_AUDIO = &apos;AUDIO&apos;const TYPE_VIDEO = &apos;VIDEO&apos;const TYPE_IMAGE = &apos;IMAGE&apos;// goodconst TYPE_AUDIO = Symbol()const TYPE_VIDEO = Symbol()const TYPE_IMAGE = Symbol()function handleFileResource(resource) {  switch(resource.type) {    case TYPE_AUDIO:      playAudio(resource)      break    case TYPE_VIDEO:      playVideo(resource)      break    case TYPE_IMAGE:      previewImage(resource)      break    default:      throw new Error(&apos;Unknown type of resource&apos;)  }}</code></pre><h6 id="3-私有变量"><a href="#3-私有变量" class="headerlink" title="3. 私有变量"></a>3. 私有变量</h6><p>  Symbol 也可以用于私有变量的实现。<br>    // 例子 4-3</p><pre><code>const Example = (function() {    var _private = Symbol(&apos;private&apos;);    class Example {        constructor() {          this[_private] = &apos;private&apos;;        }        getName() {          return this[_private];        }    }    return Example;})();var ex = new Example();console.log(ex.getName()); // privateconsole.log(ex.name); // undefined</code></pre><h5 id="5-Set-和-Map"><a href="#5-Set-和-Map" class="headerlink" title="5. Set 和 Map"></a>5. Set 和 Map</h5><h6 id="1-数组去重"><a href="#1-数组去重" class="headerlink" title="1. 数组去重"></a>1. 数组去重</h6><pre><code>/ 例子 5-1[...new Set(array)]</code></pre><h6 id="2-条件语句的优化"><a href="#2-条件语句的优化" class="headerlink" title="2. 条件语句的优化"></a>2. 条件语句的优化</h6><pre><code>// 例子 5-2// 根据颜色找出对应的水果// badfunction test(color) {  switch (color) {    case &apos;red&apos;:      return [&apos;apple&apos;, &apos;strawberry&apos;];    case &apos;yellow&apos;:      return [&apos;banana&apos;, &apos;pineapple&apos;];    case &apos;purple&apos;:      return [&apos;grape&apos;, &apos;plum&apos;];    default:      return [];  }}test(&apos;yellow&apos;); // [&apos;banana&apos;, &apos;pineapple&apos;]// goodconst fruitColor = {  red: [&apos;apple&apos;, &apos;strawberry&apos;],  yellow: [&apos;banana&apos;, &apos;pineapple&apos;],  purple: [&apos;grape&apos;, &apos;plum&apos;]};function test(color) {  return fruitColor[color] || [];}// betterconst fruitColor = new Map()  .set(&apos;red&apos;, [&apos;apple&apos;, &apos;strawberry&apos;])  .set(&apos;yellow&apos;, [&apos;banana&apos;, &apos;pineapple&apos;])  .set(&apos;purple&apos;, [&apos;grape&apos;, &apos;plum&apos;]);function test(color) {  return fruitColor.get(color) || [];}</code></pre><h5 id="6-for-of"><a href="#6-for-of" class="headerlink" title="6. for of"></a>6. for of</h5><h6 id="1-遍历范围"><a href="#1-遍历范围" class="headerlink" title="1. 遍历范围"></a>1. 遍历范围</h6><p>  for…of 循环可以使用的范围包括：</p><pre><code>数组SetMap类数组对象，如 arguments 对象、DOM NodeList 对象Generator 对象字符串</code></pre><h6 id="2-优势"><a href="#2-优势" class="headerlink" title="2. 优势"></a>2. 优势</h6><p>  ES2015 引入了 for..of 循环，它结合了 forEach 的简洁性和中断循环的能力：</p><pre><code>// 例子 6-1for (const v of [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]) {  console.log(v);}// a b cfor (const [i, v] of [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].entries()) {  console.log(i, v);}// 0 &quot;a&quot;// 1 &quot;b&quot;// 2 &quot;c&quot;</code></pre><h6 id="3-遍历-Map"><a href="#3-遍历-Map" class="headerlink" title="3. 遍历 Map"></a>3. 遍历 Map</h6><pre><code>// 例子 6-2let map = new Map(arr);// 遍历 key 值for (let key of map.keys()) {  console.log(key);}// 遍历 value 值for (let value of map.values()) {  console.log(value);}// 遍历 key 和 value 值(一)for (let item of map.entries()) {  console.log(item[0], item[1]);}// 遍历 key 和 value 值(二)for (let [key, value] of data) {  console.log(key)}</code></pre><h5 id="7-Promise"><a href="#7-Promise" class="headerlink" title="7. Promise"></a>7. Promise</h5><h6 id="1-基本示例"><a href="#1-基本示例" class="headerlink" title="1. 基本示例"></a>1. 基本示例</h6><pre><code>// 例子 7-1// badrequest(url, function(err, res, body) {    if (err) handleError(err);    fs.writeFile(&apos;1.txt&apos;, body, function(err) {        request(url2, function(err, res, body) {            if (err) handleError(err)        })    })});// goodrequest(url).then(function(result) {    return writeFileAsynv(&apos;1.txt&apos;, result)}).then(function(result) {    return request(url2)}).catch(function(e){    handleError(e)});</code></pre><h6 id="2-finally"><a href="#2-finally" class="headerlink" title="2. finally"></a>2. finally</h6><pre><code>// 例子 7-2fetch(&apos;file.json&apos;).then(data =&gt; data.json()).catch(error =&gt; console.error(error)).finally(() =&gt; console.log(&apos;finished&apos;));</code></pre><h5 id="8-Async"><a href="#8-Async" class="headerlink" title="8. Async"></a>8. Async</h5><h6 id="1-代码更加简洁"><a href="#1-代码更加简洁" class="headerlink" title="1. 代码更加简洁"></a>1. 代码更加简洁</h6><pre><code>// 例子 8-1// goodfunction fetch() {  return (    fetchData()    .then(() =&gt; {      return &quot;done&quot;    });  )}// betterasync function fetch() {  await fetchData()  return &quot;done&quot;};// 例子 8-2// goodfunction fetch() {  return fetchData()  .then(data =&gt; {    if (data.moreData) {        return fetchAnotherData(data)        .then(moreData =&gt; {          return moreData        })    } else {      return data    }  });}// betterasync function fetch() {  const data = await fetchData()  if (data.moreData) {    const moreData = await fetchAnotherData(data);    return moreData  } else {    return data  }};// 例子 8-3// goodfunction fetch() {  return (    fetchData()    .then(value1 =&gt; {      return fetchMoreData(value1)    })    .then(value2 =&gt; {      return fetchMoreData2(value2)    })  )}// betterasync function fetch() {  const value1 = await fetchData()  const value2 = await fetchMoreData(value1)  return fetchMoreData2(value2)};</code></pre><h6 id="2-错误处理"><a href="#2-错误处理" class="headerlink" title="2. 错误处理"></a>2. 错误处理</h6><pre><code>// 例子 8-4// goodfunction fetch() {  try {    fetchData()      .then(result =&gt; {        const data = JSON.parse(result)      })      .catch((err) =&gt; {        console.log(err)      })  } catch (err) {    console.log(err)  }}// betterasync function fetch() {  try {    const data = JSON.parse(await fetchData())  } catch (err) {    console.log(err)  }};</code></pre><h6 id="3-“async-地狱”"><a href="#3-“async-地狱”" class="headerlink" title="3. “async 地狱”"></a>3. “async 地狱”</h6><pre><code>// 例子 8-5// bad(async () =&gt; {  const getList = await getList();  const getAnotherList = await getAnotherList();})();// good(async () =&gt; {  const listPromise = getList();  const anotherListPromise = getAnotherList();  await listPromise;  await anotherListPromise;})();// good(async () =&gt; {  Promise.all([getList(), getAnotherList()]).then(...);})();</code></pre><h5 id="9-Class"><a href="#9-Class" class="headerlink" title="9. Class"></a>9. Class</h5><h6 id="构造函数尽可能使用-Class-的形式"><a href="#构造函数尽可能使用-Class-的形式" class="headerlink" title="构造函数尽可能使用 Class 的形式"></a>构造函数尽可能使用 Class 的形式</h6><pre><code>// 例子 9-1class Foo {  static bar () {    this.baz();  }  static baz () {    console.log(&apos;hello&apos;);  }  baz () {    console.log(&apos;world&apos;);  }}Foo.bar(); // hello</code></pre><p>  // 例子 9-2<br>    class Shape {<br>      constructor(width, height) {<br>        this._width = width;<br>        this._height = height;<br>      }<br>      get area() {<br>        return this._width * this._height;<br>      }<br>    }<br>    const square = new Shape(10, 10);<br>    console.log(square.area);    // 100<br>    console.log(square._width);  // 10</p><h5 id="10-Decorator"><a href="#10-Decorator" class="headerlink" title="10.Decorator"></a>10.Decorator</h5><h6 id="1-log"><a href="#1-log" class="headerlink" title="1. log"></a>1. log</h6><pre><code>// 例子 10-1class Math {  @log  add(a, b) {    return a + b;  }}log 的实现可以参考 《ES6 系列之我们来聊聊装饰器》</code></pre><h6 id="2-autobind"><a href="#2-autobind" class="headerlink" title="2. autobind"></a>2. autobind</h6><p>  // 例子 10-2</p><pre><code>class Toggle extends React.Component {  @autobind  handleClick() {    console.log(this)  }  render() {    return (      &lt;button onClick={this.handleClick}&gt;        button      &lt;/button&gt;    );  }}autobind 的实现可以参考 《ES6 系列之我们来聊聊装饰器》###### 3. debounce// 例子 10-3class Toggle extends React.Component {  @debounce(500, true)  handleClick() {    console.log(&apos;toggle&apos;)  }  render() {    return (      &lt;button onClick={this.handleClick}&gt;        button      &lt;/button&gt;    );  }}debounce 的实现可以参考 《ES6 系列之我们来聊聊装饰器》</code></pre><h6 id="4-React-与-Redux"><a href="#4-React-与-Redux" class="headerlink" title="4. React 与 Redux"></a>4. React 与 Redux</h6><pre><code>// 例子 10-4// goodclass MyReactComponent extends React.Component {}export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);// better@connect(mapStateToProps, mapDispatchToProps)export default class MyReactComponent extends React.Component {};##### 11. 函数###### 1. 默认值// 例子 11-1// badfunction test(quantity) {  const q = quantity || 1;}// goodfunction test(quantity = 1) {  ...}// 例子 11-2doSomething({ foo: &apos;Hello&apos;, bar: &apos;Hey!&apos;, baz: 42 });// badfunction doSomething(config) {  const foo = config.foo !== undefined ? config.foo : &apos;Hi&apos;;  const bar = config.bar !== undefined ? config.bar : &apos;Yo!&apos;;  const baz = config.baz !== undefined ? config.baz : 13;}// goodfunction doSomething({ foo = &apos;Hi&apos;, bar = &apos;Yo!&apos;, baz = 13 }) {  ...}// betterfunction doSomething({ foo = &apos;Hi&apos;, bar = &apos;Yo!&apos;, baz = 13 } = {}) {  ...}// 例子 11-3// badconst Button = ({className}) =&gt; {  const classname = className || &apos;default-size&apos;;  return &lt;span className={classname}&gt;&lt;/span&gt;};// goodconst Button = ({className = &apos;default-size&apos;}) =&gt; (  &lt;span className={classname}&gt;&lt;/span&gt;);// betterconst Button = ({className}) =&gt;  &lt;span className={className}&gt;&lt;/span&gt;}Button.defaultProps = {  className: &apos;default-size&apos;}// 例子 11-4const required = () =&gt; {throw new Error(&apos;Missing parameter&apos;)};const add = (a = required(), b = required()) =&gt; a + b;add(1, 2) // 3add(1); // Error: Missing parameter.##### 12. 拓展运算符###### 1. arguments 转数组// 例子 12-1// badfunction sortNumbers() {  return Array.prototype.slice.call(arguments).sort();}// goodconst sortNumbers = (...numbers) =&gt; numbers.sort();###### 2. 调用参数// 例子 12-2// badMath.max.apply(null, [14, 3, 77])// goodMath.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77);##### 3. 构建对象剔除部分属性，将剩下的属性构建一个新的对象// 例子 12-3let [a, b, ...arr] = [1, 2, 3, 4, 5];const { a, b, ...others } = { a: 1, b: 2, c: 3, d: 4, e: 5 };</code></pre><p>  有条件的构建对象</p><pre><code>// 例子 12-4// badfunction pick(data) {  const { id, name, age} = data  const res = { guid: id }  if (name) {    res.name = name  }  else if (age) {    res.age = age  }  return res}// goodfunction pick({id, name, age}) {  return {    guid: id,    ...(name &amp;&amp; {name}),    ...(age &amp;&amp; {age})  }}</code></pre><p>  合并对象</p><pre><code>// 例子 12-5let obj1 = { a: 1, b: 2,c: 3 }let obj2 = { b: 4, c: 5, d: 6}let merged = {...obj1, ...obj2};###### 4. React</code></pre><p>  将对象全部传入组件</p><pre><code>// 例子 12-6const parmas =  {value1: 1, value2: 2, value3: 3}&lt;Test {...parmas} /&gt;##### 13. 双冒号运算符// 例子 13-1foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);</code></pre><p>  如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p><pre><code>// 例子 13-2var method = obj::obj.foo;// 等同于var method = ::obj.foo;let log = ::console.log;// 等同于var log = console.log.bind(console);</code></pre><h5 id="14-解构赋值"><a href="#14-解构赋值" class="headerlink" title="14. 解构赋值"></a>14. 解构赋值</h5><h6 id="1-对象的基本解构"><a href="#1-对象的基本解构" class="headerlink" title="1. 对象的基本解构"></a>1. 对象的基本解构</h6><pre><code>// 例子 14-1componentWillReceiveProps(newProps) {  this.setState({    active: newProps.active  })}componentWillReceiveProps({active}) {  this.setState({active})}// 例子 14-2// badhandleEvent = () =&gt; {  this.setState({    data: this.state.data.set(&quot;key&quot;, &quot;value&quot;)  })};// goodhandleEvent = () =&gt; {  this.setState(({data}) =&gt; ({    data: data.set(&quot;key&quot;, &quot;value&quot;)  }))};// 例子 14-3Promise.all([Promise.resolve(1), Promise.resolve(2)]).then(([x, y]) =&gt; {    console.log(x, y);});</code></pre><h5 id="2-对象深度解构"><a href="#2-对象深度解构" class="headerlink" title="2. 对象深度解构"></a>2. 对象深度解构</h5><pre><code>// 例子 14-4// badfunction test(fruit) {  if (fruit &amp;&amp; fruit.name)  {    console.log (fruit.name);  } else {    console.log(&apos;unknown&apos;);  }}// goodfunction test({name} = {}) {  console.log (name || &apos;unknown&apos;);}// 例子 14-5let obj = {    a: {      b: {        c: 1      }    }};const {a: {b: {c = &apos;&apos;} = &apos;&apos;} = &apos;&apos;} = obj;</code></pre><h5 id="3-数组解构"><a href="#3-数组解构" class="headerlink" title="3. 数组解构"></a>3. 数组解构</h5><pre><code>// 例子 14-6// badconst splitLocale = locale.split(&quot;-&quot;);const language = splitLocale[0];const country = splitLocale[1];// goodconst [language, country] = locale.split(&apos;-&apos;);</code></pre><h5 id="4-变量重命名"><a href="#4-变量重命名" class="headerlink" title="4. 变量重命名"></a>4. 变量重命名</h5><pre><code>// 例子 14-8let { foo: baz } = { foo: &apos;aaa&apos;, bar: &apos;bbb&apos; };console.log(baz); // &quot;aaa&quot;</code></pre><h5 id="5-仅获取部分属性"><a href="#5-仅获取部分属性" class="headerlink" title="5. 仅获取部分属性"></a>5. 仅获取部分属性</h5><pre><code>// 例子 14-9function test(input) {  return [left, right, top, bottom];}const [left, __, top] = test(input);function test(input) {  return { left, right, top, bottom };}const { left, right } = test(input);</code></pre><h4 id="15-增强的对象字面量"><a href="#15-增强的对象字面量" class="headerlink" title="15. 增强的对象字面量"></a>15. 增强的对象字面量</h4><pre><code>// 例子 15-1// badconst something = &apos;y&apos;const x = {  something: something}// goodconst something = &apos;y&apos;const x = {  something};</code></pre><p>  动态属性</p><p>  // 例子 15-2<br>  const x = {<br>    [‘a’ + ‘_’ + ‘b’]: ‘z’<br>  }<br>  console.log(x.a_b); // z</p><h5 id="16-数组的拓展方法"><a href="#16-数组的拓展方法" class="headerlink" title="16. 数组的拓展方法"></a>16. 数组的拓展方法</h5><h6 id="1-keys"><a href="#1-keys" class="headerlink" title="1. keys"></a>1. keys</h6><p>  // 例子 16-1</p><p>  var arr = [“a”, , “c”];</p><p>  var sparseKeys = Object.keys(arr);<br>  console.log(sparseKeys); // [‘0’, ‘2’]</p><p>  var denseKeys = […arr.keys()];<br>  console.log(denseKeys);  // [0, 1, 2]</p><h6 id="2-entries"><a href="#2-entries" class="headerlink" title="2. entries"></a>2. entries</h6><p>  // 例子 16-2</p><p>  var arr = [“a”, “b”, “c”];<br>  var iterator = arr.entries();</p><p>  for (let e of iterator) {<br>      console.log(e);<br>  }</p><h6 id="3-values"><a href="#3-values" class="headerlink" title="3. values"></a>3. values</h6><p>  // 例子 16-3</p><p>  let arr = [‘w’, ‘y’, ‘k’, ‘o’, ‘p’];<br>  let eArr = arr.values();</p><p>  for (let letter of eArr) {<br>    console.log(letter);<br>  }</p><h6 id="4-includes"><a href="#4-includes" class="headerlink" title="4. includes"></a>4. includes</h6><pre><code>// 例子 16-4// badfunction test(fruit) {  if (fruit == &apos;apple&apos; || fruit == &apos;strawberry&apos;) {    console.log(&apos;red&apos;);  }}// goodfunction test(fruit) {  const redFruits = [&apos;apple&apos;, &apos;strawberry&apos;, &apos;cherry&apos;, &apos;cranberries&apos;];  if (redFruits.includes(fruit)) {    console.log(&apos;red&apos;);  }}</code></pre><h6 id="5-find"><a href="#5-find" class="headerlink" title="5. find"></a>5. find</h6><pre><code>// 例子 16-5var inventory = [    {name: &apos;apples&apos;, quantity: 2},    {name: &apos;bananas&apos;, quantity: 0},    {name: &apos;cherries&apos;, quantity: 5}];function findCherries(fruit) {    return fruit.name === &apos;cherries&apos;;}console.log(inventory.find(findCherries)); // { name: &apos;cherries&apos;, quantity: 5 }</code></pre><h6 id="6-findIndex"><a href="#6-findIndex" class="headerlink" title="6. findIndex"></a>6. findIndex</h6><pre><code>// 例子 16-6function isPrime(element, index, array) {  var start = 2;  while (start &lt;= Math.sqrt(element)) {    if (element % start++ &lt; 1) {      return false;    }  }  return element &gt; 1;}console.log([4, 6, 8, 12].findIndex(isPrime)); // -1, not foundconsole.log([4, 6, 7, 12].findIndex(isPrime)); // 2</code></pre><p>  更多的就不列举了。</p><h5 id="17-optional-chaining"><a href="#17-optional-chaining" class="headerlink" title="17. optional-chaining"></a>17. optional-chaining</h5><p>  举个例子：</p><p>  // 例子 17-1</p><p>  const obj = {<br>    foo: {<br>      bar: {<br>        baz: 42,<br>      },<br>    },<br>  };</p><p>  const baz = obj?.foo?.bar?.baz; // 42</p><p>  同样支持函数：</p><pre><code>// 例子 17-2function test() {  return 42;}test?.(); // 42exists?.(); // undefined</code></pre><p>  需要添加 @babel/plugin-proposal-optional-chaining 插件支持</p><h5 id="18-logical-assignment-operators"><a href="#18-logical-assignment-operators" class="headerlink" title="18. logical-assignment-operators"></a>18. logical-assignment-operators</h5><pre><code>// 例子 18-1a ||= b;obj.a.b ||= c;a &amp;&amp;= b;obj.a.b &amp;&amp;= c;</code></pre><p>  Babel 编译为：</p><pre><code>var _obj$a, _obj$a2;a || (a = b);(_obj$a = obj.a).b || (_obj$a.b = c);a &amp;&amp; (a = b);(_obj$a2 = obj.a).b &amp;&amp; (_obj$a2.b = c);</code></pre><p>  出现的原因：</p><pre><code>// 例子 18-2function example(a = b) {  // a 必须是 undefined  if (!a) {    a = b;  }}function numeric(a = b) {  // a 必须是 null 或者 undefined  if (a == null) {    a = b;  }}// a 可以是任何 falsy 的值function example(a = b) {  // 可以，但是一定会触发 setter  a = a || b;  // 不会触发 setter，但可能会导致 lint error  a || (a = b);  // 就有人提出了这种写法：  a ||= b;}</code></pre><p>  需要 @babel/plugin-proposal-logical-assignment-operators 插件支持</p><h5 id="19-nullish-coalescing-operator"><a href="#19-nullish-coalescing-operator" class="headerlink" title="19. nullish-coalescing-operator"></a>19. nullish-coalescing-operator</h5><pre><code>a ?? b// 相当于(a !== null &amp;&amp; a !== void 0) ? a : b举个例子：var foo = object.foo ?? &quot;default&quot;;// 相当于var foo = (object.foo != null) ? object.foo : &quot;default&quot;;</code></pre><p>  需要 @babel/plugin-proposal-nullish-coalescing-operator 插件支持</p><h5 id="20-pipeline-operator"><a href="#20-pipeline-operator" class="headerlink" title="20. pipeline-operator"></a>20. pipeline-operator</h5><pre><code>const double = (n) =&gt; n * 2;const increment = (n) =&gt; n + 1;// 没有用管道操作符double(increment(double(5))); // 22// 用上管道操作符之后5 |&gt; double |&gt; increment |&gt; double; // 22</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 使用手册&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ES6 系列之迭代器与 for of</title>
    <link href="http://yoursite.com/post/2018-11-11-20181111/"/>
    <id>http://yoursite.com/post/2018-11-11-20181111/</id>
    <published>2018-11-11T00:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.234Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 系列之迭代器与 for of</p><a id="more"></a><p>起源<br>一段标准的 for 循环代码：</p><p>  var colors = [“red”, “green”, “blue”];</p><p>  for (var i = 0, len = colors.length; i &lt; len; i++) {<br>      console.log(colors[i]);<br>  }</p><p>看着很简单，但是再回顾这段代码，实际上我们仅仅是需要数组中元素的值，但是却需要提前获取数组长度，声明索引变量等，尤其当多个循环嵌套的时候，更需要使用多个索引变量，代码的复杂度就会大大增加，比如我们使用双重循环进行去重：</p><p>  function unique(array) {<br>      var res = [];<br>      for (var i = 0, arrayLen = array.length; i &lt; arrayLen; i++) {<br>          for (var j = 0, resLen = res.length; j &lt; resLen; j++) {<br>              if (array[i] === res[j]) {<br>                  break;<br>              }<br>          }<br>          if (j === resLen) {<br>              res.push(array[i]);<br>          }<br>      }<br>      return res;<br>  }</p><p>为了消除这种复杂度以及减少循环中的错误(比如错误使用其他循环中的变量)，ES6 提供了迭代器和 for of 循环共同解决这个问题。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>所谓迭代器，其实就是一个具有 next() 方法的对象，每次调用 next() 都会返回一个结果对象，该结果对象有两个属性，value 表示当前的值，done 表示遍历是否结束。</p><p>我们直接用 ES5 的语法创建一个迭代器：</p><p>  function createIterator(items) {<br>      var i = 0;<br>      return {<br>          next: function() {<br>              var done = i &gt;= item.length;<br>              var value = !done ? items[i++] : undefined;</p><pre><code>        return {            done: done,            value: value        };    }};</code></pre><p>  }</p><p>  // iterator 就是一个迭代器对象<br>  var iterator = createIterator([1, 2, 3]);</p><p>  console.log(iterator.next()); // { done: false, value: 1 }<br>  console.log(iterator.next()); // { done: false, value: 2 }<br>  console.log(iterator.next()); // { done: false, value: 3 }<br>  console.log(iterator.next()); // { done: true, value: undefined }</p><h4 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h4><p>除了迭代器之外，我们还需要一个可以遍历迭代器对象的方式，ES6 提供了 for of 语句，我们直接用 for of 遍历一下我们上节生成的遍历器对象试试：</p><p>  var iterator = createIterator([1, 2, 3]);</p><p>  for (let value of iterator) {<br>      console.log(value);<br>  }</p><p>结果报错 TypeError: iterator is not iterable，表明我们生成的 iterator 对象并不是 iterable(可遍历的)。</p><p>那什么才是可遍历的呢？</p><p>其实一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</p><p>ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是”可遍历的”（iterable）。</p><p>举个例子：</p><p>  const obj = {<br>      value: 1<br>  };</p><p>  for (value of obj) {<br>      console.log(value);<br>  }</p><p>// TypeError: iterator is not iterable<br>我们直接 for of 遍历一个对象，会报错，然而如果我们给该对象添加 Symbol.iterator 属性：</p><p>  const obj = {<br>      value: 1<br>  };</p><p>  obj[Symbol.iterator] = function() {<br>      return createIterator([1, 2, 3]);<br>  };</p><p>  for (value of obj) {<br>      console.log(value);<br>  }</p><p>  // 1<br>  // 2<br>  // 3</p><p>由此，我们也可以发现 for of 遍历的其实是对象的 Symbol.iterator 属性。</p><p>默认可遍历对象<br>然而如果我们直接遍历一个数组对象：</p><p>  const colors = [“red”, “green”, “blue”];</p><p>  for (let color of colors) {<br>      console.log(color);<br>  }</p><p>  // red<br>  // green<br>  // blue</p><p>尽管我们没有手动添加 Symbol.iterator 属性，还是可以遍历成功，这是因为 ES6 默认部署了 Symbol.iterator 属性，当然我们也可以手动修改这个属性：</p><p>  var colors = [“red”, “green”, “blue”];</p><p>  colors[Symbol.iterator] = function() {<br>      return createIterator([1, 2, 3]);<br>  };</p><p>  for (let color of colors) {<br>      console.log(color);<br>  }</p><p>  // 1<br>  // 2<br>  // 3</p><p>除了数组之外，还有一些数据结构默认部署了 Symbol.iterator 属性。</p><p>所以 for…of 循环可以使用的范围包括：</p><p>  数组<br>  Set<br>  Map<br>  类数组对象，如 arguments 对象、DOM NodeList 对象<br>  Generator 对象<br>  字符串</p><h4 id="模拟实现-for-of"><a href="#模拟实现-for-of" class="headerlink" title="模拟实现 for of"></a>模拟实现 for of</h4><p>其实模拟实现 for of 也比较简单，基本就是通过 Symbol.iterator 属性获取迭代器对象，然后使用 while 遍历一下：</p><p>  function forOf(obj, cb) {<br>      let iterable, result;</p><pre><code>if (typeof obj[Symbol.iterator] !== &quot;function&quot;)    throw new TypeError(result + &quot; is not iterable&quot;);if (typeof cb !== &quot;function&quot;) throw new TypeError(&quot;cb must be callable&quot;);iterable = obj[Symbol.iterator]();result = iterable.next();while (!result.done) {    cb(result.value);    result = iterable.next();}</code></pre><p>  }</p><p>#####　内建迭代器</p><p>为了更好的访问对象中的内容，比如有的时候我们仅需要数组中的值，但有的时候不仅需要使用值还需要使用索引，ES6 为数组、Map、Set 集合内建了以下三种迭代器：</p><p>  entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值。<br>  keys() 返回一个遍历器对象，用来遍历所有的键名。<br>  values() 返回一个遍历器对象，用来遍历所有的键值。</p><p>以数组为例：</p><p>  var colors = [“red”, “green”, “blue”];</p><p>  for (let index of colors.keys()) {<br>      console.log(index);<br>  }</p><p>  // 0<br>  // 1<br>  // 2</p><p>  for (let color of colors.values()) {<br>      console.log(color);<br>  }</p><p>  // red<br>  // green<br>  // blue</p><p>  for (let item of colors.entries()) {<br>      console.log(item);<br>  }</p><p>  // [ 0, “red” ]<br>  // [ 1, “green” ]<br>  // [ 2, “blue” ]</p><p>Map 类型与数组类似，但是对于 Set 类型需要注意以下：</p><p>  var colors = new Set([“red”, “green”, “blue”]);</p><p>  for (let index of colors.keys()) {<br>      console.log(index);<br>  }</p><p>  // red<br>  // green<br>  // blue</p><p>  for (let color of colors.values()) {<br>      console.log(color);<br>  }</p><p>  // red<br>  // green<br>  // blue</p><p>  for (let item of colors.entries()) {<br>      console.log(item);<br>  }</p><p>  // [ “red”, “red” ]<br>  // [ “green”, “green” ]<br>  // [ “blue”, “blue” ]</p><p>Set 类型的 keys() 和 values() 返回的是相同的迭代器，这也意味着在 Set 这种数据结构中键名与键值相同。</p><p>而且每个集合类型都有一个默认的迭代器，在 for-of 循环中，如果没有显式指定则使用默认的迭代器。数组和 Set 集合的默认迭代器是 values() 方法，Map 集合的默认迭代器是 entries() 方法。</p><p>这也就是为什么直接 for of 遍历 Set 和 Map 数据结构，会有不同的数据结构返回：</p><p>  const values = new Set([1, 2, 3]);</p><p>  for (let value of values) {<br>      console.log(value);<br>  }</p><p>  // 1<br>  // 2<br>  // 3</p><p>  const values = new Map([[“key1”, “value1”], [“key2”, “value2”]]);<br>  for (let value of values) {<br>      console.log(value);<br>  }</p><p>  // [“key1”, “value1”]<br>  // [“key2”, “value2”]</p><p>遍历 Map 数据结构的时候可以顺便结合解构赋值：</p><p>  const valuess = new Map([[“key1”, “value1”], [“key2”, “value2”]]);</p><p>  for (let [key, value] of valuess) {<br>      console.log(key + “:” + value);<br>  }</p><p>  // key1:value1<br>  // key2:value2</p><p>Babel 是如何编译 for of 的<br>我们可以在 Babel 的 Try it out 中查看编译的结果：</p><p>  const colors = new Set([“red”, “green”, “blue”]);</p><p>  for (let color of colors) {<br>      console.log(color);<br>  }</p><p>对于这样一段代码，编译的结果如下：</p><p>  “use strict”;</p><p>  var colors = new Set([“red”, “green”, “blue”]);</p><p>  var _iteratorNormalCompletion = true;<br>  var _didIteratorError = false;<br>  var _iteratorError = undefined;</p><p>  try {<br>      for (<br>          var _iterator = colors<a href>Symbol.iterator</a>, _step;<br>          !(_iteratorNormalCompletion = (_step = _iterator.next()).done);<br>          _iteratorNormalCompletion = true<br>      ) {<br>          var color = _step.value;</p><pre><code>    console.log(color);}</code></pre><p>  } catch (err) {<br>      _didIteratorError = true;<br>      _iteratorError = err;<br>  } finally {<br>      try {<br>          if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {<br>              _iterator.return();<br>          }<br>      } finally {<br>          if (_didIteratorError) {<br>              throw _iteratorError;<br>          }<br>      }<br>  }</p><p>至少由编译的结果可以看出，使用 for of 循环的背后，还是会使用 Symbol.iterator 接口。</p><p>而这段编译的代码稍微复杂的地方有两段，一段是 for 循环这里：</p><p>  for (<br>      var _iterator = colors<a href>Symbol.iterator</a>, _step;<br>      !(_iteratorNormalCompletion = (_step = _iterator.next()).done);<br>      _iteratorNormalCompletion = true<br>  ) {<br>      var color = _step.value;<br>      console.log(color);<br>  }</p><p>跟标准的 for 循环写法有些差别，我们看下 for 语句的语法：</p><p>  for (initialize; test; increment) statement;<br>  initialize、test 和 increment 三个表达式之间用分号分割，它们分别负责初始化操作、循环条件判断和计数器变量的更新。</p><p>  for 语句其实就相当于：</p><p>  initialize;<br>  while (test) {<br>      statement;<br>      increment;<br>  }</p><p>代码的逻辑为：先进行初始化，然后每次循环执行之前会执行 test 表达式，并判断表达式的结果来决定是否执行循环体，如果 test 计算结果为真值，则执行循环体中的 statement。最后，执行 increment 表达式。</p><p>而且值得注意的是，其实 for 循环中的三个表达式中任意一个都可以被忽略，不过分号还是要写的。</p><p>比如 for(;;)，不过这就是一个死循环……</p><p>比如：</p><p>  var i = 0,<br>      len = colors.length;<br>  for (; i &lt; len; i++) {<br>      console.log(colors[i]);<br>  }</p><p>又比如：</p><p>  var i = 0,<br>      len = colors.length;<br>  for (; i &lt; len; ) {<br>      i++;<br>  }</p><p>然后我们再来看 Babel 编译的这个 for 循环表达式：</p><p>  for (<br>      var _iterator = colors<a href>Symbol.iterator</a>, _step;<br>      !(_iteratorNormalCompletion = (_step = _iterator.next()).done);<br>      _iteratorNormalCompletion = true<br>  ) {<br>      var color = _step.value;<br>      console.log(color);<br>  }</p><p>用 while 的写法相当于：</p><p>  var _iterator = colors<a href>Symbol.iterator</a>,<br>      _step;<br>  while (!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) {<br>      var color = _step.value;<br>      console.log(color);<br>      _iteratorNormalCompletion = true;<br>  }</p><p>是不是就好懂了很多呢，然后你就会发现，其实 _iteratorNormalCompletion = true 这句是完全没有必要的……</p><p>另外一段稍微复杂的代码是:</p><p>  try {<br>    …<br>  } catch (err) {<br>    …<br>  } finally {<br>    try {<br>      if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {<br>        _iterator.return();<br>      }<br>    } finally {<br>      …<br>    }<br>  }</p><p>因为 _iteratorNormalCompletion = (_step = _iterator.next()).done，所以 _iteratorNormalCompletion 表示的就是是否完成了一次完整的迭代过程，如果没有正常的迭代完成，并且迭代器有 return 方法时，就会执行该方法。</p><p>而之所以这么做，就要提到迭代器的 return 方法。</p><p>引用阮一峰老师的 ECMAScript 6 入门:</p><p>遍历器对象除了具有 next 方法，还可以具有 return 方法和 throw 方法。如果你自己写遍历器对象生成函数，那么 next 方法是必须部署的，return 方法和 throw 方法是否部署是可选的。</p><p>return 方法的使用场合是，如果 for…of 循环提前退出（通常是因为出错，或者有 break 语句或 continue 语句），就会调用 return 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 return 方法。</p><p>我们可以举个例子：</p><p>  function createIterator(items) {<br>      var i = 0;<br>      return {<br>          next: function() {<br>              var done = i &gt;= items.length;<br>              var value = !done ? items[i++] : undefined;</p><pre><code>        return {            done: done,            value: value        };    },    return: function() {        console.log(&quot;执行了 return 方法&quot;);        return {            value: 23333,            done: true        };    }};</code></pre><p>  }</p><p>  var colors = [“red”, “green”, “blue”];</p><p>  var iterator = createIterator([1, 2, 3]);</p><p>  colors[Symbol.iterator] = function() {<br>      return iterator;<br>  };</p><p>  for (let color of colors) {<br>      if (color == 1) break;<br>      console.log(color);<br>  }</p><p>// 执行了 return 方法<br>不过正如你在编译后的代码中看到，仅仅是在有 return 函数的时候执行了 return 函数而已，return 函数中返回的值其实并不生效……</p><p>但是你不返回值或者返回一个基本类型的值的话，结果又会报错……</p><p>TypeError: Iterator result undefined is not an object<br>这是因为 return 方法必须返回一个对象，而这又是 Generator 规范决定的……</p><p>总之如果是在浏览器中使用的话，return 函数的返回值其实并不生效</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 系列之迭代器与 for of&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ES6 系列之箭头函数</title>
    <link href="http://yoursite.com/post/2018-11-05-20181105/"/>
    <id>http://yoursite.com/post/2018-11-05-20181105/</id>
    <published>2018-11-05T00:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.215Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 系列之箭头函数</p><a id="more"></a><h5 id="我们重点比较一下箭头函数与普通函数。"><a href="#我们重点比较一下箭头函数与普通函数。" class="headerlink" title="我们重点比较一下箭头函数与普通函数。"></a>我们重点比较一下箭头函数与普通函数。</h5><h4 id="1-没有-this"><a href="#1-没有-this" class="headerlink" title="1.没有 this"></a>1.没有 this</h4><h5 id="箭头函数没有-this，所以需要通过查找作用域链来确定-this-的值。"><a href="#箭头函数没有-this，所以需要通过查找作用域链来确定-this-的值。" class="headerlink" title="箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。"></a>箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。</h5><p>这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。</p><p>模拟一个实际开发中的例子：</p><p>我们的需求是点击一个按钮，改变该按钮的背景色。</p><p>为了方便开发，我们抽离一个 Button 组件，当需要使用的时候，直接：</p><p>  // 传入元素 id 值即可绑定该元素点击时改变背景色的事件<br>  new Button(“button”)<br>  HTML 代码如下：</p><p>  <button id="button">点击变色</button><br>  JavaScript 代码如下：</p><p>  function Button(id) {<br>      this.element = document.querySelector(“#” + id);<br>      this.bindEvent();<br>  }</p><p>  Button.prototype.bindEvent = function() {<br>      this.element.addEventListener(“click”, this.setBgColor, false);<br>  };</p><p>  Button.prototype.setBgColor = function() {<br>      this.element.style.backgroundColor = ‘#1abc9c’<br>  };</p><p>var button = new Button(“button”);<br>看着好像没有问题，结果却是报错 Uncaught TypeError: Cannot read property ‘style’ of undefined</p><p>这是因为当使用 addEventListener() 为一个元素注册事件的时候，事件函数里的 this 值是该元素的引用。</p><p>所以如果我们在 setBgColor 中 console.log(this)，this 指向的是按钮元素，那 this.element 就是 undefined，报错自然就理所当然了。</p><p>也许你会问，既然 this 都指向了按钮元素，那我们直接修改 setBgColor 函数为：</p><p>  Button.prototype.setBgColor = function() {<br>      this.style.backgroundColor = ‘#1abc9c’<br>  };</p><p>不就可以解决这个问题了？</p><p>确实可以这样做，但是在实际的开发中，我们可能会在 setBgColor 中还调用其他的函数，比如写成这种：</p><p>  Button.prototype.setBgColor = function() {<br>      this.setElementColor();<br>      this.setOtherElementColor();<br>  };</p><p>所以我们还是希望 setBgColor 中的 this 是指向实例对象的，这样就可以调用其他的函数。</p><p>利用 ES5，我们一般会这样做：</p><p>  Button.prototype.bindEvent = function() {<br>      this.element.addEventListener(“click”, this.setBgColor.bind(this), false);<br>  };</p><p>为避免 addEventListener 的影响，使用 bind 强制绑定 setBgColor() 的 this 为实例对象</p><p>使用 ES6，我们可以更好的解决这个问题：</p><p>  Button.prototype.bindEvent = function() {<br>      this.element.addEventListener(“click”, event =&gt; this.setBgColor(event), false);<br>  };</p><p>由于箭头函数没有 this，所以会向外层查找 this 的值，即 bindEvent 中的 this，此时 this 指向实例对象，所以可以正确的调用 this.setBgColor 方法， 而 this.setBgColor 中的 this 也会正确指向实例对象。</p><p>在这里再额外提一点，就是注意 bindEvent 和 setBgColor 在这里使用的是普通函数的形式，而非箭头函数，如果我们改成箭头函数，会导致函数里的 this 指向 window 对象 (非严格模式下)。</p><p>最后，因为箭头函数没有 this，所以也不能用 call()、apply()、bind() 这些方法改变 this 的指向，可以看一个例子：</p><p>  var value = 1;<br>  var result = (() =&gt; this.value).bind({value: 2})();<br>  console.log(result); // 1</p><h4 id="2-没有-arguments"><a href="#2-没有-arguments" class="headerlink" title="2. 没有 arguments"></a>2. 没有 arguments</h4><h5 id="箭头函数没有自己的-arguments-对象，这不一定是件坏事，因为箭头函数可以访问外围函数的-arguments-对象："><a href="#箭头函数没有自己的-arguments-对象，这不一定是件坏事，因为箭头函数可以访问外围函数的-arguments-对象：" class="headerlink" title="箭头函数没有自己的 arguments 对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象："></a>箭头函数没有自己的 arguments 对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象：</h5><p>  function constant() {<br>      return () =&gt; arguments[0]<br>  }</p><p>  var result = constant(1);<br>  console.log(result()); // 1</p><p>那如果我们就是要访问箭头函数的参数呢？</p><p>你可以通过命名参数或者 rest 参数的形式访问参数:</p><p>  let nums = (…nums) =&gt; nums;</p><h4 id="3-不能通过-new-关键字调用"><a href="#3-不能通过-new-关键字调用" class="headerlink" title="3. 不能通过 new 关键字调用"></a>3. 不能通过 new 关键字调用</h4><p>JavaScript 函数有两个内部方法：[[Call]] 和 [[Construct]]。</p><p>当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。</p><p>当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。</p><p>箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。</p><p>  var Foo = () =&gt; {};<br>  var foo = new Foo(); // TypeError: Foo is not a constructor</p><h4 id="4-没有-new-target"><a href="#4-没有-new-target" class="headerlink" title="4. 没有 new.target"></a>4. 没有 new.target</h4><p>因为不能使用 new 调用，所以也没有 new.target 值。</p><p>关于 new.target，可以参考 <a href="http://es6.ruanyifeng.com/#docs/class#new-target-%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/class#new-target-%E5%B1%9E%E6%80%A7</a></p><h4 id="5-没有原型"><a href="#5-没有原型" class="headerlink" title="5. 没有原型"></a>5. 没有原型</h4><p>由于不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性。</p><p>var Foo = () =&gt; {};<br>console.log(Foo.prototype); // undefined</p><h4 id="6-没有-super"><a href="#6-没有-super" class="headerlink" title="6. 没有 super"></a>6. 没有 super</h4><p>连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 系列之箭头函数&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ES6 系列之 let 和 const</title>
    <link href="http://yoursite.com/post/2018-11-01-20181101/"/>
    <id>http://yoursite.com/post/2018-11-01-20181101/</id>
    <published>2018-11-01T00:23:18.000Z</published>
    <updated>2020-03-10T01:17:54.210Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 系列之 let 和 const</p><a id="more"></a><h5 id="块级作用域的出现"><a href="#块级作用域的出现" class="headerlink" title="块级作用域的出现"></a>块级作用域的出现</h5><p>通过 var 声明的变量存在变量提升的特性：</p><pre><code>if (condition) {    var value = 1;}console.log(value);</code></pre><p>初学者可能会觉得只有 condition 为 true 的时候，才会创建 value，如果 condition 为 false，结果应该是报错，然而因为变量提升的原因，代码相当于：</p><pre><code>var value;if (condition) {    value = 1;}console.log(value);</code></pre><p>如果 condition 为 false，结果会是 undefined。</p><p>除此之外，在 for 循环中：</p><pre><code>for (var i = 0; i &lt; 10; i++) {    ...}console.log(i); // 10</code></pre><p>即便循环已经结束了，我们依然可以访问 i 的值。</p><p>为了加强对变量生命周期的控制，ECMAScript 6 引入了块级作用域。</p><p>块级作用域存在于：</p><p>函数内部<br>块中(字符 { 和 } 之间的区域)</p><h5 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h5><p>块级声明用于声明在指定块的作用域之外无法访问的变量。</p><p>let 和 const 都是块级声明的一种。</p><p>我们来回顾下 let 和 const 的特点：</p><h6 id="1-不会被提升"><a href="#1-不会被提升" class="headerlink" title="1.不会被提升"></a>1.不会被提升</h6><pre><code>if (false) {    let value = 1;}console.log(value); // Uncaught ReferenceError: value is not defined</code></pre><h6 id="2-重复声明报错"><a href="#2-重复声明报错" class="headerlink" title="2.重复声明报错"></a>2.重复声明报错</h6><pre><code>var value = 1;let value = 2; // Uncaught SyntaxError: Identifier &apos;value&apos; has already been declared</code></pre><h6 id="3-不绑定全局作用域"><a href="#3-不绑定全局作用域" class="headerlink" title="3.不绑定全局作用域"></a>3.不绑定全局作用域</h6><p>当在全局作用域中使用 var 声明的时候，会创建一个新的全局变量作为全局对象的属性。</p><pre><code>var value = 1;console.log(window.value); // 1</code></pre><p>然而 let 和 const 不会：</p><pre><code>let value = 1;console.log(window.value); // undefined</code></pre><p>再来说下 let 和 const 的区别：</p><p>const 用于声明常量，其值一旦被设定不能再被修改，否则会报错。</p><p>值得一提的是：const 声明不允许修改绑定，但允许修改值。这意味着当用 const 声明对象时：</p><pre><code>const data = {    value: 1}// 没有问题data.value = 2;data.num = 3;// 报错data = {}; // Uncaught TypeError: Assignment to constant variable.</code></pre><h5 id="临时死区"><a href="#临时死区" class="headerlink" title="临时死区"></a>临时死区</h5><p>临时死区(Temporal Dead Zone)，简写为 TDZ。</p><p>let 和 const 声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，会导致报错：</p><p>console.log(typeof value); // Uncaught ReferenceError: value is not defined<br>let value = 1;<br>这是因为 JavaScript 引擎在扫描代码发现变量声明时，要么将它们提升到作用域顶部(遇到 var 声明)，要么将声明放在 TDZ 中(遇到 let 和 const 声明)。访问 TDZ 中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从 TDZ 中移出，然后方可访问。</p><p>看似很好理解，不保证你不犯错：</p><pre><code>var value = &quot;global&quot;;// 例子1(function() {    console.log(value);    let value = &apos;local&apos;;}());// 例子2{    console.log(value);    const value = &apos;local&apos;;};</code></pre><p>两个例子中，结果并不会打印 “global”，而是报错 Uncaught ReferenceError: value is not defined，就是因为 TDZ 的缘故。</p><p>如果let声明的变量没有变量提升，应该打印’global’；而它却报错，说明它是提升了的，只是规定了不能在其声明之前使用而已。我们称这特性叫“暂时性死区（temporal dead zone）”。且这一特性，仅对遵循‘块级作用域’的命令有效（let、const）。</p><p>循环中的块级作用域</p><pre><code>var funcs = [];for (var i = 0; i &lt; 3; i++) {    funcs[i] = function () {        console.log(i);    };}funcs[0](); // 3</code></pre><p>一个老生常谈的面试题，解决方案如下：</p><pre><code>var funcs = [];for (var i = 0; i &lt; 3; i++) {    funcs[i] = (function(i){        return function() {            console.log(i);        }    }(i))}funcs[0](); // 0</code></pre><p>ES6 的 let 为这个问题提供了新的解决方法：</p><pre><code>var funcs = [];for (let i = 0; i &lt; 3; i++) {    funcs[i] = function () {        console.log(i);    };}funcs[0](); // 0</code></pre><p>问题在于，上面讲了 let 不提升，不能重复声明，不能绑定全局作用域等等特性，可是为什么在这里就能正确打印出 i 值呢？</p><p>如果是不重复声明，在循环第二次的时候，又用 let 声明了 i，应该报错呀，就算因为某种原因，重复声明不报错，一遍一遍迭代，i 的值最终还是应该是 3 呀，还有人说 for 循环的<br>设置循环变量的那部分是一个单独的作用域，就比如：</p><pre><code>for (let i = 0; i &lt; 3; i++) {  let i = &apos;abc&apos;;  console.log(i);}// abc// abc// abc</code></pre><p>这个例子是对的，如果我们把 let 改成 var 呢？</p><pre><code>for (var i = 0; i &lt; 3; i++) {  var i = &apos;abc&apos;;  console.log(i);}// abc</code></pre><p>为什么结果就不一样了呢，如果有单独的作用域，结果应该是相同的呀……</p><p>总结：<br><a href="https://www.cnblogs.com/moumoon/p/10985250.html" target="_blank" rel="noopener">https://www.cnblogs.com/moumoon/p/10985250.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 系列之 let 和 const&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>浏览器 - 重绘和回流</title>
    <link href="http://yoursite.com/post/2018-10-03-20181003/"/>
    <id>http://yoursite.com/post/2018-10-03-20181003/</id>
    <published>2018-10-03T04:13:18.000Z</published>
    <updated>2020-03-10T01:17:54.196Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器采用流式布局模型（Flow Based Layout）<br>浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了渲染树（Render Tree）。<br>有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。<br>由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。</p><a id="more"></a><h5 id="1、浏览器渲染机制"><a href="#1、浏览器渲染机制" class="headerlink" title="1、浏览器渲染机制"></a>1、浏览器渲染机制</h5><p>浏览器采用流式布局模型（Flow Based Layout）<br>浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了渲染树（Render Tree）。<br>有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。<br>由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。</p><h5 id="2、-重绘"><a href="#2、-重绘" class="headerlink" title="2、 重绘"></a>2、 重绘</h5><p>由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如outline, visibility, color、background-color等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。</p><h5 id="3、回流"><a href="#3、回流" class="headerlink" title="3、回流"></a>3、回流</h5><p>回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。</p>  <body>  <div class="error">      <h4>我的组件</h4>      <p><strong>错误：</strong>错误的描述…</p>      <h5>错误纠正</h5>      <ol>          <li>第一步</li>          <li>第二步</li>      </ol>  </div>  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body><p>在上面的HTML片段中，对该段落(</p><p>标签)回流将会引发强烈的回流，因为它是一个子节点。这也导致了祖先的回流（div.error和body – 视浏览器而定）。此外，</p><h5>和<ol>也会有简单的回流，因为其在DOM中在回流元素之后。大部分的回流将导致页面的重新渲染。<p></p><h6 id="4、浏览器优化"><a href="#4、浏览器优化" class="headerlink" title="4、浏览器优化"></a>4、浏览器优化</h6><p>现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。<br>主要包括以下属性或方法：</p><pre><code>offsetTop、offsetLeft、offsetWidth、offsetHeightscrollTop、scrollLeft、scrollWidth、scrollHeightclientTop、clientLeft、clientWidth、clientHeightwidth、heightgetComputedStyle()getBoundingClientRect()</code></pre><p>所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。</p><h5 id="5、减少重绘与回流"><a href="#5、减少重绘与回流" class="headerlink" title="5、减少重绘与回流"></a>5、减少重绘与回流</h5><h6 id="1、CSS"><a href="#1、CSS" class="headerlink" title="1、CSS"></a>1、CSS</h6><p>使用 transform 替代 top</p><p>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局</p><p>避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。</p><p>尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。</p><p>避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。</p>  <div>    <a> <span></span> </a>  </div>  <style>    span {      color: red;    }    div > a > span {      color: red;    }  </style><p>对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平。</p><p>将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。</p><p>避免使用CSS表达式，可能会引发回流。</p><p>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。</p><p>CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</p><h6 id="2、JavaScript"><a href="#2、JavaScript" class="headerlink" title="2、JavaScript"></a>2、JavaScript</h6><p>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</p><p>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</p><p>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</p><p>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</p></ol></h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器采用流式布局模型（Flow Based Layout）&lt;br&gt;浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了渲染树（Render Tree）。&lt;br&gt;有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。&lt;br&gt;由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器 - 缓存机制</title>
    <link href="http://yoursite.com/post/2018-10-01-20181001/"/>
    <id>http://yoursite.com/post/2018-10-01-20181001/</id>
    <published>2018-10-01T02:23:18.000Z</published>
    <updated>2020-03-09T01:44:46.458Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说,浏览器缓存其实就是浏览器保存通过HTTP获取的所有资源,是浏览器将网络资源存储在本地的一种行为</p><a id="more"></a><h5 id="Service-Worker-Cache"><a href="#Service-Worker-Cache" class="headerlink" title="Service Worker Cache"></a>Service Worker Cache</h5><p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p><p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</p><p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p><p>Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，算是幕后工作，可以实现离线缓存，网络代理等</p><p>  window.navigator.serviceWorker.register(‘/kaikeba.js’).then(<br>    function () {<br>      console.log(‘注册成功’)<br>    }).catch(err =&gt; {<br>      console.error(“注册失败”)<br>  })</p><h5 id="memory-cache"><a href="#memory-cache" class="headerlink" title="memory cache"></a>memory cache</h5><p>Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p><p>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？<br>这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。</p><p>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</p><p>内存缓存中有一块重要的缓存资源是preloader相关指令（例如<link rel="prefetch">）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。</p><p>需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。</p><h5 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h5><p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。</p><p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。</p><p>浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？<br>关于这点，网上说法不一，不过以下观点比较靠得住：</p><p>对于大文件来说，大概率是不存储在内存中的，反之优先<br>当前系统内存使用率高的话，文件优先存储进硬盘</p><h5 id="push-cache"><a href="#push-cache" class="headerlink" title="push cache"></a>push cache</h5><p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</p><p>Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读Jake Archibald的 HTTP/2 push is tougher than I thought 这篇文章，文章中的几个结论：</p><p>所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差<br>可以推送 no-cache 和 no-store 的资源<br>一旦连接被关闭，Push Cache 就被释放<br>多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。<br>Push Cache 中的缓存只能被使用一次<br>浏览器可以拒绝接受已经存在的资源推送<br>你可以给其他域名推送资源</p><h6 id="如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。"><a href="#如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。" class="headerlink" title="如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。"></a>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</h6><p>那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的</p><h4 id="三、缓存过程分析"><a href="#三、缓存过程分析" class="headerlink" title="三、缓存过程分析"></a>三、缓存过程分析</h4><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的</p><p>由上图我们可以知道：</p><p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</p><p>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p><p>以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。</p><h4 id="四、强缓存"><a href="#四、强缓存" class="headerlink" title="四、强缓存"></a>四、强缓存</h4><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。</p><h6 id="1-Expires"><a href="#1-Expires" class="headerlink" title="1.Expires"></a>1.Expires</h6><p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><p>Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018</p><h6 id="2、Cache-Control"><a href="#2、Cache-Control" class="headerlink" title="2、Cache-Control"></a>2、Cache-Control</h6><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p><p>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：</p><p>public：所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如 Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。</p><p>private：所有内容只有客户端可以缓存，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。</p><p>no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</p><p>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p><p>max-age：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效</p><p>s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。</p><p>max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。</p><p>min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。</p><p><img src="http://github.com/unicorn.png" alt="github" title="github">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单来说,浏览器缓存其实就是浏览器保存通过HTTP获取的所有资源,是浏览器将网络资源存储在本地的一种行为&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解vue中的slot与slot-scope</title>
    <link href="http://yoursite.com/post/2018-09-21-20180921/"/>
    <id>http://yoursite.com/post/2018-09-21-20180921/</id>
    <published>2018-09-21T12:48:18.000Z</published>
    <updated>2020-03-09T01:44:46.427Z</updated>
    
    <content type="html"><![CDATA[<p>单个插槽 | 默认插槽 | 匿名插槽</p><a id="more"></a><h2 id="单个插槽"><a href="#单个插槽" class="headerlink" title="单个插槽"></a>单个插槽</h2><p>首先是单个插槽，单个插槽是vue的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置name属性。<br>单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（name属性）不同就可以了。</p><p>下面通过一个例子来展示。</p><p>父组件：</p><pre><code>&lt;template&gt;    &lt;div class=&quot;father&quot;&gt;        &lt;h3&gt;这里是父组件&lt;/h3&gt;        &lt;child&gt;            &lt;div class=&quot;tmpl&quot;&gt;            &lt;span&gt;菜单1&lt;/span&gt;            &lt;span&gt;菜单2&lt;/span&gt;            &lt;span&gt;菜单3&lt;/span&gt;            &lt;span&gt;菜单4&lt;/span&gt;            &lt;span&gt;菜单5&lt;/span&gt;            &lt;span&gt;菜单6&lt;/span&gt;            &lt;/div&gt;        &lt;/child&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><p>子组件：</p><pre><code>&lt;template&gt;    &lt;div class=&quot;child&quot;&gt;        &lt;h3&gt;这里是子组件&lt;/h3&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>匿名插槽没有name属性，所以是匿名插槽，那么，插槽加了name属性，就变成了具名插槽。具名插槽可以在一个组件中出现N次，出现在不同的位置。下面的例子，就是一个有两个具名插槽和单个插槽的组件，这三个插槽被父组件用同一套css样式显示了出来，不同的是内容上略有区别。</p><p>父组件：</p><pre><code>&lt;template&gt;&lt;div class=&quot;father&quot;&gt;    &lt;h3&gt;这里是父组件&lt;/h3&gt;    &lt;child&gt;    &lt;div class=&quot;tmpl&quot; slot=&quot;up&quot;&gt;        &lt;span&gt;菜单1&lt;/span&gt;        &lt;span&gt;菜单2&lt;/span&gt;        &lt;span&gt;菜单3&lt;/span&gt;        &lt;span&gt;菜单4&lt;/span&gt;        &lt;span&gt;菜单5&lt;/span&gt;        &lt;span&gt;菜单6&lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;tmpl&quot; slot=&quot;down&quot;&gt;        &lt;span&gt;菜单-1&lt;/span&gt;        &lt;span&gt;菜单-2&lt;/span&gt;        &lt;span&gt;菜单-3&lt;/span&gt;        &lt;span&gt;菜单-4&lt;/span&gt;        &lt;span&gt;菜单-5&lt;/span&gt;        &lt;span&gt;菜单-6&lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;tmpl&quot;&gt;        &lt;span&gt;菜单-&gt;1&lt;/span&gt;        &lt;span&gt;菜单-&gt;2&lt;/span&gt;        &lt;span&gt;菜单-&gt;3&lt;/span&gt;        &lt;span&gt;菜单-&gt;4&lt;/span&gt;        &lt;span&gt;菜单-&gt;5&lt;/span&gt;        &lt;span&gt;菜单-&gt;6&lt;/span&gt;    &lt;/div&gt;    &lt;/child&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><p>子组件：</p><pre><code>&lt;template&gt;    &lt;div class=&quot;child&quot;&gt;        // 具名插槽        &lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;        &lt;h3&gt;这里是子组件&lt;/h3&gt;        // 具名插槽        &lt;slot name=&quot;down&quot;&gt;&lt;/slot&gt;        // 匿名插槽        &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="作用域插槽-带数据的插槽"><a href="#作用域插槽-带数据的插槽" class="headerlink" title="作用域插槽 | 带数据的插槽"></a>作用域插槽 | 带数据的插槽</h2><p>最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的template里面写</p><pre><code>匿名插槽&lt;slot&gt;&lt;/slot&gt;具名插槽&lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;</code></pre><p>但是作用域插槽要求，在slot上面绑定数据。也就是你得写成大概下面这个样子。</p><pre><code>&lt;slot name=&quot;up&quot; :data=&quot;data&quot;&gt;&lt;/slot&gt;export default {    data: function(){    return {        data: [&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wanwu&apos;,&apos;zhaoliu&apos;,&apos;tianqi&apos;,&apos;xiaoba&apos;]    }    },}</code></pre><p>我们前面说了，插槽最后显示不显示是看父组件有没有在child下面写模板，像下面那样。</p><pre><code>&lt;child&gt;html模板&lt;/child&gt;</code></pre><p>写了，插槽就总得在浏览器上显示点东西，东西就是html该有的模样，没写，插槽就是空壳子，啥都没有。OK，我们说有html模板的情况，就是父组件会往子组件插模板的情况，那到底插一套什么样的样式呢，这由父组件的html+css共同决定，但是这套样式里面的内容呢？</p><p>正因为作用域插槽绑定了一套数据，父组件可以拿来用。于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。</p><p>我们再来对比，作用域插槽跟单个插槽和具名插槽的区别，因为单个插槽和具名插槽不绑定数据，所以父组件提供的模板一般要既包括样式又包括内容，上面的例子中，你看到的文字，“菜单1”，“菜单2”都是父组件自己提供的内容；而作用域插槽，父组件只需要提供一套样式（在确实用作用域插槽绑定的数据的前提下）。</p><p>下面的例子，你就能看到，父组件提供了三种样式(分别是flex、ul、直接显示)，都没有提供数据，数据使用的都是子组件插槽自己绑定的那个数组（一堆人名的那个数组）。</p><pre><code>&lt;template&gt;    &lt;div class=&quot;father&quot;&gt;        &lt;h3&gt;这里是父组件&lt;/h3&gt;        &lt;!--第一次使用：用flex展示数据--&gt;        &lt;child&gt;        &lt;template slot-scope=&quot;user&quot;&gt;            &lt;div class=&quot;tmpl&quot;&gt;            &lt;span v-for=&quot;item in user.data&quot;&gt;{{item}}&lt;/span&gt;            &lt;/div&gt;        &lt;/template&gt;        &lt;/child&gt;        &lt;!--第二次使用：用列表展示数据--&gt;        &lt;child&gt;        &lt;template slot-scope=&quot;user&quot;&gt;            &lt;ul&gt;            &lt;li v-for=&quot;item in user.data&quot;&gt;{{item}}&lt;/li&gt;            &lt;/ul&gt;        &lt;/template&gt;        &lt;/child&gt;        &lt;!--第三次使用：直接显示数据--&gt;        &lt;child&gt;        &lt;template slot-scope=&quot;user&quot;&gt;        {{user.data}}        &lt;/template&gt;        &lt;/child&gt;        &lt;!--第四次使用：不使用其提供的数据, 作用域插槽退变成匿名插槽--&gt;        &lt;child&gt;        我就是模板        &lt;/child&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单个插槽 | 默认插槽 | 匿名插槽&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex的state，actions，getters，mutations的使用</title>
    <link href="http://yoursite.com/post/2018-09-19-20180919/"/>
    <id>http://yoursite.com/post/2018-09-19-20180919/</id>
    <published>2018-09-19T12:48:18.000Z</published>
    <updated>2020-03-09T01:44:46.395Z</updated>
    
    <content type="html"><![CDATA[<p>vuex的state，actions，getters，mutations的使用 分为两种情况，有module和没有mudule</p><a id="more"></a><p>##有module</p><p>###看getters，有四种写法</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;getUserName()&quot;&gt;      点击获取用户名    &lt;/button&gt;    &lt;div&gt;获取到的用户名：{{userName}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import {mapGetters} from &apos;vuex&apos;  export default {    name: &quot;login&quot;,    data: function () {      return {        userName: &apos;&apos;,      }    },    methods:{      getUserName:function(){        /**         *  调用getters有四种方法         *  第一种：this.userName = this.gettersName ，需要在computed中写...mapGetters         *  第二种：this.userName = this[&apos;gettersName&apos;] ，需要在computed中写...mapGetters         *  第三种：this.userName = this.$store.getters.gettersName，直接调用getters.js中的gettersName方法，不需要mapGetters         *  第四种：this.userName = this.$store.getters[&apos;gettersName&apos;]，直接调用getters.js中的gettersName方法，不需要mapGetters         */        console.log(&apos;没有module的getters：&apos;+JSON.stringify(this.$store.getters))//{&quot;gettersName&quot;:&quot;111&quot;}        this.userName = this.$store.getters[&apos;gettersName&apos;]      }    },    computed: {      ...mapGetters([        &apos;gettersName&apos;      ])    },  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>###actions有三种写法：</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;input type=&quot;number&quot; v-model=&quot;userName&quot; placeholder=&quot;请输入用户名&quot; /&gt;    &lt;div @click=&apos;loginClick()&apos;&gt; 登录&lt;/div&gt;    &lt;div&gt;{{test}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import { mapActions } from &apos;vuex&apos;  export default {    name: &quot;login&quot;,    data:function () {      return{        userName:&apos;&apos;,      }    },    methods:{      ...mapActions([        &apos;setActionName&apos;      ]),      loginClick:function () {        /**         *  调用actions有三种方法         *  第一种：this.setActionName(this.userName)，需要在methods中写...mapActions         *  第二种：this[&apos;setActionName&apos;](this.userName)，需要在methods中写...mapActions         *  第三种：this.$store.dispatch(&apos;setActionName&apos;,this.userName)，直接调用actions.js中的setActionName方法，不需要mapActions         */        this.$store.dispatch(&apos;setActionName&apos;,this.userName)      },    },    computed:{      test(){        return this.$store.state.name;      }    }  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>###mutations有一种写法：</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;input type=&quot;number&quot; v-model=&quot;userName&quot; placeholder=&quot;请输入用户名&quot; /&gt;    &lt;button @click=&apos;loginClick()&apos;&gt; 登录&lt;/button&gt;    &lt;div&gt;{{test}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    name: &quot;login&quot;,    data:function () {      return{        userName:&apos;&apos;,      }    },    methods:{      loginClick:function () {        /**         *  调用mutations有一种方法         *   this.$store.commit(&apos;setMutationName&apos;,this.userName)         */        this.$store.commit(&apos;setMutationName&apos;,this.userName)      },    },    computed:{      test(){        return this.$store.state.name;      }    }  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>##state有四种写法：</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;button @click=&apos;loginClick()&apos;&gt; 获取用户名&lt;/button&gt;    &lt;div&gt;获取到的用户名：{{userName}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import { mapState } from &apos;vuex&apos;  export default {    name: &quot;login&quot;,    data:function () {      return{        userName:&apos;&apos;,      }    },    methods:{      loginClick:function () {        /**         *  调用state有四种方法         *  第一种：this.userName = this.$store.state.name,不需要...mapstate         *  第二种：this.userName = this.$store.state[&apos;name&apos;],不需要...mapstate         *  第三种：this.userName = this.getName，需要...mapstate         *  第四种：this.userName = this[&apos;getName&apos;]，需要...mapstate         */        console.log(&apos;没有module的state：&apos;+JSON.stringify(this.$store.state))//{&quot;name&quot;:&quot;111&quot;}        this.userName = this[&apos;getName&apos;]      },    },    computed:{      ...mapState({        getName: state =&gt; state.name,      }),    }  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>##再来看看有module的情况：</p><p>###接下来看看有module时getters的使用：getters有两种使用方法</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;getUserName()&quot;&gt;      点击获取用户名    &lt;/button&gt;    &lt;div&gt;获取到的用户名：{{userName}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import {mapGetters} from &apos;vuex&apos;  export default {    name: &quot;login&quot;,    data: function () {      return {        userName: &apos;&apos;,      }    },    methods:{      getUserName:function(){        /**         *  调用getters有两种方法         *  第一种：this.userName = this[&apos;mod1/getUserName&apos;] ，需要在computed中写...mapGetters         *  第二种：this.userName = this.$store.getters[&apos;mod1/getUserName&apos;]，直接调用gettersOne.js中的mod1的getUserName方法，不需要mapGetters         */        console.log(&apos;有module的getters：&apos;+JSON.stringify(this.$store.getters))//{&quot;getAddress&quot;:&quot;西安市&quot;,&quot;mod1/getUserName&quot;:&quot;testName&quot;,&quot;mod1/getUserNameTest&quot;:&quot;testName&quot;}        this.userName = this.$store.getters[&apos;mod1/getUserName&apos;];      }    },    computed: {      ...mapGetters([        &apos;mod1/getUserName&apos;      ])    },  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>###有module的state：state有四种使用方法</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;button @click=&apos;loginClick()&apos;&gt; 获取用户名&lt;/button&gt;    &lt;div&gt;获取到的用户名：{{userName}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import { mapState } from &apos;vuex&apos;  export default {    name: &quot;login&quot;,    data:function () {      return{        userName:&apos;&apos;,      }    },    methods:{      loginClick:function () {        /**         *  调用state有四种方法         *  第一种：this.userName = this.$store.state.mod1.userName,不需要...mapstate         *  第二种：this.userName = this.$store.state.mod1[&apos;userName&apos;],不需要...mapstate         *  第三种：this.userName = this.getName，需要...mapstate         *  第四种：this.userName = this[&apos;getName&apos;]，需要...mapstate         */        console.log(&apos;===&apos;+ JSON.stringify(this.$store.state))//{&quot;address&quot;:&quot;西安市&quot;,&quot;mod1&quot;:{&quot;userName&quot;:&quot;testName&quot;}}        this.userName = this.getName      },    },    computed:{      ...mapState({        /**         * 下面的方法也可以写为         *  getName: function(state){              console.log(JSON.stringify(state))//{&quot;address&quot;:&quot;西安市&quot;,&quot;mod1&quot;:{&quot;userName&quot;:&quot;testName&quot;}}              return  state.mod1.userName           }         * @param state         * @returns {*}         */        getName: state =&gt;state.mod1.userName//或者getName: state =&gt;state.mod1[&apos;userName&apos;]      }),    }  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>###有module的actions：action有两种使用方法</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;input type=&quot;number&quot; v-model=&quot;userName&quot; placeholder=&quot;请输入用户名&quot; /&gt;    &lt;div @click=&apos;loginClick()&apos;&gt; 登录&lt;/div&gt;    &lt;div&gt;{{test}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import { mapActions } from &apos;vuex&apos;  export default {    name: &quot;login&quot;,    data:function () {      return{        userName:&apos;&apos;,      }    },    methods:{      ...mapActions([        &apos;mod1/changeName&apos;      ]),      loginClick:function () {        /**         *  调用actions有两种方法         *  第一种：this[&apos;mod1/changeName&apos;](this.userName)，需要在methods中写...mapActions         *  第二种：this.$store.dispatch(&apos;mod1/changeName&apos;,this.userName)，直接调用actions.js中的changeName方法，不需要mapActions         */        this[&apos;mod1/changeName&apos;](this.userName)      },    },    computed:{      test(){        return this.$store.state.mod1.userName;      }    }  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>###有module的mutations：mutations有一种使用方法</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;input type=&quot;number&quot; v-model=&quot;userName&quot; placeholder=&quot;请输入用户名&quot; /&gt;    &lt;button @click=&apos;loginClick()&apos;&gt; 登录&lt;/button&gt;    &lt;div&gt;{{test}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    name: &quot;login&quot;,    data:function () {      return{        userName:&apos;&apos;,      }    },    methods:{      loginClick:function () {        /**         *  调用mutations有一种方法         *   this.$store.commit(&apos;setName&apos;,this.userName)         */        this.$store.commit(&apos;mod1/setName&apos;,this.userName)      },    },    computed:{      test(){        return this.$store.state.mod1.userName;      }    }  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vuex的state，actions，getters，mutations的使用 分为两种情况，有module和没有mudule&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue - vuex" scheme="http://yoursite.com/categories/vue-vuex/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>收藏 -记录</title>
    <link href="http://yoursite.com/post/2018-09-17-20180917/"/>
    <id>http://yoursite.com/post/2018-09-17-20180917/</id>
    <published>2018-09-17T12:48:18.000Z</published>
    <updated>2020-03-09T01:44:46.374Z</updated>
    
    <content type="html"><![CDATA[<p>网站地址收藏 -爱好收藏 </p><a id="more"></a><p>##js</p><p>彻底弄懂 JavaScript 执行机制  （<a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">https://juejin.im/post/59e85eebf265da430d571f89</a> ）</p><p>函数防抖和节流（<a href="https://www.jianshu.com/p/c8b86b09daf0" target="_blank" rel="noopener">https://www.jianshu.com/p/c8b86b09daf0</a> ）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网站地址收藏 -爱好收藏 &lt;/p&gt;
    
    </summary>
    
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="日志" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
