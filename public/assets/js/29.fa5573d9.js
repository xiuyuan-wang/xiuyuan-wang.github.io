(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{480:function(a,t,e){"use strict";e.r(t);var r=e(2),n=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("js 异步已经告一段落了，这里来一波小总结\n")]),a._v(" "),e("h5",{attrs:{id:"_1-回调函数（callback）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-回调函数（callback）"}},[a._v("#")]),a._v(" 1. 回调函数（callback）")]),a._v(" "),e("p",[a._v("setTimeout(() => {\n// callback 函数体\n}, 1000)")]),a._v(" "),e("h6",{attrs:{id:"缺点：回调地狱，不能用-try-catch-捕获错误，不能-return"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点：回调地狱，不能用-try-catch-捕获错误，不能-return"}},[a._v("#")]),a._v(" 缺点：回调地狱，不能用 try catch 捕获错误，不能 return")]),a._v(" "),e("p",[a._v("回调地狱的根本问题在于：")]),a._v(" "),e("p",[a._v("缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符\n嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转）\n嵌套函数过多的多话，很难处理错误")]),a._v(" "),e("p",[a._v("ajax('XXX1', () => {\n// callback 函数体\najax('XXX2', () => {\n// callback 函数体\najax('XXX3', () => {\n// callback 函数体\n})\n})\n})")]),a._v(" "),e("h6",{attrs:{id:"优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）"}},[a._v("#")]),a._v(" 优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）")]),a._v(" "),e("h5",{attrs:{id:"_2-promise"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-promise"}},[a._v("#")]),a._v(" 2.Promise")]),a._v(" "),e("p",[a._v("Promise就是为了解决callback的问题而产生的。")]),a._v(" "),e("p",[a._v("Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装")]),a._v(" "),e("h6",{attrs:{id:"优点：解决了回调地狱的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点：解决了回调地狱的问题"}},[a._v("#")]),a._v(" 优点：解决了回调地狱的问题")]),a._v(" "),e("p",[a._v("ajax('XXX1')\n.then(res => {\n// 操作逻辑\nreturn ajax('XXX2')\n}).then(res => {\n// 操作逻辑\nreturn ajax('XXX3')\n}).then(res => {\n// 操作逻辑\n})")]),a._v(" "),e("h6",{attrs:{id:"缺点：无法取消-promise-，错误需要通过回调函数来捕获"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点：无法取消-promise-，错误需要通过回调函数来捕获"}},[a._v("#")]),a._v(" 缺点：无法取消 Promise ，错误需要通过回调函数来捕获")]),a._v(" "),e("h5",{attrs:{id:"_3-generator"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-generator"}},[a._v("#")]),a._v(" 3. Generator")]),a._v(" "),e("h6",{attrs:{id:"特点：可以控制函数的执行，可以配合-co-函数库使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#特点：可以控制函数的执行，可以配合-co-函数库使用"}},[a._v("#")]),a._v(" 特点：可以控制函数的执行，可以配合 co 函数库使用")]),a._v(" "),e("p",[a._v("function *fetch() {\nyield ajax('XXX1', () => {})\nyield ajax('XXX2', () => {})\nyield ajax('XXX3', () => {})\n}\nlet it = fetch()\nlet result1 = it.next()\nlet result2 = it.next()\nlet result3 = it.next()")]),a._v(" "),e("h5",{attrs:{id:"_4-async-await"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-async-await"}},[a._v("#")]),a._v(" 4. Async/await")]),a._v(" "),e("p",[a._v("async、await 是异步的终极解决方案")]),a._v(" "),e("h5",{attrs:{id:"优点是：代码清晰，不用像-promise-写一大堆-then-链，处理了回调地狱的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点是：代码清晰，不用像-promise-写一大堆-then-链，处理了回调地狱的问题"}},[a._v("#")]),a._v(" 优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题")]),a._v(" "),e("h5",{attrs:{id:"缺点：await-将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用-await-会导致性能上的降低。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点：await-将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用-await-会导致性能上的降低。"}},[a._v("#")]),a._v(" 缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。")]),a._v(" "),e("p",[a._v("async function test() {\n// 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式\n// 如果有依赖性的话，其实就是解决回调地狱的例子了\nawait fetch('XXX1')\nawait fetch('XXX2')\nawait fetch('XXX3')\n}")]),a._v(" "),e("p",[a._v("下面来看一个使用 await 的例子：")]),a._v(" "),e("p",[a._v("let a = 0\nlet b = async () => {\na = a + await 10\nconsole.log('2', a) // -> '2' 10\n}\nb()\na++\nconsole.log('1', a) // -> '1' 1")]),a._v(" "),e("p",[a._v("对于以上代码你可能会有疑惑，让我来解释下原因")]),a._v(" "),e("p",[a._v("首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来\n因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码\n同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10")]),a._v(" "),e("p",[a._v("上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。")])])}),[],!1,null,null,null);t.default=n.exports}}]);