(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{484:function(n,e,a){"use strict";a.r(e);var t=a(2),s=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("p",[n._v("本文讲解JavaScript各种继承方式和优缺点。\n")]),n._v(" "),a("h5",{attrs:{id:"_1-原型链继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-原型链继承"}},[n._v("#")]),n._v(" 1.原型链继承")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("    function Parent () {\n        this.name = 'kevin';\n    }\n\n    Parent.prototype.getName = function () {\n        console.log(this.name);\n    }\n\n    function Child () {\n\n    }\n\n    Child.prototype = new Parent();\n\n    var child1 = new Child();\n\n    console.log(child1.getName()) // kevin\n")])])]),a("p",[n._v("问题：")]),n._v(" "),a("p",[n._v("1.引用类型的属性被所有实例共享，举个例子：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v('    function Parent () {\n        this.names = [\'kevin\', \'daisy\'];\n    }\n\n    function Child () {\n\n    }\n\n    Child.prototype = new Parent();\n\n    var child1 = new Child();\n\n    child1.names.push(\'yayu\');\n\n    console.log(child1.names); // ["kevin", "daisy", "yayu"]\n\n    var child2 = new Child();\n\n    console.log(child2.names); // ["kevin", "daisy", "yayu"]\n')])])]),a("p",[n._v("2.在创建 Child 的实例时，不能向Parent传参")]),n._v(" "),a("h4",{attrs:{id:"_2-借用构造函数-经典继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-借用构造函数-经典继承"}},[n._v("#")]),n._v(" 2.借用构造函数(经典继承)")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v('    function Parent () {\n        this.names = [\'kevin\', \'daisy\'];\n    }\n\n    function Child () {\n        Parent.call(this);\n    }\n\n    var child1 = new Child();\n\n    child1.names.push(\'yayu\');\n\n    console.log(child1.names); // ["kevin", "daisy", "yayu"]\n\n    var child2 = new Child();\n\n    console.log(child2.names); // ["kevin", "daisy"]\n')])])]),a("p",[n._v("优点：")]),n._v(" "),a("p",[n._v("1.避免了引用类型的属性被所有实例共享")]),n._v(" "),a("p",[n._v("2.可以在 Child 中向 Parent 传参")]),n._v(" "),a("p",[n._v("举个例子：")]),n._v(" "),a("p",[n._v("function Parent (name) {\nthis.name = name;\n}")]),n._v(" "),a("p",[n._v("function Child (name) {\nParent.call(this, name);\n}")]),n._v(" "),a("p",[n._v("var child1 = new Child('kevin');")]),n._v(" "),a("p",[n._v("console.log(child1.name); // kevin")]),n._v(" "),a("p",[n._v("var child2 = new Child('daisy');")]),n._v(" "),a("p",[n._v("console.log(child2.name); // daisy")]),n._v(" "),a("p",[n._v("缺点：")]),n._v(" "),a("p",[n._v("方法都在构造函数中定义，每次创建实例都会创建一遍方法。")]),n._v(" "),a("h4",{attrs:{id:"_3-组合继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-组合继承"}},[n._v("#")]),n._v(" 3.组合继承")]),n._v(" "),a("p",[n._v("原型链继承和经典继承双剑合璧。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("    function Parent (name) {\n        this.name = name;\n        this.colors = ['red', 'blue', 'green'];\n    }\n\n    Parent.prototype.getName = function () {\n        console.log(this.name)\n    }\n\n    function Child (name, age) {\n\n        Parent.call(this, name);\n        \n        this.age = age;\n\n    }\n\n    Child.prototype = new Parent();\n    Child.prototype.constructor = Child;\n\n    var child1 = new Child('kevin', '18');\n\n    child1.colors.push('black');\n\n    console.log(child1.name); // kevin\n    console.log(child1.age); // 18\n    console.log(child1.colors); // [\"red\", \"blue\", \"green\", \"black\"]\n\n    var child2 = new Child('daisy', '20');\n\n    console.log(child2.name); // daisy\n    console.log(child2.age); // 20\n    console.log(child2.colors); // [\"red\", \"blue\", \"green\"]\n")])])]),a("p",[n._v("优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。")]),n._v(" "),a("h4",{attrs:{id:"_4-原型式继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-原型式继承"}},[n._v("#")]),n._v(" 4.原型式继承")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("    function createObj(o) {\n        function F(){}\n        F.prototype = o;\n        return new F();\n    }\n")])])]),a("p",[n._v("就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。")]),n._v(" "),a("p",[n._v("缺点：")]),n._v(" "),a("p",[n._v("包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("    var person = {\n        name: 'kevin',\n        friends: ['daisy', 'kelly']\n    }\n\n    var person1 = createObj(person);\n    var person2 = createObj(person);\n\n    person1.name = 'person1';\n    console.log(person2.name); // kevin\n\n    person1.firends.push('taylor');\n    console.log(person2.friends); // [\"daisy\", \"kelly\", \"taylor\"]\n")])])]),a("p",[n._v("注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = 'person1'，给person1添加了 name 值，并非修改了原型上的 name 值。")]),n._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[n._v("寄生式继承")])]),n._v(" "),a("p",[n._v("创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("    function createObj (o) {\n        var clone = Object.create(o);\n        clone.sayName = function () {\n            console.log('hi');\n        }\n        return clone;\n    }\n")])])]),a("p",[n._v("缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法")]),n._v(" "),a("h4",{attrs:{id:"_6-寄生组合式继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-寄生组合式继承"}},[n._v("#")]),n._v(" 6. 寄生组合式继承")]),n._v(" "),a("p",[n._v("为了方便大家阅读，在这里重复一下组合继承的代码：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("    function Box(name) {\n        this.name = name;\n        this.arr = ['哥哥','妹妹','父母'];\n    }\n    Box.prototype.run = function () {\n        return this.name;\n    };\n    function Desk(name, age) {\n        Box.call(this, name);//第二次调用 Box\n        this.age = age;\n    }\n    Desk.prototype = new Box();//第一次调用 Box\n")])])]),a("p",[n._v("以上代码是之前的组合继承，那么寄生组合继承寄生组合继承，解决了两次调用的问题")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("    function obj(o) {\n        function F() {}\n        F.prototype = o;\n        return new F();\n    }\n    function create(box, desk) {\n        var f = obj(box.prototype);\n        f.constructor = desk;\n        desk.prototype = f;\n    }\n    function Box(name) {\n        this.name = name;\n        this.arr = ['哥哥','妹妹','父母'];\n    }\n    Box.prototype.run = function () {\n        return this.name;\n    };\n\n    function Desk(name, age) {\n        Box.call(this, name);\n        this.age = age;\n    }\n\n    create(Box, Desk);//通过这里实现继承\n    var desk = new Desk('Lee',100);\n    desk.arr.push('姐姐');\n    alert(desk.arr);\n    alert(desk.run());//只共享了方法\n    var desk2 = new Desk('Jack', 200);\n    alert(desk2.arr);//引用问题解决\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);