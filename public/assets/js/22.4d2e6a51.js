(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{473:function(n,a,s){"use strict";s.r(a);var t=s(2),l=Object(t.a)({},(function(){var n=this,a=n.$createElement,s=n._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("p",[n._v("单个插槽|默认插槽|匿名插槽")]),n._v(" "),s("p",[n._v("##单个插槽\n首先是单个插槽，单个插槽是vue的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置name属性。\n单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（name属性）不同就可以了。")]),n._v(" "),s("p",[n._v("下面通过一个例子来展示。")]),n._v(" "),s("p",[n._v("父组件：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v('<template>\n    <div class="father">\n        <h3>这里是父组件</h3>\n        <child>\n            <div class="tmpl">\n            <span>菜单1</span>\n            <span>菜单2</span>\n            <span>菜单3</span>\n            <span>菜单4</span>\n            <span>菜单5</span>\n            <span>菜单6</span>\n            </div>\n        </child>\n    </div>\n</template>\n')])])]),s("p",[n._v("子组件：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v('<template>\n    <div class="child">\n        <h3>这里是子组件</h3>\n        <slot></slot>\n    </div>\n</template>\n')])])]),s("p",[n._v("##具名插槽")]),n._v(" "),s("p",[n._v("匿名插槽没有name属性，所以是匿名插槽，那么，插槽加了name属性，就变成了具名插槽。具名插槽可以在一个组件中出现N次，出现在不同的位置。下面的例子，就是一个有两个具名插槽和单个插槽的组件，这三个插槽被父组件用同一套css样式显示了出来，不同的是内容上略有区别。")]),n._v(" "),s("p",[n._v("父组件：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v('<template>\n<div class="father">\n    <h3>这里是父组件</h3>\n    <child>\n    <div class="tmpl" slot="up">\n        <span>菜单1</span>\n        <span>菜单2</span>\n        <span>菜单3</span>\n        <span>菜单4</span>\n        <span>菜单5</span>\n        <span>菜单6</span>\n    </div>\n    <div class="tmpl" slot="down">\n        <span>菜单-1</span>\n        <span>菜单-2</span>\n        <span>菜单-3</span>\n        <span>菜单-4</span>\n        <span>菜单-5</span>\n        <span>菜单-6</span>\n    </div>\n    <div class="tmpl">\n        <span>菜单->1</span>\n        <span>菜单->2</span>\n        <span>菜单->3</span>\n        <span>菜单->4</span>\n        <span>菜单->5</span>\n        <span>菜单->6</span>\n    </div>\n    </child>\n</div>\n</template>\n')])])]),s("p",[n._v("子组件：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v('<template>\n    <div class="child">\n        // 具名插槽\n        <slot name="up"></slot>\n        <h3>这里是子组件</h3>\n        // 具名插槽\n        <slot name="down"></slot>\n        // 匿名插槽\n        <slot></slot>\n    </div>\n</template>\n')])])]),s("p",[n._v("##作用域插槽 | 带数据的插槽")]),n._v(" "),s("p",[n._v("最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的template里面写")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v('匿名插槽\n<slot></slot>\n具名插槽\n<slot name="up"></slot>\n')])])]),s("p",[n._v("但是作用域插槽要求，在slot上面绑定数据。也就是你得写成大概下面这个样子。")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("<slot name=\"up\" :data=\"data\"></slot>\nexport default {\n    data: function(){\n    return {\n        data: ['zhangsan','lisi','wanwu','zhaoliu','tianqi','xiaoba']\n    }\n    },\n}\n")])])]),s("p",[n._v("我们前面说了，插槽最后显示不显示是看父组件有没有在child下面写模板，像下面那样。")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("<child>\nhtml模板\n</child>\n")])])]),s("p",[n._v("写了，插槽就总得在浏览器上显示点东西，东西就是html该有的模样，没写，插槽就是空壳子，啥都没有。OK，我们说有html模板的情况，就是父组件会往子组件插模板的情况，那到底插一套什么样的样式呢，这由父组件的html+css共同决定，但是这套样式里面的内容呢？")]),n._v(" "),s("p",[n._v("正因为作用域插槽绑定了一套数据，父组件可以拿来用。于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。")]),n._v(" "),s("p",[n._v("我们再来对比，作用域插槽跟单个插槽和具名插槽的区别，因为单个插槽和具名插槽不绑定数据，所以父组件提供的模板一般要既包括样式又包括内容，上面的例子中，你看到的文字，“菜单1”，“菜单2”都是父组件自己提供的内容；而作用域插槽，父组件只需要提供一套样式（在确实用作用域插槽绑定的数据的前提下）。")]),n._v(" "),s("p",[n._v("下面的例子，你就能看到，父组件提供了三种样式(分别是flex、ul、直接显示)，都没有提供数据，数据使用的都是子组件插槽自己绑定的那个数组（一堆人名的那个数组）。")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v('    <template>\n        <div class="father">\n            <h3>这里是父组件</h3>\n            \x3c!--第一次使用：用flex展示数据--\x3e\n            <child>\n            <template slot-scope="user">\n                <div class="tmpl">\n                <span v-for="item in user.data">item</span>\n                </div>\n            </template>\n\n            </child>\n            \x3c!--第二次使用：用列表展示数据--\x3e\n            <child>\n            <template slot-scope="user">\n                <ul>\n                <li v-for="item in user.data">item</li>\n                </ul>\n            </template>\n\n            </child>\n\n            \x3c!--第三次使用：直接显示数据--\x3e\n            <child>\n            <template slot-scope="user">\n            user.data\n            </template>\n\n            </child>\n\n            \x3c!--第四次使用：不使用其提供的数据, 作用域插槽退变成匿名插槽--\x3e\n            <child>\n            我就是模板\n            </child>\n        </div>\n    </template>')])])])])}),[],!1,null,null,null);a.default=l.exports}}]);