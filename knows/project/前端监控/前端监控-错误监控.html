<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前言 | 倘若有一天</title>
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/header.jpg">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.a427340b.css" as="style"><link rel="preload" href="/assets/js/app.282508ef.js" as="script"><link rel="preload" href="/assets/js/2.a1cbaef5.js" as="script"><link rel="preload" href="/assets/js/92.23834236.js" as="script"><link rel="prefetch" href="/assets/js/10.2c98332c.js"><link rel="prefetch" href="/assets/js/100.393ab2a4.js"><link rel="prefetch" href="/assets/js/101.78c1f8b6.js"><link rel="prefetch" href="/assets/js/102.85d15ad3.js"><link rel="prefetch" href="/assets/js/103.b2c501a5.js"><link rel="prefetch" href="/assets/js/104.c0ed595d.js"><link rel="prefetch" href="/assets/js/105.f15f5366.js"><link rel="prefetch" href="/assets/js/106.61151c5e.js"><link rel="prefetch" href="/assets/js/107.d39240eb.js"><link rel="prefetch" href="/assets/js/108.f716bda5.js"><link rel="prefetch" href="/assets/js/109.fbc135d0.js"><link rel="prefetch" href="/assets/js/11.f005400c.js"><link rel="prefetch" href="/assets/js/110.3928667b.js"><link rel="prefetch" href="/assets/js/111.b13a0b48.js"><link rel="prefetch" href="/assets/js/112.7b5006f4.js"><link rel="prefetch" href="/assets/js/113.0d31f132.js"><link rel="prefetch" href="/assets/js/114.2bb5d9e1.js"><link rel="prefetch" href="/assets/js/115.5e64c1e5.js"><link rel="prefetch" href="/assets/js/116.3ee73b77.js"><link rel="prefetch" href="/assets/js/117.f50cff54.js"><link rel="prefetch" href="/assets/js/118.2689f48f.js"><link rel="prefetch" href="/assets/js/119.6426d3f6.js"><link rel="prefetch" href="/assets/js/12.cf3e63d8.js"><link rel="prefetch" href="/assets/js/120.363e12a7.js"><link rel="prefetch" href="/assets/js/121.85ec9cf3.js"><link rel="prefetch" href="/assets/js/13.81302ba4.js"><link rel="prefetch" href="/assets/js/14.9afc1667.js"><link rel="prefetch" href="/assets/js/15.c564a464.js"><link rel="prefetch" href="/assets/js/16.3f8c98ff.js"><link rel="prefetch" href="/assets/js/17.1d432112.js"><link rel="prefetch" href="/assets/js/18.66992dd5.js"><link rel="prefetch" href="/assets/js/19.3a5615bc.js"><link rel="prefetch" href="/assets/js/20.9e0b5237.js"><link rel="prefetch" href="/assets/js/21.f51d933b.js"><link rel="prefetch" href="/assets/js/22.aaa8538e.js"><link rel="prefetch" href="/assets/js/23.e4f94cd3.js"><link rel="prefetch" href="/assets/js/24.5deee84c.js"><link rel="prefetch" href="/assets/js/25.9b363258.js"><link rel="prefetch" href="/assets/js/26.c6083244.js"><link rel="prefetch" href="/assets/js/27.9ebc4263.js"><link rel="prefetch" href="/assets/js/28.d4a74cd6.js"><link rel="prefetch" href="/assets/js/29.bb4db167.js"><link rel="prefetch" href="/assets/js/3.17384045.js"><link rel="prefetch" href="/assets/js/30.3b68b547.js"><link rel="prefetch" href="/assets/js/31.58ba7ddf.js"><link rel="prefetch" href="/assets/js/32.886b3dd0.js"><link rel="prefetch" href="/assets/js/33.5e65a6cc.js"><link rel="prefetch" href="/assets/js/34.25b5b82b.js"><link rel="prefetch" href="/assets/js/35.f8d6f114.js"><link rel="prefetch" href="/assets/js/36.aea7921b.js"><link rel="prefetch" href="/assets/js/37.5c6156f9.js"><link rel="prefetch" href="/assets/js/38.588a6193.js"><link rel="prefetch" href="/assets/js/39.e9ceb0e8.js"><link rel="prefetch" href="/assets/js/4.ac8c0f23.js"><link rel="prefetch" href="/assets/js/40.9acab66e.js"><link rel="prefetch" href="/assets/js/41.97497b1c.js"><link rel="prefetch" href="/assets/js/42.873f16b5.js"><link rel="prefetch" href="/assets/js/43.4d558e3f.js"><link rel="prefetch" href="/assets/js/44.645dab32.js"><link rel="prefetch" href="/assets/js/45.1f2b148b.js"><link rel="prefetch" href="/assets/js/46.f6b30a8a.js"><link rel="prefetch" href="/assets/js/47.6f082f8d.js"><link rel="prefetch" href="/assets/js/48.ce777f64.js"><link rel="prefetch" href="/assets/js/49.570a21ec.js"><link rel="prefetch" href="/assets/js/5.8a91f847.js"><link rel="prefetch" href="/assets/js/50.7d81323a.js"><link rel="prefetch" href="/assets/js/51.0303e90b.js"><link rel="prefetch" href="/assets/js/52.97f8b439.js"><link rel="prefetch" href="/assets/js/53.3fd3c6a9.js"><link rel="prefetch" href="/assets/js/54.d0eb83b3.js"><link rel="prefetch" href="/assets/js/55.32fdcecc.js"><link rel="prefetch" href="/assets/js/56.fbfc09a3.js"><link rel="prefetch" href="/assets/js/57.547120c7.js"><link rel="prefetch" href="/assets/js/58.8ca04f20.js"><link rel="prefetch" href="/assets/js/59.50e6f206.js"><link rel="prefetch" href="/assets/js/6.c966999c.js"><link rel="prefetch" href="/assets/js/60.03d4b566.js"><link rel="prefetch" href="/assets/js/61.03af23bf.js"><link rel="prefetch" href="/assets/js/62.cf5f882a.js"><link rel="prefetch" href="/assets/js/63.8389c2c6.js"><link rel="prefetch" href="/assets/js/64.56a6a39f.js"><link rel="prefetch" href="/assets/js/65.2934948c.js"><link rel="prefetch" href="/assets/js/66.e050480c.js"><link rel="prefetch" href="/assets/js/67.a03accad.js"><link rel="prefetch" href="/assets/js/68.fa9364ed.js"><link rel="prefetch" href="/assets/js/69.2fbeaf39.js"><link rel="prefetch" href="/assets/js/7.971eb831.js"><link rel="prefetch" href="/assets/js/70.89ef1589.js"><link rel="prefetch" href="/assets/js/71.a41e8134.js"><link rel="prefetch" href="/assets/js/72.ba2ffe87.js"><link rel="prefetch" href="/assets/js/73.113b3d76.js"><link rel="prefetch" href="/assets/js/74.4dd54a46.js"><link rel="prefetch" href="/assets/js/75.98bbb07f.js"><link rel="prefetch" href="/assets/js/76.6cee2f65.js"><link rel="prefetch" href="/assets/js/77.0bc53ebb.js"><link rel="prefetch" href="/assets/js/78.8617cec2.js"><link rel="prefetch" href="/assets/js/79.137d3747.js"><link rel="prefetch" href="/assets/js/8.c941beae.js"><link rel="prefetch" href="/assets/js/80.130e6609.js"><link rel="prefetch" href="/assets/js/81.0b3bf721.js"><link rel="prefetch" href="/assets/js/82.982380fc.js"><link rel="prefetch" href="/assets/js/83.501eca82.js"><link rel="prefetch" href="/assets/js/84.66e5994c.js"><link rel="prefetch" href="/assets/js/85.df1ae8de.js"><link rel="prefetch" href="/assets/js/86.565baee7.js"><link rel="prefetch" href="/assets/js/87.3244d4ef.js"><link rel="prefetch" href="/assets/js/88.f104eed0.js"><link rel="prefetch" href="/assets/js/89.592f4c57.js"><link rel="prefetch" href="/assets/js/9.1002202d.js"><link rel="prefetch" href="/assets/js/90.db5ee901.js"><link rel="prefetch" href="/assets/js/91.2acf88e1.js"><link rel="prefetch" href="/assets/js/93.33612d70.js"><link rel="prefetch" href="/assets/js/94.3262e5a7.js"><link rel="prefetch" href="/assets/js/95.48027147.js"><link rel="prefetch" href="/assets/js/96.a9ed0cf0.js"><link rel="prefetch" href="/assets/js/97.48930c53.js"><link rel="prefetch" href="/assets/js/98.4a046e5f.js"><link rel="prefetch" href="/assets/js/99.aff15256.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a427340b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/header.jpg" alt="倘若有一天" class="logo"> <span class="site-name can-hide">倘若有一天</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/knows/" class="nav-link router-link-active">
  前端
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  数据可视化
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/knows/" class="nav-link router-link-active">
  前端
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  数据可视化
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>前端方案</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knows/project/001.html" class="sidebar-link">指南</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>即时通讯</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>前端监控</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knows/project/前端监控/前端监控-性能监控.html" class="sidebar-link">前端监控-性能监控</a></li><li><a href="/knows/project/前端监控/前端监控-行为监控.html" class="sidebar-link">前端监控-行为监控</a></li><li><a href="/knows/project/前端监控/前端监控-错误监控.html" class="active sidebar-link">前端监控-错误监控</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/knows/project/前端监控/前端监控-架构设计.html" class="sidebar-link">前端监控-架构设计</a></li><li><a href="/knows/project/前端监控/前端日志上报.html" class="sidebar-link">前端日志上报</a></li><li><a href="/knows/project/前端监控/神策分析.html" class="sidebar-link">神策分析 Web JS SDK</a></li></ul></section></li><li><a href="/knows/project/PWA/使用offline-plugin实现PWA.html" class="sidebar-link">使用offline-plugin实现PWA</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>微前端</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h3> <p>上篇文章我们分享了关于 <code>用户行为监控</code> 的内容，本文我们接着来看 <code>错误异常监控</code> 的方面</p> <h3 id="系列文章传送门"><a href="#系列文章传送门" class="header-anchor">#</a> 系列文章传送门</h3> <p><a href="https://juejin.cn/post/7097157902862909471" title="https://juejin.cn/post/7097157902862909471" target="_blank" rel="noopener noreferrer">一文摸清前端监控实践要点（一）性能监控<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/7098656658649251877" title="https://juejin.cn/post/7098656658649251877" target="_blank" rel="noopener noreferrer">一文摸清前端监控实践要点（二）行为监控<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/7100841779854835719/" title="https://juejin.cn/post/7100841779854835719/" target="_blank" rel="noopener noreferrer">一文摸清前端监控实践要点（三）错误监控<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/7108660942686126093" title="https://juejin.cn/post/7108660942686126093" target="_blank" rel="noopener noreferrer">腾讯三面：说说前端监控告警分析平台的架构设计和难点亮点？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="应用的稳定情况"><a href="#应用的稳定情况" class="header-anchor">#</a> 应用的稳定情况</h3> <p>众所周知，无论进行发布前的<code>单元测试</code>、<code>集成测试</code>、<code>人工测试</code>进行再多轮，<strong>都会难免漏掉一些边缘的测试场景</strong>，甚至还有一些<code>奇奇怪怪的玄学故障出现</code>；而出现报错后，<code>轻则某些数据页面无法访问</code>，<code>重则导致客户数据出错</code>；</p> <p>这时，一个完善的错误监控体系就派上很大的用场，它可以帮助我们做以下的事情：</p> <ul><li>应用报错时，及时知晓线上应用出现了错误，及时安排修复止损；</li> <li>应用报错后，根据上报的用户行为追踪记录数据，迅速进行bug复现；</li> <li>应用报错后，通过上报的错误行列以及错误信息，找到报错源码并快速修正；</li> <li>数据采集后，进行分析提供宏观的 错误数、错误率、影响用户数等关键指标；</li></ul> <h4 id="整体封装"><a href="#整体封装" class="header-anchor">#</a> 整体封装</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 错误类型
export enum mechanismType {
  JS = 'js',
  RS = 'resource',
  UJ = 'unhandledrejection',
  HP = 'http',
  CS = 'cors',
  VUE = 'vue',
}

// 格式化后的 异常数据结构体
export interface ExceptionMetrics {
  mechanism: Object;
  value?: string;
  type: string;
  stackTrace?: Object;
  pageInformation?: Object;
  breadcrumbs?: Array&lt;behaviorStack&gt;;
  errorUid: string;
  meta?: any;
}

// 初始化用参
export interface ErrorVitalsInitOptions {
  Vue: any;
}

// 判断是 JS异常、静态资源异常、还是跨域异常
export const getErrorKey = (event: ErrorEvent | Event) =&gt; {
  const isJsError = event instanceof ErrorEvent;
  if (!isJsError) return mechanismType.RS;
  return event.message === 'Script error.' ? mechanismType.CS : mechanismType.JS;
};

// 初始化的类
export default class ErrorVitals {
  private engineInstance: EngineInstance;

  // 已上报的错误 uid
  private submitErrorUids: Array&lt;string&gt;;

  constructor(engineInstance: EngineInstance, options: ErrorVitalsInitOptions) {
    const { Vue } = options;
    this.engineInstance = engineInstance;
    this.submitErrorUids = [];
    // 初始化 js错误
    this.initJsError();
    // 初始化 静态资源加载错误
    this.initResourceError();
    // 初始化 Promise异常
    this.initPromiseError();
    // 初始化 HTTP请求异常
    this.initHttpError();
    // 初始化 跨域异常
    this.initCorsError();
    // 初始化 Vue异常
    this.initVueError(Vue);
  }

  // 封装错误的上报入口，上报前，判断错误是否已经发生过
  errorSendHandler = (data: ExceptionMetrics) =&gt; {
    // 统一加上 用户行为追踪 和 页面基本信息
    const submitParams = {
      ...data,
      breadcrumbs: this.engineInstance.userInstance.breadcrumbs.get(),
      pageInformation: this.engineInstance.userInstance.metrics.get('page-information'),
    } as ExceptionMetrics;
    // 判断同一个错误在本次页面访问中是否已经发生过;
    const hasSubmitStatus = this.submitErrorUids.includes(submitParams.errorUid);
    // 检查一下错误在本次页面访问中，是否已经产生过
    if (hasSubmitStatus) return;
    this.submitErrorUids.push(submitParams.errorUid);
    // 记录后清除 breadcrumbs
    this.engineInstance.userInstance.breadcrumbs.clear();
    // 一般来说，有报错就立刻上报;
    this.engineInstance.transportInstance.kernelTransportHandler(
      this.engineInstance.transportInstance.formatTransportData(transportCategory.ERROR, submitParams),
    );
  };

  // 初始化 JS异常 的数据获取和上报
  initJsError = (): void =&gt; {
    //... 详情代码在下
  };

  // 初始化 静态资源异常 的数据获取和上报
  initResourceError = (): void =&gt; {
    //... 详情代码在下
  };

  // 初始化 Promise异常 的数据获取和上报
  initPromiseError = (): void =&gt; {
    //... 详情代码在下
  };

  // 初始化 HTTP请求异常 的数据获取和上报
  initHttpError = (): void =&gt; {
    //... 详情代码在下
  };

  // 初始化 跨域异常 的数据获取和上报
  initCorsError = (): void =&gt; {
    //... 详情代码在下
  };

  // 初始化 Vue异常 的数据获取和上报
  initVueError = (app: Vue): void =&gt; {
    //... 详情代码在下
  };
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br></div></div><h4 id="生成错误-uid"><a href="#生成错误-uid" class="header-anchor">#</a> 生成错误 uid</h4> <p>首先，什么叫为<code>每个错误生成 uid</code>，这里生成的 <code>uid</code> 有什么用呢？答案其实很简单：</p> <ul><li>一次用户访问（页签未关闭），上报过一次错误后，后续产生<code>重复错误不再上报</code></li> <li>多个用户产生的同一个错误，在服务端可以归类，<code>分析影响用户数、错误数等指标</code></li> <li>需要注意的是，对于同一个原因产生的同一个错误，生成的 uid 是相同的</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 对每一个错误详情，生成一串编码
export const getErrorUid = (input: string) =&gt; {
  return window.btoa(unescape(encodeURIComponent(input)));
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="错误堆栈"><a href="#错误堆栈" class="header-anchor">#</a> 错误堆栈</h4> <p>在做错误监控之前，我们先来了解一下什么是错误堆栈；我们写代码经常报错的时候能够看到，<code>下图这样子类似的错误</code>，一个错误加上很多条很多条的调用信息组成的错误；这就是抛出的 <code>Error对象</code> 里的 <code>Stack错误堆栈</code>，里面包含了很多信息：包括<code>调用链</code>、<code>文件名</code>、<code>调用地址行列信息</code>等等；而在下文的错误捕获中，我们也需要去对 <code>Stack错误堆栈</code> 进行解析；</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fc6084b2c604432ab8355e0c28bb530~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="248666eeb9c549a7af8a57a6a5022077.png"></p> <p><strong>当然，解析这一长串的东西还是比较痛苦的，我这边就给出我的解析方法<code>以供参考</code>：</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 正则表达式，用以解析堆栈split后得到的字符串
const FULL_MATCH =
  /^\s*at (?:(.*?) ?()?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|&lt;anonymous&gt;|[-a-z]+:|.*bundle|/).*?)(?::(\d+))?(?::(\d+))?)?\s*$/i;

// 限制只追溯10个
const STACKTRACE_LIMIT = 10;

// 解析每一行
export function parseStackLine(line: string) {
  const lineMatch = line.match(FULL_MATCH);
  if (!lineMatch) return {};
  const filename = lineMatch[2];
  const functionName = lineMatch[1] || '';
  const lineno = parseInt(lineMatch[3], 10) || undefined;
  const colno = parseInt(lineMatch[4], 10) || undefined;
  return {
    filename,
    functionName,
    lineno,
    colno,
  };
}

// 解析错误堆栈
export function parseStackFrames(error: Error) {
  const { stack } = error;
  // 无 stack 时直接返回
  if (!stack) return [];
  const frames = [];
  for (const line of stack.split('\n').slice(1)) {
    const frame = parseStackLine(line);
    if (frame) {
      frames.push(frame);
    }
  }
  return frames.slice(0, STACKTRACE_LIMIT);
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p>调用 <code>parseStackFrames()</code> 方法将 <code>error对象</code> 传入后，我们可以看到解析的效果还是可以的：</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86b977a6c84f421b9660c3377d485c50~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p> <h4 id="js运行异常"><a href="#js运行异常" class="header-anchor">#</a> JS运行异常</h4> <p>什么叫 <code>JS运行异常</code> 呢？其实很简单，当 <strong>JavaScript运行时产生的错误</strong> 就属于 <code>JS运行异常</code></p> <p>比如，我们未定义一个方法就直接调用它，它会报错：<code>Uncaught ReferenceError: xxx is not defined</code>，这就属于 <code>JS运行异常</code></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>noEmit();   // 没有定义，直接调用
// 会报错：Uncaught ReferenceError: noEmit is not defined
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>那么，既然发生了错误，我们就需要去捕获它；<strong>而捕获JS运行异常有两种方法：</strong></p> <h5 id="方法一"><a href="#方法一" class="header-anchor">#</a> 方法一</h5> <p>我们可以使用 <code>window.onerror</code> 来捕获全局的 <code>JS运行异常</code>,<code>window.onerror</code> 是一个全局变量，默认值为null。<strong>当有js运行时错误触发时，window会触发error事件</strong>，并执行 <code>window.onerror()</code>,借助这个特性，我们对 <code>window.onerror</code> 进行重写就可以捕获到代码中的异常；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>window.onerror = (msg, url, row, col, error) =&gt; {
  const exception = {
    // 上报错误归类
    mechanism: {
      type: 'js'
    },
    // 错误信息
    value: msg,
    // 错误类型
    type: error.name || 'UnKnowun',
    // 解析后的错误堆栈
    stackTrace: {
      frames: parseStackFrames(error),
    },
    meta: {
      url, // 文件地址
      row, // 行号
      col, // 列号
    }
  };
  // 获取了报错详情，就可以走上报方法上报错误信息
  console.log('JS运行error', exception);
  return true; // 返回 true,阻止了默认事件执行,也就是原本将要在控制台打印的错误信息
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h5 id="方法二"><a href="#方法二" class="header-anchor">#</a> 方法二</h5> <p>我们还可以使用 <code>window.addEventListener('error')</code> 来捕获 <code>JS运行异常</code>；它会比 <code>window.onerror</code> <strong>先触发</strong>；</p> <p><strong>我们简单封装一下：</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 初始化 JS异常 的数据获取和上报
initJsError = (): void =&gt; {
  const handler = (event: ErrorEvent) =&gt; {
    // 阻止向上抛出控制台报错
    event.preventDefault();
    // 如果不是 JS异常 就结束
    if (getErrorKey(event) !== mechanismType.JS) return;
    const exception = {
      // 上报错误归类
      mechanism: {
        type: mechanismType.JS,
      },
      // 错误信息
      value: event.message,
      // 错误类型
      type: (event.error &amp;&amp; event.error.name) || 'UnKnowun',
      // 解析后的错误堆栈
      stackTrace: {
        frames: parseStackFrames(event.error),
      },
      // 用户行为追踪 breadcrumbs 在 errorSendHandler 中统一封装
      // 页面基本信息 pageInformation 也在 errorSendHandler 中统一封装
      // 错误的标识码
      errorUid: getErrorUid(`${mechanismType.JS}-${event.message}-${event.filename}`),
      // 附带信息
      meta: {
        // file 错误所处的文件地址
        file: event.filename,
        // col 错误列号
        col: event.colno,
        // row 错误行号
        row: event.lineno,
      },
    } as ExceptionMetrics;
    // 一般错误异常立刻上报，不用缓存在本地
    this.errorSendHandler(exception);
  };
  window.addEventListener('error', (event) =&gt; handler(event), true);
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><h5 id="两者的区别和选用"><a href="#两者的区别和选用" class="header-anchor">#</a> 两者的区别和选用</h5> <p>阅读了上文，我们了解到想要监控 <code>JS运行异常</code> ，我们有两种方法可以选用，那么我们<strong>应该选用哪一种</strong>呢？或者说它们两者方法之间有什么区别呢？</p> <ul><li>它们两者均可以捕获到 <code>JS运行异常</code>，但是 方法二除了可以监听 <code>JS运行异常</code> 之外，还可以同时捕获到 <code>静态资源加载异常</code></li> <li><code>onerror</code> 可以接受多个参数。而 <code>addEventListener('error')</code> 只有一个保存所有错误信息的参数</li></ul> <p><strong>我这边个人更加建议使用第二种 <code>addEventListener('error')</code> 的方式</strong>；原因很简单：<code>不像方法一可以被 window.onerror 重新覆盖</code>；<code>而且可以同时处理静态资源错误</code></p> <h4 id="错误类型"><a href="#错误类型" class="header-anchor">#</a> 错误类型</h4> <p>细心的同学应该看见了，上文的捕获中，有一个参数叫做 <code>错误类型</code>，<strong>我们可以通过这个来快速判断错误是基于什么导致的</strong>，那么 JS运行时的错误类型常见的有哪些呢？</p> <table><thead><tr><th>类型</th> <th>含义</th> <th>说明</th></tr></thead> <tbody><tr><td>SyntaxError</td> <td>语法错误</td> <td>语法错误</td></tr> <tr><td>ReferenceError</td> <td>引用错误</td> <td>常见于引用了一个不存在的变量： <code>let a = undefinedVariable;</code></td></tr> <tr><td>RangeError</td> <td>有效范围错误</td> <td>数值变量或参数超出了其有效范围。 常见于 1.创建一个负长度数组 2.Number对象的方法参数超出范围：<code>let b = new Array(-1)</code></td></tr> <tr><td>TypeError</td> <td>类型错误</td> <td>常见于变量或参数不属于有效类型 <code>let foo = 3;foo();</code></td></tr> <tr><td>URIError</td> <td>URL处理函数错误</td> <td>使用全局URL处理函数错误，比如 <code>decodeURIComponent('%');</code></td></tr></tbody></table> <ul><li><strong>这里有一个点需要特别注意</strong>，我们主观感觉上的 <code>SyntaxError 语法错误</code>，除了用 <code>eval()</code> 执行的脚本以外，一般是不可以被捕获到的，比如我们编写一个<code>正常的语法错误</code>：</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>const d d = 1;
// 控制台报错 :Uncaught SyntaxError: Missing initializer in const declaration
// 但是上述的捕获方法无法正常捕获错误；
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>这明显上是一个<code>语法上的错误</code>，但是我们上述的 <code>两个错误捕获方法</code>，<strong>都没办法捕获到错误</strong>；</li> <li>只有在代码中通过 <code>eval()</code> 执行的代码脚本才可以正常捕获到错误信息；</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>eval('ddd fff');
// 控制台报错 VM149:1 Uncaught SyntaxError: Unexpected identifier
// 上文的错误捕获方法可以正常捕获到错误；
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><strong>那么，WHY</strong>？</li></ul> <p>其实原因很简单， <code>const d d = 1</code>; 这种语法错误，在<code>编译解析阶段</code>就已经报错了，而拥有语法错误的脚本不会放入<code>任务队列</code>进行执行，<strong>自然也就不会有错误冒泡到我们的捕获代码</strong>；而我们使用 <code>eval()</code>；在编译解析阶段一切正常，直到执行的时候才进行报错，自然我们就可以捕获到这段错误；</p> <blockquote><p><strong>当然，现在代码检查这么好用，早在编写代码时这种语法错误就被避免掉了，一般我们碰不上语法错误的</strong>~</p></blockquote> <h4 id="静态资源加载异常"><a href="#静态资源加载异常" class="header-anchor">#</a> 静态资源加载异常</h4> <p>有的时候，我们界面上的 <code>img图片</code>、<code>CDN资源</code> <strong>突然失效了、打不开了</strong>，就比如以下面这个为例子，我们往html中放进一个img，把它的路径设为请求不到的地址：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;img src=&quot;http://localhost:8888/nottrue.jpg&quot;&gt;
// 会报错 GET http://localhost:8888/nottrue.jpg net::ERR_CONNECTION_REFUSED
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>那我们怎么去捕获到这种请求不到资源的、或者说静态资源失效的报错呢？很简单，只需要祭出 <code>window.addEventListener('error')</code> 就可以了</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 静态资源错误的 ErrorTarget
export interface ResourceErrorTarget {
  src?: string;
  tagName?: string;
  outerHTML?: string;
}

// 初始化 静态资源异常 的数据获取和上报
initResourceError = (): void =&gt; {
  const handler = (event: Event) =&gt; {
    event.preventDefault(); // 阻止向上抛出控制台报错
    // 如果不是跨域脚本异常,就结束
    if (getErrorKey(event) !== mechanismType.RS) return;
    const target = event.target as ResourceErrorTarget;
    const exception = {
      // 上报错误归类
      mechanism: {
        type: mechanismType.RS,
      },
      // 错误信息
      value: '',
      // 错误类型
      type: 'ResourceError',
      // 用户行为追踪 breadcrumbs 在 errorSendHandler 中统一封装
      // 页面基本信息 pageInformation 也在 errorSendHandler 中统一封装
      // 错误的标识码
      errorUid: getErrorUid(`${mechanismType.RS}-${target.src}-${target.tagName}`),
      // 附带信息
      meta: {
        url: target.src,
        html: target.outerHTML,
        type: target.tagName,
      },
    } as ExceptionMetrics;
    // 一般错误异常立刻上报，不用缓存在本地
    this.errorSendHandler(exception);
  };
  window.addEventListener('error', (event) =&gt; handler(event), true);
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><blockquote><p>使用 <code>addEventListener</code> 捕获资源错误时，一定要将 <strong>第三个选项设为 true</strong>，因为资源错误没有冒泡，所以只能在捕获阶段捕获。同理，由于 window.onerror 是通过在冒泡阶段捕获错误，所以无法捕获资源错误。</p></blockquote> <h4 id="promise异常"><a href="#promise异常" class="header-anchor">#</a> Promise异常</h4> <p>什么叫 <code>Promise异常</code> 呢？其实就是我们使用 <code>Promise</code> 的过程中，当 <code>Promise</code> 被 <code>reject</code> 且没有被 <code>catch</code> 处理的时候，就会抛出 <code>Promise异常</code>；同样的，如果我们在使用 <code>Promise</code> 的过程中，报了JS的错误，同样也被以 <code>Promise异常</code> 的形式抛出：</p> <p><strong>下面我举两个会产生 <code>Promise异常</code> 的例子</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Promise.resolve().then(() =&gt; console.log(c));
// Uncaught (in promise) ReferenceError: c is not defined
Promise.reject('reject了但是没有处理!')
// Uncaught (in promise) reject了但是没有处理!
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>而当抛出 <code>Promise异常</code> 时，会触发 <code>unhandledrejection</code> 事件，所以我们只需要去监听它就可以进行 <code>Promise 异常</code> 的捕获了，不过值得注意的一点是：<strong>相比与上面所述的直接获取报错的行号、列号等信息</strong>，<code>Promise异常</code> 我们只能捕获到一个 <code>报错原因</code> 而已；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 初始化 Promise异常 的数据获取和上报
initPromiseError = (): void =&gt; {
  const handler = (event: PromiseRejectionEvent) =&gt; {
    event.preventDefault(); // 阻止向上抛出控制台报错
    const value = event.reason.message || event.reason;
    const type = event.reason.name || 'UnKnowun';
    const exception = {
      // 上报错误归类
      mechanism: {
        type: mechanismType.UJ,
      },
      // 错误信息
      value,
      // 错误类型
      type,
      // 解析后的错误堆栈
      stackTrace: {
        frames: parseStackFrames(event.reason),
      },
      // 用户行为追踪 breadcrumbs 在 errorSendHandler 中统一封装
      // 页面基本信息 pageInformation 也在 errorSendHandler 中统一封装
      // 错误的标识码
      errorUid: getErrorUid(`${mechanismType.UJ}-${value}-${type}`),
      // 附带信息
      meta: {},
    } as ExceptionMetrics;
    // 一般错误异常立刻上报，不用缓存在本地
    this.errorSendHandler(exception);
  };

  window.addEventListener('unhandledrejection', (event) =&gt; handler(event), true);
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><h4 id="http请求异常"><a href="#http请求异常" class="header-anchor">#</a> HTTP请求异常</h4> <p><strong>HTTP请求的捕获，我在前文中已经写过代码，可以回翻</strong>: <a href="https://juejin.cn/post/7098656658649251877#heading-12" title="https://juejin.cn/post/7098656658649251877#heading-12" target="_blank" rel="noopener noreferrer">一文摸清前端监控实践要点（二）行为监控 HTTP 请求捕获<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>所谓 <code>Http请求异常</code> <strong>也就是异步请求 HTTP 接口时的异常罢了</strong>，比如我调用了一个登录接口，但是我的传参不对，登录接口给我返回了 <code>500 错误码</code>，其实这个时候就已经产生了异常了；</p> <h5 id="是否属于-promise异常"><a href="#是否属于-promise异常" class="header-anchor">#</a> 是否属于 Promise异常</h5> <p><code>看到这里，其实有的同学可能会疑惑</code>，我们现在的调用 HTTP 接口，一般也就是通过 <code>async/await</code> 这种基于Promise的解决异步的最终方案；那么，<strong>假如说请求了一个接口地址报了500</strong>，因为是基于 <code>Promise</code> 调用的接口，我们<strong>能够</strong>在上文的 <code>Promise异常</code> 捕获中，获取到一个错误信息（如下图）；</p> <p>但是有一个问题别忘记了，<strong><code>Promise异常捕获没办法获取报错的行列</code></strong>，我们<strong>只知道</strong> Promise 报错了，报错的信息是 <code>接口请求500</code>；但是我们<strong>根本不知道是哪个接口报错了</strong>；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/669f963fd18f4f10970a1f68c6d24557~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="1e3b1763cf19402fbd0988d356fcd590.png"></p> <p>所以说，我们对于 <code>Http请求异常</code> 的捕获需求就是：<code>全局统一监控</code>、<code>报错的具体接口</code>、<code>请求状态码</code>、<code>请求耗时</code>以及<code>请求参数</code>等等；</p> <p>而为了实现上述的监控需求，我们需要了解到：现在异步请求的底层原理都是调用的 <code>XMLHttpRequest</code> 或者 <code>Fetch</code>，我们只需要对这两个方法都进行 <code>劫持</code> ，就可以往接口请求的过程中加入我们所需要的一些参数捕获；</p> <h5 id="代码实现"><a href="#代码实现" class="header-anchor">#</a> 代码实现</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 初始化 HTTP请求异常 的数据获取和上报
initHttpError = (): void =&gt; {
  const loadHandler = (metrics: httpMetrics) =&gt; {
    // 如果 status 状态码小于 400,说明没有 HTTP 请求错误
    if (metrics.status &lt; 400) return;
    const value = metrics.response;
    const exception = {
      // 上报错误归类
      mechanism: {
        type: mechanismType.HP,
      },
      // 错误信息
      value,
      // 错误类型
      type: 'HttpError',
      // 错误的标识码
      errorUid: getErrorUid(`${mechanismType.HP}-${value}-${metrics.statusText}`),
      // 附带信息
      meta: {
        metrics,
      },
    } as ExceptionMetrics;
    // 一般错误异常立刻上报，不用缓存在本地
    this.errorSendHandler(exception);
  };
  proxyXmlHttp(null, loadHandler);
  proxyFetch(null, loadHandler);
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h4 id="跨域脚本错误"><a href="#跨域脚本错误" class="header-anchor">#</a> 跨域脚本错误</h4> <h5 id="介绍"><a href="#介绍" class="header-anchor">#</a> 介绍</h5> <p>还有一种错误，平常我们较难遇到，那就是 <code>跨域脚本错误</code> ，什么叫 <code>跨域脚本错误</code> 呢？比如说我们新建一个<code>texterror.js</code> 文件到 <code>项目B</code> 的 public 目录下以供外部访问;</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 新建的 texterror.js 文件
const a = new Array(-1);
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以看到，我们在 <code>texterror.js</code> 文件中<strong>写了一行会报错的代码</strong>，认真看过上文的同学应该知道，它会被捕获在 <code>JS运行异常</code>中，且错误类型为 <code>RangeError</code> ；而我们从 <code>项目A</code> 中引入它；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 项目B的地址，和项目A端口不同；
&lt;script async src=&quot;http://xxxxxx:8081/texterror.js&quot;&gt; &lt;/script&gt;
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>加载后运行，我们自然能在控制台发现报错：而我们上文的代码捕获也有错误捕获到：</strong></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2cf0152a75746de8013d120f07e9ceb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="99e47b449f444af3be512799d4933ddf.png"></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/000f4b4a285444c9984c5cb62435dfd4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p> <p>但是我们发现，这里的 <code>msg</code> 信息是 <code>Script error</code>，也没有获取到<code>行号</code>、<code>列号</code>、<code>文件名</code>等的信息，<strong>这是怎么回事呢？</strong></p> <p>其实这是浏览器的一个<code>安全机制</code>：<strong>当跨域加载的脚本中发生语法错误时，浏览器出于安全考虑，不会报告错误的细节，而只报告简单的 <code>Script error</code>。浏览器只允许同域下的脚本捕获具体错误信息，而其他脚本只知道发生了一个错误，但无法获知错误的具体内容（控制台仍然可以看到，JS脚本无法捕获）</strong> ，我们上文通过项目A去加载项目B的文件，自然产生了跨域；</p> <h5 id="处理"><a href="#处理" class="header-anchor">#</a> 处理</h5> <p><strong>其实对于三方脚本的错误，我们是否捕获都可以</strong>，不过我们需要一点处理，<strong>如果不需要捕获的话，就不进行上报</strong>，如果需要捕获的话，只上报类型；我们甚至可以只关心自己的远端JS问题，去根据公司域名进行过滤 filename。</p> <p>我们对上文的 <code>window.addEventListener('error')</code> <strong>再加上对跨域资源的判断</strong>，以和正常的代码中错误区分开；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 初始化 跨域异常 的数据获取和上报
initCorsError = (): void =&gt; {
  const handler = (event: ErrorEvent) =&gt; {
    // 阻止向上抛出控制台报错
    event.preventDefault();
    // 如果不是跨域脚本异常,就结束
    if (getErrorKey(event) !== mechanismType.CS) return;
    const exception = {
      // 上报错误归类
      mechanism: {
        type: mechanismType.CS,
      },
      // 错误信息
      value: event.message,
      // 错误类型
      type: 'CorsError',
      // 错误的标识码
      errorUid: getErrorUid(`${mechanismType.JS}-${event.message}`),
      // 附带信息
      meta: {},
    } as ExceptionMetrics;
    // 自行上报异常，也可以跨域脚本的异常都不上报;
    this.errorSendHandler(exception);
  };
  window.addEventListener('error', (event) =&gt; handler(event), true);
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h5 id="补充"><a href="#补充" class="header-anchor">#</a> 补充</h5> <p>看到了这里，可能还有的同学想了解：<strong>那么这种跨域的脚本错误我们就没有办法进行获取错误详情吗</strong>？答案还是有的：</p> <p>我们只需要 <strong><code>开启跨域资源共享CORS（Cross Origin Resource Sharing）</code></strong> ，就可以捕获错误了~我们需要分两步来进行实现：</p> <ol><li><strong>添加<code>crossorigin=&quot;anonymous&quot;</code>属性。</strong></li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;script src=&quot;http://xxxxxxxx/texterror.js&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="2"><li><strong>添加<code>跨域HTTP响应头</code>。</strong></li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>Access-Control-Allow-Origin: *
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这两步完成后，允许了跨域，我们就可以在错误捕获脚本中获取到具体的错误信息拉！</p> <h4 id="vue2、vue3-错误捕获"><a href="#vue2、vue3-错误捕获" class="header-anchor">#</a> Vue2、Vue3 错误捕获</h4> <ul><li><code>Vue2</code> 如果在组件渲染时出现运行错误，错误将会被传递至全局 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fdeployment.html%23%25E8%25B7%259F%25E8%25B8%25AA%25E8%25BF%2590%25E8%25A1%258C%25E6%2597%25B6%25E9%2594%2599%25E8%25AF%25AF" title="https://cn.vuejs.org/v2/guide/deployment.html#%E8%B7%9F%E8%B8%AA%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF" target="_blank" rel="noopener noreferrer">Vue.config.errorHandler<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置函数；</li> <li><code>Vue3</code> 同 <code>Vue2</code>，如果在组件渲染时出现运行错误，错误将会被传递至全局的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fguide%2Ftooling%2Fdeployment.html%23%25E8%25B7%259F%25E8%25B8%25AA%25E8%25BF%2590%25E8%25A1%258C%25E6%2597%25B6%25E9%2594%2599%25E8%25AF%25AF" title="https://v3.cn.vuejs.org/guide/tooling/deployment.html#%E8%B7%9F%E8%B8%AA%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF" target="_blank" rel="noopener noreferrer">app.config.errorHandler<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置函数；</li></ul> <p><strong>我们可以利用这两个钩子函数来进行错误捕获</strong>，由于是依赖于 <code>Vue配置函数</code> 的错误捕获，所以我们在<code>初始化</code>时，需要用户将 <code>Vue实例</code> 传进来；</p> <h5 id="获取报错组件名"><a href="#获取报错组件名" class="header-anchor">#</a> 获取报错组件名</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>export interface Vue {
  config: {
    errorHandler?: any;
    warnHandler?: any;
  };
}

export interface ViewModel {
  _isVue?: boolean;
  __isVue?: boolean;
  $root: ViewModel;
  $parent?: ViewModel;
  $props: { [key: string]: any };
  $options: {
    name?: string;
    propsData?: { [key: string]: any };
    _componentTag?: string;
    __file?: string;
  };
}

// 获取报错组件名
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str: string) =&gt; str.replace(classifyRE, (c) =&gt; c.toUpperCase()).replace(/[-_]/g, '');
const ROOT_COMPONENT_NAME = '&lt;Root&gt;';
const ANONYMOUS_COMPONENT_NAME = '&lt;Anonymous&gt;';
export const formatComponentName = (vm: ViewModel, includeFile: Boolean) =&gt; {
  if (!vm) {
    return ANONYMOUS_COMPONENT_NAME;
  }
  if (vm.$root === vm) {
    return ROOT_COMPONENT_NAME;
  }
  const options = vm.$options;
  let name = options.name || options._componentTag;
  const file = options.__file;
  if (!name &amp;&amp; file) {
    const match = file.match(/([^/\]+).vue$/);
    if (match) {
      name = match[1];
    }
  }
  return (
    (name ? `&lt;${classify(name)}&gt;` : ANONYMOUS_COMPONENT_NAME) + (file &amp;&amp; includeFile !== false ? ` at ${file}` : '')
  );
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><h5 id="初始化封装"><a href="#初始化封装" class="header-anchor">#</a> 初始化封装</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 只需要在外部把初始化好的 Vue 对象传入即可~
// 初始化 Vue异常 的数据获取和上报
initVueError = (app: Vue): void =&gt; {
  app.config.errorHandler = (err: Error, vm: ViewModel, info: string): void =&gt; {
    const componentName = formatComponentName(vm, false);
    const exception = {
      // 上报错误归类
      mechanism: {
        type: mechanismType.VUE,
      },
      // 错误信息
      value: err.message,
      // 错误类型
      type: err.name,
      // 解析后的错误堆栈
      stackTrace: {
        frames: parseStackFrames(err),
      },
      // 错误的标识码
      errorUid: getErrorUid(`${mechanismType.JS}-${err.message}-${componentName}-${info}`),
      // 附带信息
      meta: {
        // 报错的Vue组件名
        componentName,
        // 报错的Vue阶段
        hook: info,
      },
    } as ExceptionMetrics;
    // 一般错误异常立刻上报，不用缓存在本地
    this.errorSendHandler(exception);
  };
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><h4 id="react-错误捕获"><a href="#react-错误捕获" class="header-anchor">#</a> React 错误捕获</h4> <p><code>React</code> 一样也有官方提供的错误捕获，见文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Freact-component.html%23componentdidcatch" title="https://zh-hans.reactjs.org/docs/react-component.html#componentdidcatch" target="_blank" rel="noopener noreferrer">zh-hans.reactjs.org/docs/react-…<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>和 <code>Vue</code> 不同的是，我们需要<strong>自己定义一个高阶组件暴露给项目使用</strong>，我这里就不具体详写了，感兴趣的同学可以自己进行补全：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import * as React from 'react';
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
  }
  // ...
  componentDidCatch(error, info) {
    // &quot;组件堆栈&quot; 例子:
    //   in ComponentThatThrows (created by App)
    //   in ErrorBoundary (created by App)
    //   in div (created by App)
    //   in App
  }
  // ...
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>项目使用方只需要这样既可：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import React from &quot;react&quot;;

&lt;ErrorBoundary&gt;
  &lt;Example /&gt;
&lt;/ErrorBoundary&gt;;
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="source-map"><a href="#source-map" class="header-anchor">#</a> Source Map</h4> <p>我们的项目想要部署上线，就需要将项目源码经过<code>混淆</code>、<code>压缩</code>、<code>babel编译转化</code>等等的操作之后，生成最终的<code>打包产物</code>，再进行线上部署；而这样<code>混淆后的代码</code>，我们基本上无法阅读，<strong>即使在上文的错误监控里，我们获取了报错代码的行号、列号等关键信息，我们也无法找到具体的<code>源码位置所在</code></strong>；这个时候就需要请出我们的 <code>Sourcemap</code> 了</p> <p><strong><code>Sourcemap</code> 本质上是一个信息文件</strong>，里面储存着代码转换前后的对应位置信息。它记录了转换压缩后的代码所对应的转换前的源代码位置，是源代码和生产代码的映射。</p> <p>我们通过种种打包工具打包后，如果开启了 <code>Sourcemap</code> 功能，就会在打包产物里发现后缀为 <code>.map</code> 的文件，<strong>通过对它的解析，我们就可以得到项目的源代码；</strong></p> <ul><li>我这里举例一个通过 <code>nodejs</code> 进行 <code>SourceMap</code> 解析的例子代码：</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 这里因为 npm 装了 babel，所以用的 import，正常 nodejs 下为 require
import sourceMap from 'source-map';    //source-map库
import fs from 'fs'                    //fs为nodejs读取文件的库
import rp from 'request-promise'

/**
 * @description:  用来解析 sourcemap 的函数方法
 * @param {*} sourceMapFile 传入的 .map 源文件
 * @param {*} line  报错行数
 * @param {*} column  报错列数
 * @param {*} offset  需要截取几行的代码
 * @return {*}
 */
export const sourceMapAnalysis = async (sourceMapFile, line, column, offset) =&gt; {
// 通过 sourceMap 库转换为sourceMapConsumer对象
  const consumer = await new sourceMap.SourceMapConsumer(sourceMapFile);
  // 传入要查找的行列数，查找到压缩前的源文件及行列数
  const sm = consumer.originalPositionFor({
    line, // 压缩后的行数
    column, // 压缩后的列数
  });
  // 压缩前的所有源文件列表
  const { sources } = consumer;
  // 根据查到的source，到源文件列表中查找索引位置
  const smIndex = sources.indexOf(sm.source);
  // 到源码列表中查到源代码
  const smContent = consumer.sourcesContent[smIndex];
  // 将源代码串按&quot;行结束标记&quot;拆分为数组形式
  const rawLines = smContent.split(/\r?\n/g);
  let begin = sm.line - offset;
  const end = sm.line + offset + 1;
  begin = begin &lt; 0 ? 0 : begin;
  const context = rawLines.slice(begin, end);
  // 可以根据自己的需要，在末尾处加上 \n
  // const context = rawLines.slice(begin, end).join('\n');
  // 销毁
  consumer.destroy();
  return {
    // 报错的具体代码
    context,
    // 报错在文件的第几行
    originLine: sm.line + 1, // line 是从 0 开始数，所以 +1
    // source 报错的文件路径
    source: sm.source,
  }
};

// 请求线上的 .map 文件进行解析
export const loadMapFileByUrl = async (url)=&gt;{
  return await rp(url)
}
const line = 9;
const column = 492621;
const rawSourceMap = JSON.parse(
  // 这里加载在本地的 .map 文件
  fs.readFileSync('./xxxxxxxxxxxxxxx.map','utf-8').toString()    // 路径自拟
);
const inlineSourceMap = JSON.parse(await loadMapFileByUrl('http://xxxxxxxxxxxx.map')) // 路径自换

// 从url获取 sourcemap 文件
// const res = await sourceMapAnalysis(inlineSourceMap,line,column,2)
// 从本地获取 sourcemap 文件
const res = await sourceMapAnalysis(rawSourceMap,line,column,2)

console.log(res);
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br></div></div><p><strong><code>效果如下:</code></strong></p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b37ce5ba6ee45a68cd4580df18da884~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="d35fa52dcdb1439ebb64a112223b0848.png"></p> <blockquote><p>注意：使用 <code>Sourcemap</code> 的同学注意在打包的时候，将 <code>.map</code> 文件和<code>部署产物</code>分离，<strong>不能部署到线上地址哦！</strong> 如果你将 <code>.map</code> 部署上去了，那么你项目的代码也就是直接明文跑在网页上，<strong>谁都可以查看未混淆的源码拉！</strong></p></blockquote> <h3 id="参考阅读"><a href="#参考阅读" class="header-anchor">#</a> 参考阅读</h3> <p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Freact-component.html%23componentdidcatch" title="https://zh-hans.reactjs.org/docs/react-component.html#componentdidcatch" target="_blank" rel="noopener noreferrer">React componentDidCatch<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://link.juejin.cn?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fdeployment.html%23%25E8%25B7%259F%25E8%25B8%25AA%25E8%25BF%2590%25E8%25A1%258C%25E6%2597%25B6%25E9%2594%2599%25E8%25AF%25AF" title="https://cn.vuejs.org/v2/guide/deployment.html#%E8%B7%9F%E8%B8%AA%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF" target="_blank" rel="noopener noreferrer">Vue errorHandler<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgetsentry%2Fsentry-javascript" title="https://github.com/getsentry/sentry-javascript" target="_blank" rel="noopener noreferrer">sentry-javascript 源码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2/23/2023, 8:50:24 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/knows/project/前端监控/前端监控-行为监控.html" class="prev">
        前端监控-行为监控
      </a></span> <span class="next"><a href="/knows/project/前端监控/前端监控-架构设计.html">
        前端监控-架构设计
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.282508ef.js" defer></script><script src="/assets/js/2.a1cbaef5.js" defer></script><script src="/assets/js/92.23834236.js" defer></script>
  </body>
</html>
