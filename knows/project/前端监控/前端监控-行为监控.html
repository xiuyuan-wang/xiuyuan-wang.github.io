<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前言 | 倘若有一天</title>
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/header.jpg">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.a427340b.css" as="style"><link rel="preload" href="/assets/js/app.282508ef.js" as="script"><link rel="preload" href="/assets/js/2.a1cbaef5.js" as="script"><link rel="preload" href="/assets/js/91.2acf88e1.js" as="script"><link rel="prefetch" href="/assets/js/10.2c98332c.js"><link rel="prefetch" href="/assets/js/100.393ab2a4.js"><link rel="prefetch" href="/assets/js/101.78c1f8b6.js"><link rel="prefetch" href="/assets/js/102.85d15ad3.js"><link rel="prefetch" href="/assets/js/103.b2c501a5.js"><link rel="prefetch" href="/assets/js/104.c0ed595d.js"><link rel="prefetch" href="/assets/js/105.f15f5366.js"><link rel="prefetch" href="/assets/js/106.61151c5e.js"><link rel="prefetch" href="/assets/js/107.d39240eb.js"><link rel="prefetch" href="/assets/js/108.f716bda5.js"><link rel="prefetch" href="/assets/js/109.fbc135d0.js"><link rel="prefetch" href="/assets/js/11.f005400c.js"><link rel="prefetch" href="/assets/js/110.3928667b.js"><link rel="prefetch" href="/assets/js/111.b13a0b48.js"><link rel="prefetch" href="/assets/js/112.7b5006f4.js"><link rel="prefetch" href="/assets/js/113.0d31f132.js"><link rel="prefetch" href="/assets/js/114.2bb5d9e1.js"><link rel="prefetch" href="/assets/js/115.5e64c1e5.js"><link rel="prefetch" href="/assets/js/116.3ee73b77.js"><link rel="prefetch" href="/assets/js/117.f50cff54.js"><link rel="prefetch" href="/assets/js/118.2689f48f.js"><link rel="prefetch" href="/assets/js/119.6426d3f6.js"><link rel="prefetch" href="/assets/js/12.cf3e63d8.js"><link rel="prefetch" href="/assets/js/120.363e12a7.js"><link rel="prefetch" href="/assets/js/121.85ec9cf3.js"><link rel="prefetch" href="/assets/js/13.81302ba4.js"><link rel="prefetch" href="/assets/js/14.9afc1667.js"><link rel="prefetch" href="/assets/js/15.c564a464.js"><link rel="prefetch" href="/assets/js/16.3f8c98ff.js"><link rel="prefetch" href="/assets/js/17.1d432112.js"><link rel="prefetch" href="/assets/js/18.66992dd5.js"><link rel="prefetch" href="/assets/js/19.3a5615bc.js"><link rel="prefetch" href="/assets/js/20.9e0b5237.js"><link rel="prefetch" href="/assets/js/21.f51d933b.js"><link rel="prefetch" href="/assets/js/22.aaa8538e.js"><link rel="prefetch" href="/assets/js/23.e4f94cd3.js"><link rel="prefetch" href="/assets/js/24.5deee84c.js"><link rel="prefetch" href="/assets/js/25.9b363258.js"><link rel="prefetch" href="/assets/js/26.c6083244.js"><link rel="prefetch" href="/assets/js/27.9ebc4263.js"><link rel="prefetch" href="/assets/js/28.d4a74cd6.js"><link rel="prefetch" href="/assets/js/29.bb4db167.js"><link rel="prefetch" href="/assets/js/3.17384045.js"><link rel="prefetch" href="/assets/js/30.3b68b547.js"><link rel="prefetch" href="/assets/js/31.58ba7ddf.js"><link rel="prefetch" href="/assets/js/32.886b3dd0.js"><link rel="prefetch" href="/assets/js/33.5e65a6cc.js"><link rel="prefetch" href="/assets/js/34.25b5b82b.js"><link rel="prefetch" href="/assets/js/35.f8d6f114.js"><link rel="prefetch" href="/assets/js/36.aea7921b.js"><link rel="prefetch" href="/assets/js/37.5c6156f9.js"><link rel="prefetch" href="/assets/js/38.588a6193.js"><link rel="prefetch" href="/assets/js/39.e9ceb0e8.js"><link rel="prefetch" href="/assets/js/4.ac8c0f23.js"><link rel="prefetch" href="/assets/js/40.9acab66e.js"><link rel="prefetch" href="/assets/js/41.97497b1c.js"><link rel="prefetch" href="/assets/js/42.873f16b5.js"><link rel="prefetch" href="/assets/js/43.4d558e3f.js"><link rel="prefetch" href="/assets/js/44.645dab32.js"><link rel="prefetch" href="/assets/js/45.1f2b148b.js"><link rel="prefetch" href="/assets/js/46.f6b30a8a.js"><link rel="prefetch" href="/assets/js/47.6f082f8d.js"><link rel="prefetch" href="/assets/js/48.ce777f64.js"><link rel="prefetch" href="/assets/js/49.570a21ec.js"><link rel="prefetch" href="/assets/js/5.8a91f847.js"><link rel="prefetch" href="/assets/js/50.7d81323a.js"><link rel="prefetch" href="/assets/js/51.0303e90b.js"><link rel="prefetch" href="/assets/js/52.97f8b439.js"><link rel="prefetch" href="/assets/js/53.3fd3c6a9.js"><link rel="prefetch" href="/assets/js/54.d0eb83b3.js"><link rel="prefetch" href="/assets/js/55.32fdcecc.js"><link rel="prefetch" href="/assets/js/56.fbfc09a3.js"><link rel="prefetch" href="/assets/js/57.547120c7.js"><link rel="prefetch" href="/assets/js/58.8ca04f20.js"><link rel="prefetch" href="/assets/js/59.50e6f206.js"><link rel="prefetch" href="/assets/js/6.c966999c.js"><link rel="prefetch" href="/assets/js/60.03d4b566.js"><link rel="prefetch" href="/assets/js/61.03af23bf.js"><link rel="prefetch" href="/assets/js/62.cf5f882a.js"><link rel="prefetch" href="/assets/js/63.8389c2c6.js"><link rel="prefetch" href="/assets/js/64.56a6a39f.js"><link rel="prefetch" href="/assets/js/65.2934948c.js"><link rel="prefetch" href="/assets/js/66.e050480c.js"><link rel="prefetch" href="/assets/js/67.a03accad.js"><link rel="prefetch" href="/assets/js/68.fa9364ed.js"><link rel="prefetch" href="/assets/js/69.2fbeaf39.js"><link rel="prefetch" href="/assets/js/7.971eb831.js"><link rel="prefetch" href="/assets/js/70.89ef1589.js"><link rel="prefetch" href="/assets/js/71.a41e8134.js"><link rel="prefetch" href="/assets/js/72.ba2ffe87.js"><link rel="prefetch" href="/assets/js/73.113b3d76.js"><link rel="prefetch" href="/assets/js/74.4dd54a46.js"><link rel="prefetch" href="/assets/js/75.98bbb07f.js"><link rel="prefetch" href="/assets/js/76.6cee2f65.js"><link rel="prefetch" href="/assets/js/77.0bc53ebb.js"><link rel="prefetch" href="/assets/js/78.8617cec2.js"><link rel="prefetch" href="/assets/js/79.137d3747.js"><link rel="prefetch" href="/assets/js/8.c941beae.js"><link rel="prefetch" href="/assets/js/80.130e6609.js"><link rel="prefetch" href="/assets/js/81.0b3bf721.js"><link rel="prefetch" href="/assets/js/82.982380fc.js"><link rel="prefetch" href="/assets/js/83.501eca82.js"><link rel="prefetch" href="/assets/js/84.66e5994c.js"><link rel="prefetch" href="/assets/js/85.df1ae8de.js"><link rel="prefetch" href="/assets/js/86.565baee7.js"><link rel="prefetch" href="/assets/js/87.3244d4ef.js"><link rel="prefetch" href="/assets/js/88.f104eed0.js"><link rel="prefetch" href="/assets/js/89.592f4c57.js"><link rel="prefetch" href="/assets/js/9.1002202d.js"><link rel="prefetch" href="/assets/js/90.db5ee901.js"><link rel="prefetch" href="/assets/js/92.23834236.js"><link rel="prefetch" href="/assets/js/93.33612d70.js"><link rel="prefetch" href="/assets/js/94.3262e5a7.js"><link rel="prefetch" href="/assets/js/95.48027147.js"><link rel="prefetch" href="/assets/js/96.a9ed0cf0.js"><link rel="prefetch" href="/assets/js/97.48930c53.js"><link rel="prefetch" href="/assets/js/98.4a046e5f.js"><link rel="prefetch" href="/assets/js/99.aff15256.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a427340b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/header.jpg" alt="倘若有一天" class="logo"> <span class="site-name can-hide">倘若有一天</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/knows/" class="nav-link router-link-active">
  前端
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  数据可视化
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/knows/" class="nav-link router-link-active">
  前端
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  数据可视化
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>前端方案</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knows/project/001.html" class="sidebar-link">指南</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>即时通讯</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>前端监控</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knows/project/前端监控/前端监控-性能监控.html" class="sidebar-link">前端监控-性能监控</a></li><li><a href="/knows/project/前端监控/前端监控-行为监控.html" class="active sidebar-link">前端监控-行为监控</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/knows/project/前端监控/前端监控-错误监控.html" class="sidebar-link">前端监控-错误监控</a></li><li><a href="/knows/project/前端监控/前端监控-架构设计.html" class="sidebar-link">前端监控-架构设计</a></li><li><a href="/knows/project/前端监控/前端日志上报.html" class="sidebar-link">前端日志上报</a></li><li><a href="/knows/project/前端监控/神策分析.html" class="sidebar-link">神策分析 Web JS SDK</a></li></ul></section></li><li><a href="/knows/project/PWA/使用offline-plugin实现PWA.html" class="sidebar-link">使用offline-plugin实现PWA</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>微前端</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h3> <p>上篇文章我们分享了关于 <code>页面性能监控</code> 的内容，本文我们接着来看 <code>用户行为监控</code> 的方面</p> <h3 id="系列文章传送门"><a href="#系列文章传送门" class="header-anchor">#</a> 系列文章传送门</h3> <p><a href="https://juejin.cn/post/7097157902862909471" title="https://juejin.cn/post/7097157902862909471" target="_blank" rel="noopener noreferrer">一文摸清前端监控实践要点（一）性能监控<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/7098656658649251877" title="https://juejin.cn/post/7098656658649251877" target="_blank" rel="noopener noreferrer">一文摸清前端监控实践要点（二）行为监控<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/7100841779854835719/" title="https://juejin.cn/post/7100841779854835719/" target="_blank" rel="noopener noreferrer">一文摸清前端监控实践要点（三）错误监控<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/7108660942686126093" title="https://juejin.cn/post/7108660942686126093" target="_blank" rel="noopener noreferrer">腾讯三面：说说前端监控告警分析平台的架构设计和难点亮点？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="用户的行为特征"><a href="#用户的行为特征" class="header-anchor">#</a> 用户的行为特征</h3> <p>为什么要做用户的行为情况监控？其实也就是问：<strong>采集了用户的行为信息后我们能做什么</strong>，答案其实很简单：</p> <ul><li>PV、UV量，日同比、周同比等。能清晰的明白流量变化。</li> <li>用户热点页面、高访问量TOP10</li> <li>设备、浏览器语言、浏览器、活跃时间段等的用户特征</li> <li>用户的行为追踪：某个用户，进入了网站后的一系列操作或者跳转行为；</li> <li>用户自定义埋点上报用户行为：想做一些自定义事件的监听，比如播放某个视频的行为动作。</li> <li>多语种站点，每个语种的用户量</li></ul> <h4 id="整体封装"><a href="#整体封装" class="header-anchor">#</a> 整体封装</h4> <p>跟上文一样，这边先附上整体的一个初始化封装;</p> <h5 id="数据暂存"><a href="#数据暂存" class="header-anchor">#</a> 数据暂存</h5> <p>暂存在 store 里的数据跟 <code>文一：性能监控</code> 基本类似，这里就附一下用户行为所多的参数</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export enum metricsName {
  PI = 'page-information',
  OI = 'origin-information',
  RCR = 'router-change-record',
  CBR = 'click-behavior-record',
  CDR = 'custom-define-record',
  HT = 'http-record',
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h5 id="整体初始化"><a href="#整体初始化" class="header-anchor">#</a> 整体初始化</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default class UserVitals {
  private engineInstance: EngineInstance;

  // 本地暂存数据在 Map 里 （也可以自己用对象来存储）
  public metrics: UserMetricsStore;

  public breadcrumbs: BehaviorStore;

  public customHandler: Function;

  // 最大行为追踪记录数
  public maxBehaviorRecords: number;

  // 允许捕获click事件的DOM标签 eg:button div img canvas
  clickMountList: Array&lt;string&gt;;

  constructor(engineInstance: EngineInstance) {
    this.engineInstance = engineInstance;
    this.metrics = new UserMetricsStore();
    // 限制最大行为追踪记录数为 100，真实场景下需要外部传入自定义;
    this.maxBehaviorRecords = 100;
    // 初始化行为追踪记录
    this.breadcrumbs = new BehaviorStore({ maxBehaviorRecords: this.maxBehaviorRecords });
    // 初始化 用户自定义 事件捕获
    this.customHandler = this.initCustomerHandler();
    // 作为 真实sdk 的时候，需要在初始化时传入与默认值合并;
    this.clickMountList = ['button'].map((x) =&gt; x.toLowerCase());
    // 重写事件
    wrHistory();
    // 初始化页面基本信息
    this.initPageInfo();
    // 初始化路由跳转获取
    this.initRouteChange();
    // 初始化用户来路信息获取
    this.initOriginInfo();
    // 初始化 PV 的获取;
    this.initPV();
    // 初始化 click 事件捕获
    this.initClickHandler(this.clickMountList);
    // 初始化 Http 请求事件捕获
    this.initHttpHandler();
    // 上报策略在后几篇细说
  }

  // 封装用户行为的上报入口
  userSendHandler = (data: IMetrics) =&gt; {
    // 进行通知内核实例进行上报;
  };

  // 补齐 pathname 和 timestamp 参数
  getExtends = (): { page: string; timestamp: number | string } =&gt; {
    return {
      page: this.getPageInfo().pathname,
      timestamp: new Date().getTime(),
    };
  };

  // 初始化用户自定义埋点数据的获取上报
  initCustomerHandler = (): Function =&gt; {
    //... 详情代码在下文
  };

  // 初始化 PI 页面基本信息的获取以及返回
  initPageInfo = (): void =&gt; {
    //... 详情代码在下文
  };

  // 初始化 RCR 路由跳转的获取以及返回
  initRouteChange = (): void =&gt; {
    //... 详情代码在下文
  };

  // 初始化 PV 的获取以及返回
  initPV = (): void =&gt; {
    //... 详情代码在下文
  };

  // 初始化 OI 用户来路的获取以及返回
  initOriginInfo = (): void =&gt; {
    //... 详情代码在下文
  };

  // 初始化 CBR 点击事件的获取和返回
  initClickHandler = (mountList: Array&lt;string&gt;): void =&gt; {
    //... 详情代码在下文
  };

  // 初始化 http 请求的数据获取和上报
  initHttpHandler = (): void =&gt; {
    //... 详情代码在下文
  };
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br></div></div><h4 id="用户的基本信息"><a href="#用户的基本信息" class="header-anchor">#</a> 用户的基本信息</h4> <p>获取用户一些基本的信息；包括：<code>当前访问的网页路径</code>、<code>浏览器语种</code>、<code>屏幕大小</code>、<code>等等</code></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export interface PageInformation {
  host: string;
  hostname: string;
  href: string;
  protocol: string;
  origin: string;
  port: string;
  pathname: string;
  search: string;
  hash: string;
  // 网页标题
  title: string;
  // 浏览器的语种 (eg:zh) ; 这里截取前两位，有需要也可以不截取
  language: string;
  // 用户 userAgent 信息
  userAgent?: string;
  // 屏幕宽高 (eg:1920x1080)  屏幕宽高意为整个显示屏的宽高
  winScreen: string;
  // 文档宽高 (eg:1388x937)   文档宽高意为当前页面显示的实际宽高（有的同学喜欢半屏显示）
  docScreen: string;
}

// 获取 PI 页面基本信息
getPageInfo = (): PageInformation =&gt; {
  const { host, hostname, href, protocol, origin, port, pathname, search, hash } = window.location;
  const { width, height } = window.screen;
  const { language, userAgent } = navigator;

  return {
    host,
    hostname,
    href,
    protocol,
    origin,
    port,
    pathname,
    search,
    hash,
    title: document.title,
    language: language.substr(0, 2),
    userAgent,
    winScreen: `${width}x${height}`,
    docScreen: `${document.documentElement.clientWidth || document.body.clientWidth}x${
      document.documentElement.clientHeight || document.body.clientHeight
    }`,
  };
};

// 初始化 PI 页面基本信息的获取以及返回
initPageInfo = (): void =&gt; {
  const info: PageInformation = this.getPageInfo();
  const metrics = info as IMetrics;
  this.metrics.set(metricsName.PI, metrics);
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br></div></div><h4 id="用户行为记录栈"><a href="#用户行为记录栈" class="header-anchor">#</a> 用户行为记录栈</h4> <p><strong>有时候，我们需要去获取用户</strong>的一个<code>行为追踪记录</code>（比如说：<code>出现了一个线上异常，我们要追溯异常如何发生</code>），这虽然说可能算是错误监控里面的内容，不过数据捕获部分我们就放在这章 <code>行为监控</code> 里讲，也就是说，用户自从打开我们的网站后，看了什么，点击了什么</p> <p>一般来说，我们所谈到的用户行为记录栈，<code>需要追踪的事件包括以下</code>：</p> <ul><li>路由跳转行为</li> <li>点击行为</li> <li>ajax 请求行为</li> <li>用户自定义事件</li></ul> <p><strong>捕获上面的四个行为，只需要在上述四个事件的代码中做数据捕获就可以了，我们放下下面的叙述中细细说明</strong>，这里我就贴一下封装 <code>用户行为记录栈</code> 的代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export interface behaviorRecordsOptions {
  maxBehaviorRecords: number;
}

export interface behaviorStack {
  name: metricsName;
  page: string;
  timestamp: number | string;
  value: Object;
}

// 暂存用户的行为记录追踪
export default class behaviorStore {
  // 数组形式的 stack
  private state: Array&lt;behaviorStack&gt;;

  // 记录的最大数量
  private maxBehaviorRecords: number;

  // 外部传入 options 初始化，
  constructor(options: behaviorRecordsOptions) {
    const { maxBehaviorRecords } = options;
    this.maxBehaviorRecords = maxBehaviorRecords;
    this.state = [];
  }

  // 从底部插入一个元素，且不超过 maxBehaviorRecords 限制数量
  push(value: behaviorStack) {
    if (this.length() === this.maxBehaviorRecords) {
      this.shift();
    }
    this.state.push(value);
  }

  // 从顶部删除一个元素，返回删除的元素
  shift() {
    return this.state.shift();
  }

  length() {
    return this.state.length;
  }

  get() {
    return this.state;
  }

  clear() {
    this.state = [];
  }
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br></div></div><h4 id="路由跳转"><a href="#路由跳转" class="header-anchor">#</a> 路由跳转</h4> <p>一般的路由跳转行为，都是针对于 <code>SPA单页应用</code>的，因为对于非单页应用来说，<code>url</code>跳转都以页面刷新的形式;</p> <h5 id="hash-路由"><a href="#hash-路由" class="header-anchor">#</a> Hash 路由</h5> <p><code>hash</code>路由的监听比较简单，大家都知道可以用<code>hashchange</code>来监听，</p> <p>但是 <code>hash</code> 变化除了触发 <code>hashchange</code> ,也会触发 <code>popstate</code> 事件,而且会先触发 <code>popstate</code> 事件，我们可以统一监听 <code>popstate</code></p> <h5 id="history-路由"><a href="#history-路由" class="header-anchor">#</a> History 路由</h5> <p>接着往下阅读之前，我们先来了解一下，<code>html5</code> 的 <code>History API</code> ，它所支持的 <code>API</code> 有以下五个</p> <ul><li><code>history.back()</code></li> <li><code>history.go()</code></li> <li><code>history.forward()</code></li> <li><code>history.pushState()</code></li> <li><code>history.replaceState()</code></li></ul> <p>同时在 <code>History API</code> 中还有一个 <code>事件</code> ，该事件为 <code>popstate</code>;它有着以下<strong>特点</strong>;</p> <ul><li><code>History.back()</code>、<code>History.forward()</code>、<code>History.go()</code>在被<strong>调用</strong>时，会触发 <code>popstate事件</code></li> <li>但是<code>History.pushState()</code>和<code>History.replaceState()</code>不会触发 <code>popstate事件</code>。</li></ul> <p>所以我们需要对 <code>replaceState</code> 和 <code>pushState</code>，去<strong>创建新的全局Event事件</strong>。然后 <code>window.addEventListener</code> 监听我们加的 <code>Event</code> 即可</p> <h5 id="封装"><a href="#封装" class="header-anchor">#</a> 封装</h5> <ul><li><strong>简单封装一下</strong> 以适合上文的<code>整体封装</code></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 派发出新的 Event
const wr = (type: keyof History) =&gt; {
  const orig = history[type];
  return function (this: unknown) {
    const rv = orig.apply(this, arguments);
    const e = new Event(type);
    window.dispatchEvent(e);
    return rv;
  };
};

// 添加 pushState replaceState 事件
export const wrHistory = (): void =&gt; {
  history.pushState = wr('pushState');
  history.replaceState = wr('replaceState');
};

// 为 pushState 以及 replaceState 方法添加 Event 事件
export const proxyHistory = (handler: Function): void =&gt; {
  // 添加对 replaceState 的监听
  window.addEventListener('replaceState', (e) =&gt; handler(e), true);
  // 添加对 pushState 的监听
  window.addEventListener('pushState', (e) =&gt; handler(e), true);
};

export const proxyHash = (handler: Function): void =&gt; {
  // 添加对 hashchange 的监听
  // hash 变化除了触发 hashchange ,也会触发 popstate 事件,而且会先触发 popstate 事件，我们可以统一监听 popstate
  // 这里可以考虑是否需要监听 hashchange,或者只监听 hashchange
  window.addEventListener('hashchange', (e) =&gt; handler(e), true);
  // 添加对 popstate 的监听
  // 浏览器回退、前进行为触发的 可以自己判断是否要添加监听
  window.addEventListener('popstate', (e) =&gt; handler(e), true);
};

// 初始化 RCR 路由跳转的获取以及返回
initRouteChange = (): void =&gt; {
  const handler = (e: Event) =&gt; {
    // 正常记录
    const metrics = {
      // 跳转的方法 eg:replaceState
      jumpType: e.type,
      // 创建时间
      timestamp: new Date().getTime(),
      // 页面信息
      pageInfo: this.getPageInfo(),
    } as IMetrics;
    // 一般路由跳转的信息不会进行上报，根据业务形态决定；
    this.metrics.add(metricsName.RCR, metrics);
    // 行为记录 不需要携带 pageInfo
    delete metrics.pageInfo;
    // 记录到行为记录追踪
    const behavior = {
      category: metricsName.RCR,
      data: metrics,
      ...this.getExtends(),
    } as behaviorStack;
    this.breadcrumbs.push(behavior);
  };
  proxyHash(handler);
  // 为 pushState 以及 replaceState 方法添加 Evetn 事件
  proxyHistory(handler);
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br></div></div><h4 id="pv、uv"><a href="#pv、uv" class="header-anchor">#</a> PV、UV</h4> <p>首先我们来了解一下 PV 和 UV 的定义：</p> <ul><li><code>PV</code> 是页面访问量</li> <li><code>UV</code> 是24小时内(<code>00:00-24:00</code>)访问的独立用户数。</li></ul> <p>那么了解了 PV 和 UV 各是什么之后，我们应该如何做才能采集这两个数据指标呢？其实很简单</p> <ul><li><code>PV</code> 只需要在<code>用户每次进入页面的时候</code>，进行上报即可，这里需要注意 <code>SPA单页面</code> 应用的PV上报需要结合上面的路由跳转进行；</li> <li><code>UV</code> 我们就会转为<code>使用服务端进行采集</code>，当服务端判断到上报的 <code>PV所属的IP</code>结合<code>登录信息或者用户标志</code>，是当天的第一次上报时，就给它记录一次 <code>UV</code></li></ul> <p>那么按照这个逻辑，我们的 <code>PV上报代码</code> 可以像这样写，<strong>简单封装一下</strong>；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 初始化 PV 的获取以及返回
initPV = (): void =&gt; {
  const handler = () =&gt; {
    const metrics = {
      // 还有一些标识用户身份的信息，由项目使用方传入，任意拓展 eg:userId
      // 创建时间
      timestamp: new Date().getTime(),
      // 页面信息
      pageInfo: this.getPageInfo(),
      // 用户来路
      originInformation: getOriginInfo(),
    } as IMetrics;
    this.userSendHandler(metrics);
    // 一般来说， PV 可以立即上报
  };
  afterLoad(() =&gt; {
    handler();
  });
  proxyHash(handler);
  // 为 pushState 以及 replaceState 方法添加 Evetn 事件
  proxyHistory(handler);
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h4 id="点击事件"><a href="#点击事件" class="header-anchor">#</a> 点击事件</h4> <p><strong>有时，我们获取用户的点击情况是非常有价值的</strong>，<code>比如说有以下场景</code>：</p> <ul><li>网站的首页有三个推广广告，那么哪一个广告更能够吸引用户的点击？</li> <li>放在网页上的视频是否有人进行播放？播放量为多少？</li> <li>......等等等等</li></ul> <p>简而言之，我们如果能够捕获到用户的点击行为，是能够得到一些非常具有价值的指标数据的，<code>当然我们也不是要获取用户的所有点击</code>，里面会包含很多的无意义点击行为，我们需要获取的是具有一些指标意义的点击行为，这就<code>需要一定的过滤</code>，过滤可以根据标签、id、class等等进行过滤：</p> <ul><li><strong>简单封装一下</strong> 以适合上文的<code>整体封装</code></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 初始化 CBR 点击事件的获取和返回
initClickHandler = (mountList: Array&lt;string&gt;): void =&gt; {
  const handler = (e: MouseEvent | any) =&gt; {
    // 这里是根据 tagName 进行是否需要捕获事件的依据，可以根据自己的需要，额外判断id\class等
    // 先判断浏览器支持 e.path ，从 path 里先取
    let target = e.path?.find((x: Element) =&gt; mountList.includes(x.tagName?.toLowerCase()));
    // 不支持 path 就再判断 target
    target = target || (mountList.includes(e.target.tagName?.toLowerCase()) ? e.target : undefined);
    if (!target) return;
    const metrics = {
      tagInfo: {
        id: target.id,
        classList: Array.from(target.classList),
        tagName: target.tagName,
        text: target.textContent,
      },
      // 创建时间
      timestamp: new Date().getTime(),
      // 页面信息
      pageInfo: this.getPageInfo(),
    } as IMetrics;
    // 除开商城业务外，一般不会特意上报点击行为的数据，都是作为辅助检查错误的数据存在;
    this.metrics.add(metricsName.CBR, metrics);
    // 行为记录 不需要携带 完整的pageInfo
    delete metrics.pageInfo;
    // 记录到行为记录追踪
    const behavior = {
      category: metricsName.CBR,
      data: metrics,
      ...this.getExtends(),
    } as behaviorStack;
    this.breadcrumbs.push(behavior);
  };
  window.addEventListener(
    'click',
    (e) =&gt; {
      handler(e);
    },
    true,
  );
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><blockquote><p>同理，如果我们想捕获 <code>input</code>、<code>keydown</code>、<code>doubleClick</code> 也是类似的写法，有兴趣的可以自行拓展</p></blockquote> <h4 id="用户自定义埋点"><a href="#用户自定义埋点" class="header-anchor">#</a> 用户自定义埋点</h4> <p>其实用户自定义埋点这个东西，并没有那么神秘和复杂，原理也就是 SDK 内部暴露出接口供 <code>项目使用方</code> 调用，这样用户就可以<code>在任意的时间段</code>（<code>页面加载</code>、<code>用户点击</code>、<code>观看视频达到一半进度</code>....等等）去调用接口 <code>上报任意的自定义内容</code>；</p> <p>而我们 SDK 暴露出的接口，可以由SDK挂载在 <code>window</code> 上，也可以通过暴露接口的方式给外部调用；</p> <p>然后在服务端再进行<code>数据的归类分析</code>，就<strong>完成了用户自定义埋点的一系列流程</strong>；实现起来很简单，但是重要的是什么呢？是数据结构的定义，定义的数据结构需要能让服务端方便进行归类分析；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 这里参考了 谷歌GA 的自定义埋点上报数据维度结构
export interface customAnalyticsData {
  // 事件类别 互动的对象 eg:Video
  eventCategory: string;
  // 事件动作 互动动作方式 eg:play
  eventAction: string;
  // 事件标签 对事件进行分类 eg:
  eventLabel: string;
  // 事件值 与事件相关的数值   eg:180min
  eventValue?: string;
}

// 初始化用户自定义埋点数据的获取上报
initCustomerHandler = (): Function =&gt; {
  const handler = (options: customAnalyticsData) =&gt; {
    // 记录到 UserMetricsStore
    this.metrics.add(metricsName.CDR, options);
    // 自定义埋点的信息一般立即上报
    this.userSendHandler(options);
    // 记录到用户行为记录栈
    this.breadcrumbs.push({
      category: metricsName.CDR,
      data: options,
      ...this.getExtends(),
    });
  };

  return handler;
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h4 id="http-请求捕获"><a href="#http-请求捕获" class="header-anchor">#</a> HTTP 请求捕获</h4> <p><code>HTTP行为</code> 也是<code>用户行为追踪</code>的重要一环，有的时候，页面出现问题往往是 HTTP 请求了某些数据，渲染造成的；而除了是<code>用户行为追踪</code>的重要一环外；采集 <code>HTTP请求</code> 的各种信息：包括 <code>请求地址</code>、<code>方法</code>、<code>耗时</code>、<code>请求时间</code>、<code>响应时间</code>、<code>响应结果</code>等等等等...</p> <p>而为了实现上述的监控需求，我们需要了解到：现在异步请求的底层原理都是调用的 <code>XMLHttpRequest</code> 或者 <code>Fetch</code>，我们只需要对这两个方法都进行 <code>劫持</code> ，就可以往接口请求的过程中加入我们所需要的一些参数捕获；</p> <h5 id="xmlhttprequest-的劫持"><a href="#xmlhttprequest-的劫持" class="header-anchor">#</a> XMLHttpRequest 的劫持</h5> <p>预期就是，我们只需要传入一个 <code>loadHandler</code> 方法，它就自动会在 <code>请求</code> 结束时给我返回该有的数据</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export interface httpMetrics {
  method: string;
  url: string | URL;
  body: Document | XMLHttpRequestBodyInit | null | undefined | ReadableStream;
  requestTime: number;
  responseTime: number;
  status: number;
  statusText: string;
  response?: any;
}

// 调用 proxyXmlHttp 即可完成全局监听 XMLHttpRequest
export const proxyXmlHttp = (sendHandler: Function | null | undefined, loadHandler: Function) =&gt; {
  if ('XMLHttpRequest' in window &amp;&amp; typeof window.XMLHttpRequest === 'function') {
    const oXMLHttpRequest = window.XMLHttpRequest;
    if (!(window as any).oXMLHttpRequest) {
      // oXMLHttpRequest 为原生的 XMLHttpRequest，可以用以 SDK 进行数据上报，区分业务
      (window as any).oXMLHttpRequest = oXMLHttpRequest;
    }
    (window as any).XMLHttpRequest = function () {
      // 覆写 window.XMLHttpRequest
      const xhr = new oXMLHttpRequest();
      const { open, send } = xhr;
      let metrics = {} as httpMetrics;
      xhr.open = (method, url) =&gt; {
        metrics.method = method;
        metrics.url = url;
        open.call(xhr, method, url, true);
      };
      xhr.send = (body) =&gt; {
        metrics.body = body || '';
        metrics.requestTime = new Date().getTime();
        // sendHandler 可以在发送 Ajax 请求之前，挂载一些信息，比如 header 请求头
        // setRequestHeader 设置请求header，用来传输关键参数等
        // xhr.setRequestHeader('xxx-id', 'VQVE-QEBQ');
        if (typeof sendHandler === 'function') sendHandler(xhr);
        send.call(xhr, body);
      };
      xhr.addEventListener('loadend', () =&gt; {
        const { status, statusText, response } = xhr;
        metrics = {
          ...metrics,
          status,
          statusText,
          response,
          responseTime: new Date().getTime(),
        };
        if (typeof loadHandler === 'function') loadHandler(metrics);
        // xhr.status 状态码
      });
      return xhr;
    };
  }
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br></div></div><h5 id="fetch-的劫持"><a href="#fetch-的劫持" class="header-anchor">#</a> Fetch 的劫持</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 调用 proxyFetch 即可完成全局监听 fetch
export const proxyFetch = (sendHandler: Function | null | undefined, loadHandler: Function) =&gt; {
  if ('fetch' in window &amp;&amp; typeof window.fetch === 'function') {
    const oFetch = window.fetch;
    if (!(window as any).oFetch) {
      (window as any).oFetch = oFetch;
    }
    (window as any).fetch = async (input: any, init: RequestInit) =&gt; {
      // init 是用户手动传入的 fetch 请求互数据，包括了 method、body、headers，要做统一拦截数据修改，直接改init即可
      if (typeof sendHandler === 'function') sendHandler(init);
      let metrics = {} as httpMetrics;

      metrics.method = init?.method || '';
      metrics.url = (input &amp;&amp; typeof input !== 'string' ? input?.url : input) || ''; // 请求的url
      metrics.body = init?.body || '';
      metrics.requestTime = new Date().getTime();

      return oFetch.call(window, input, init).then(async (response) =&gt; {
        // clone 出一个新的 response,再用其做.text(),避免 body stream already read 问题
        const res = response.clone();
        metrics = {
          ...metrics,
          status: res.status,
          statusText: res.statusText,
          response: await res.text(),
          responseTime: new Date().getTime(),
        };
        if (typeof loadHandler === 'function') loadHandler(metrics);
        return response;
      });
    };
  }
};

复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h5 id="简单初始化封装"><a href="#简单初始化封装" class="header-anchor">#</a> 简单初始化封装</h5> <p>上面都是 proxy 劫持接口的封装，具体的调用看如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 初始化 http 请求的数据获取和上报
initHttpHandler = (): void =&gt; {
  const loadHandler = (metrics: httpMetrics) =&gt; {
    if (metrics.status &lt; 400) {
      // 对于正常请求的 HTTP 请求来说,不需要记录 请求体 和 响应体
      delete metrics.response;
      delete metrics.body;
    }
    // 记录到 UserMetricsStore
    this.metrics.add(metricsName.HT, metrics);
    // 记录到用户行为记录栈
    this.breadcrumbs.push({
      category: metricsName.HT,
      data: metrics,
      ...this.getExtends(),
    });
  };
  proxyXmlHttp(null, loadHandler);
  proxyFetch(null, loadHandler);
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h4 id="页面停留时间"><a href="#页面停留时间" class="header-anchor">#</a> 页面停留时间</h4> <p>还有一项比较通用的指标，叫做页面停留时间，是通过统计用户在每个页面的停留时间而成的</p> <p>这里给一个<code>简单的采集实例代码思路</code> <strong>（未封装）</strong> ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const routeList = [];
const routeTemplate = {
  userId: '', // 用户信息等
  // 除了userId以外，还可以附带一些其余的用户特征到这里面
  url: '',
  startTime: 0,
  dulation: 0,
  endTime: 0,
};
function recordNextPage() {
  // 记录前一个页面的页面停留时间
  const time = new Date().getTime();
  routeList[routeList.length - 1].endTime = time;
  routeList[routeList.length - 1].dulation = time - routeList[routeList.length - 1].startTime;
  // 推一个新的页面停留记录
  routeList.push({
    ...routeTemplate,
    ...{ url: window.location.pathname, startTime: time, dulation: 0, endTime: 0 },
  });
}
// 第一次进入页面时,记录
window.addEventListener('load', () =&gt; {
  const time = new Date().getTime();
  routeList.push({
    ...routeTemplate,
    ...{ url: window.location.pathname, startTime: time, dulation: 0, endTime: 0 },
  });
});
// 单页面应用触发 replaceState 时的上报
window.addEventListener('replaceState', () =&gt; {
  recordNextPage();
});
// 单页面应用触发 pushState 时的上报
window.addEventListener('pushState', () =&gt; {
  recordNextPage();
});
// 浏览器回退、前进行为触发的 可以自己判断是否要上报
window.addEventListener('popstate', () =&gt; {
  recordNextPage();
});
// 关闭浏览器前记录最后的时间并上报
window.addEventListener('beforeunload', () =&gt; {
  const time = new Date().getTime();
  routeList[routeList.length - 1].endTime = time;
  routeList[routeList.length - 1].dulation = time - routeList[routeList.length - 1].startTime;
  // 记录完了离开的时间，就可以上报了
  // eg: report()
});
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br></div></div><h4 id="访客来路"><a href="#访客来路" class="header-anchor">#</a> 访客来路</h4> <p>有的时候，产品可能会问我们几个<code>直击灵魂的问题</code>：</p> <ul><li>我们现在的<strong>新用户流量</strong>，大部分都是从哪里引流过来的啊？</li> <li><strong>线上环境404页面访问激增</strong>，我想知道用户是访问了哪个不存在页面才跳到 404 的</li></ul> <p>很简单，采集一下<code>用户来路</code>的数据就可以了，原理就是获取 <code>document.referrer</code> 以及<code>window.performance.navigation.type</code></p> <h5 id="用户来路地址"><a href="#用户来路地址" class="header-anchor">#</a> 用户来路地址</h5> <p>我们可以直接用 <code>document.referrer</code> 来获取用户在我们的网页上的<strong>前一个网页地址</strong>；但是需要注意的是，有几个场景我们<code>获取到的值会是空</code></p> <ul><li>直接在地址栏中输入地址跳转</li> <li>直接通过浏览器收藏夹打开</li> <li>从https的网站直接进入一个http协议的网站</li></ul> <h5 id="用户来路方式"><a href="#用户来路方式" class="header-anchor">#</a> 用户来路方式</h5> <p>我们可以直接使用 <code>window.performance.navigation.type</code> 来获取用户在我们网页上的<strong>来路方式</strong></p> <p><strong>该属性返回一个整数值，可能有以下4种情况</strong></p> <ul><li><code>0</code>: 点击链接、地址栏输入、表单提交、脚本操作等。</li> <li><code>1</code>: 点击重新加载按钮、location.reload。</li> <li><code>2</code>: 点击前进或后退按钮。</li> <li><code>255</code>: 任何其他来源。即非刷新/非前进后退、非点击链接/地址栏输入/表单提交/脚本操作等。</li></ul> <h5 id="代码封装"><a href="#代码封装" class="header-anchor">#</a> 代码封装</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>export interface OriginInformation {
  referrer: string;
  type: number | string;
}

// 返回 OI 用户来路信息
export const getOriginInfo = (): OriginInformation =&gt; {
  return {
    referrer: document.referrer,
    type: window.performance?.navigation.type || '',
  };
};

// 初始化 OI 用户来路的获取以及返回
initOriginInfo = (): void =&gt; {
  const info: OriginInformation = getOriginInfo();
  const metrics = info as IMetrics;
  this.metrics.set(metricsName.OI, metrics);
};
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h4 id="user-agent-解析"><a href="#user-agent-解析" class="header-anchor">#</a> User Agent 解析</h4> <p>我们的 <code>User Agent</code> 信息里面有带有很多的信息，<code>比如浏览器内核</code>、<code>设备类型等等</code>，但是解析它并不是个简单的事情，如果我们自己写的话，会用到很多的正则表达式去解析它，所以这边推荐<code>两个现成的插件</code>来使用：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flancedikson%2Fbowser" title="https://github.com/lancedikson/bowser" target="_blank" rel="noopener noreferrer">bowser<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffaisalman%2Fua-parser-js" title="https://github.com/faisalman/ua-parser-js" target="_blank" rel="noopener noreferrer">ua-parser-js<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// nodejs 环境下 require
const parser = require('ua-parser-js');
const Bowser = require('bowser');
// 获取user-agent解析
function getFeature(userAgent) {
  const browserData = Bowser.parse(userAgent);
  const parserData = parser(userAgent);
  const browserName = browserData.browser.name || parserData.browser.name; // 浏览器名
  const browserVersion = browserData.browser.version || parserData.browser.version; // 浏览器版本号
  const osName = browserData.os.name || parserData.os.name; // 操作系统名
  const osVersion = parserData.os.version || browserData.os.version; // 操作系统版本号
  const deviceType = browserData.platform.type || parserData.device.type; // 设备类型
  const deviceVendor = browserData.platform.vendor || parserData.device.vendor || ''; // 设备所属公司
  const deviceModel = browserData.platform.model || parserData.device.model || ''; // 设备型号
  const engineName = browserData.engine.name || parserData.engine.name; // engine名
  const engineVersion = browserData.engine.version || parserData.engine.version; // engine版本号
  return {
    browserName,
    browserVersion,
    osName,
    osVersion,
    deviceType,
    deviceVendor,
    deviceModel,
    engineName,
    engineVersion,
  };
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h4 id="ip-采集解析"><a href="#ip-采集解析" class="header-anchor">#</a> IP 采集解析</h4> <p>为什么要采集 IP 呢？其实很简单，我们可以通过解析 IP 地址，来解析出用户的<code>地域</code>、<code>网络运营商等信息</code>；而<code>解析IP</code>我们可以使用诸如腾讯云、阿里云等各种的 <code>三方API</code> 来实现；但是<code>采集 IP 信息</code>就需要我们自己来进行实现了；</p> <p>具体来说，<code>IP</code> 并不是一个通过 <code>JS SDK</code> 来采集的<strong>指标数据</strong>，我们需要在服务端去获取访问过来的IP地址，<code>获取 IP 地址的方法</code>我建议先阅读一下这篇文章： <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.runoob.com%2Fw3cnote%2Fhttp-x-forwarded-for.html" title="https://www.runoob.com/w3cnote/http-x-forwarded-for.html" target="_blank" rel="noopener noreferrer">HTTP X-Forwarded-For 介绍 | 菜鸟教程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>直接贴结论</strong>：</p> <ul><li><strong>对于直接面向用户部署的 Web 应用</strong>，<code>必须使用</code>从 TCP 连接中得到的 <code>Remote Address</code>；</li> <li><strong>对于部署了 Nginx 这样反向代理的 Web 应用</strong>，可以使用 Nginx 传过来的 <code>X-Real-IP</code> 或 <code>X-Forwarded-For 最后一节</code>（实际上它们一定等价）。</li></ul> <p><strong>我这边举例一下 Nginx 下的获取，这里取 <code>x-real-ip</code> 或 <code>x-forwarded-for</code> 的最后一节即可</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// nodejs 代码
const http = require('http');

function getIp(req) {
  const ip = (req.headers['x-forwarded-for'] || req.connection.remoteAddress).replace('::ffff:', '');
  // 取 x-forwarded-for 的话再做一个取最后一节的处理
  return ip === '::1' ? '127.0.0.1' : ip;
}
http
  .createServer((req, res) =&gt; {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    // 先取x-real-ip
    // 再取service里的自定义方法，取x-forwarded-for最后一节
    const ip = req.headers['x-real-ip'] || getIp(req);
    res.write(`ip: ${ip}\n`);
    res.end();
  })
  .listen(9009, '0.0.0.0');
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h4 id="参考链接"><a href="#参考链接" class="header-anchor">#</a> 参考链接</h4> <p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.runoob.com%2Fw3cnote%2Fhttp-x-forwarded-for.html" title="https://www.runoob.com/w3cnote/http-x-forwarded-for.html" target="_blank" rel="noopener noreferrer">HTTP X-Forwarded-For 介绍 | 菜鸟教程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2/23/2023, 8:50:24 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/knows/project/前端监控/前端监控-性能监控.html" class="prev">
        前端监控-性能监控
      </a></span> <span class="next"><a href="/knows/project/前端监控/前端监控-错误监控.html">
        前端监控-错误监控
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.282508ef.js" defer></script><script src="/assets/js/2.a1cbaef5.js" defer></script><script src="/assets/js/91.2acf88e1.js" defer></script>
  </body>
</html>
